<meta charset="utf8"><style>body,html{width:100vw;height:100vh;margin:0;padding:0;background-color:#0a1a2f}#d1{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}#d2{max-width:100vw;max-height:100vh;aspect-ratio:48/27}#canvas{width:100%;height:100%}</style><div id="d1"><div id="d2"><canvas id="canvas"></canvas></div></div><script>(function () {
    'use strict';

    /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
    *
    * Copyright (c) 2011-2013 Marcus Geelnard
    *
    * This software is provided 'as-is', without any express or implied
    * warranty. In no event will the authors be held liable for any damages
    * arising from the use of this software.
    *
    * Permission is granted to anyone to use this software for any purpose,
    * including commercial applications, and to alter it and redistribute it
    * freely, subject to the following restrictions:
    *
    * 1. The origin of this software must not be misrepresented; you must not
    *    claim that you wrote the original software. If you use this software
    *    in a product, an acknowledgment in the product documentation would be
    *    appreciated but is not required.
    *
    * 2. Altered source versions must be plainly marked as such, and must not be
    *    misrepresented as being the original software.
    *
    * 3. This notice may not be removed or altered from any source
    *    distribution.
    *
    */


    // Some general notes and recommendations:
    //  * This code uses modern ECMAScript features, such as ** instead of
    //    Math.pow(). You may have to modify the code to make it work on older
    //    browsers.
    //  * If you're not using all the functionality (e.g. not all oscillator types,
    //    or certain effects), you can reduce the size of the player routine even
    //    further by deleting the code.


    const CPlayer = function() {

        //--------------------------------------------------------------------------
        // Private methods
        //--------------------------------------------------------------------------

        // Oscillators
        var osc_sin = function (value) {
            return Math.sin(value * 6.283184);
        };

        var osc_saw = function (value) {
            return 2 * (value % 1) - 1;
        };

        var osc_square = function (value) {
            return (value % 1) < 0.5 ? 1 : -1;
        };

        var osc_tri = function (value) {
            var v2 = (value % 1) * 4;
            if(v2 < 2) return v2 - 1;
            return 3 - v2;
        };

        var getnotefreq = function (n) {
            // 174.61.. / 44100 = 0.003959503758 (F3)
            return 0.003959503758 * (2 ** ((n - 128) / 12));
        };

        var createNote = function (instr, n, rowLen) {
            var osc1 = mOscillators[instr.i[0]],
                o1vol = instr.i[1],
                o1xenv = instr.i[3]/32,
                osc2 = mOscillators[instr.i[4]],
                o2vol = instr.i[5],
                o2xenv = instr.i[8]/32,
                noiseVol = instr.i[9],
                attack = instr.i[10] * instr.i[10] * 4,
                sustain = instr.i[11] * instr.i[11] * 4,
                release = instr.i[12] * instr.i[12] * 4,
                releaseInv = 1 / release,
                expDecay = -instr.i[13]/16,
                arp = instr.i[14],
                arpInterval = rowLen * (2 **(2 - instr.i[15]));

            var noteBuf = new Int32Array(attack + sustain + release);

            // Re-trig oscillators
            var c1 = 0, c2 = 0;

            // Local variables.
            var j, j2, e, rsample, o1t, o2t;

            // Generate one note (attack + sustain + release)
            for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
                if (j2 >= 0) {
                    // Switch arpeggio note.
                    arp = (arp >> 8) | ((arp & 255) << 4);
                    j2 -= arpInterval;

                    // Calculate note frequencies for the oscillators
                    o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                    o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
                }

                // Envelope
                e = 1;
                if (j < attack) {
                    e = j / attack;
                } else if (j >= attack + sustain) {
                    e = (j - attack - sustain) * releaseInv;
                    e = (1 - e) * (3 ** (expDecay * e));
                }

                // Oscillator 1
                c1 += o1t * e ** o1xenv;
                rsample = osc1(c1) * o1vol;

                // Oscillator 2
                c2 += o2t * e ** o2xenv;
                rsample += osc2(c2) * o2vol;

                // Noise oscillator
                if (noiseVol) {
                    rsample += (2 * Math.random() - 1) * noiseVol;
                }

                // Add to (mono) channel buffer
                noteBuf[j] = (80 * rsample * e) | 0;
            }

            return noteBuf;
        };


        //--------------------------------------------------------------------------
        // Private members
        //--------------------------------------------------------------------------

        // Array of oscillator functions
        var mOscillators = [
            osc_sin,
            osc_square,
            osc_saw,
            osc_tri
        ];

        // Private variables set up by init()
        var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf;


        //--------------------------------------------------------------------------
        // Initialization
        //--------------------------------------------------------------------------

        this.init = function (song) {
            // Define the song
            mSong = song;

            // Init iteration state variables
            mLastRow = song.endPattern;
            mCurrentCol = 0;

            // Prepare song info
            mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

            // Create work buffer (initially cleared)
            mMixBuf = new Int32Array(mNumWords);
        };


        //--------------------------------------------------------------------------
        // Public methods
        //--------------------------------------------------------------------------

        // Generate audio data for a single track
        this.generate = function () {
            // Local variables
            var i, j, p, row, col, n, cp,
                k, t, rsample, rowStartSample, f;

            // Put performance critical items in local variables
            var chnBuf = new Int32Array(mNumWords),
                instr = mSong.songData[mCurrentCol],
                rowLen = mSong.rowLen,
                patternLen = mSong.patternLen;

            // Clear effect state
            var low = 0, band = 0, high;
            var lsample, filterActive = false;

            // Clear note cache.
            var noteCache = [];

             // Patterns
             for (p = 0; p <= mLastRow; ++p) {
                cp = instr.p[p];

                // Pattern rows
                for (row = 0; row < patternLen; ++row) {
                    // Execute effect command.
                    var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                    if (cmdNo) {
                        instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                        // Clear the note cache since the instrument has changed.
                        if (cmdNo < 17) {
                            noteCache = [];
                        }
                    }

                    // Put performance critical instrument properties in local variables
                    var oscLFO = mOscillators[instr.i[16]],
                        lfoAmt = instr.i[17] / 512,
                        lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                        fxLFO = instr.i[19],
                        fxFilter = instr.i[20],
                        fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                        q = 1 - instr.i[22] / 255,
                        dist = instr.i[23] * 1e-5,
                        drive = instr.i[24] / 32,
                        panAmt = instr.i[25] / 512,
                        panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                        dlyAmt = instr.i[27] / 255,
                        dly = instr.i[28] * rowLen & -2;  // Must be an even number

                    // Calculate start sample number for this row in the pattern
                    rowStartSample = (p * patternLen + row) * rowLen;

                    // Generate notes for this pattern row
                    for (col = 0; col < 4; ++col) {
                        n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                        if (n) {
                            if (!noteCache[n]) {
                                noteCache[n] = createNote(instr, n, rowLen);
                            }

                            // Copy note from the note cache
                            var noteBuf = noteCache[n];
                            for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                              chnBuf[i] += noteBuf[j];
                            }
                        }
                    }

                    // Perform effects for this pattern row
                    for (j = 0; j < rowLen; j++) {
                        // Dry mono-sample
                        k = (rowStartSample + j) * 2;
                        rsample = chnBuf[k];

                        // We only do effects if we have some sound input
                        if (rsample || filterActive) {
                            // State variable filter
                            f = fxFreq;
                            if (fxLFO) {
                                f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                            }
                            f = 1.5 * Math.sin(f);
                            low += f * band;
                            high = q * (rsample - band) - low;
                            band += f * high;
                            rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                            // Distortion
                            if (dist) {
                                rsample *= dist;
                                rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                                rsample /= dist;
                            }

                            // Drive
                            rsample *= drive;

                            // Is the filter active (i.e. still audiable)?
                            filterActive = rsample * rsample > 1e-5;

                            // Panning
                            t = Math.sin(panFreq * k) * panAmt + 0.5;
                            lsample = rsample * (1 - t);
                            rsample *= t;
                        } else {
                            lsample = 0;
                        }

                        // Delay is always done, since it does not need sound input
                        if (k >= dly) {
                            // Left channel = left + right[-p] * t
                            lsample += chnBuf[k-dly+1] * dlyAmt;

                            // Right channel = right + left[-p] * t
                            rsample += chnBuf[k-dly] * dlyAmt;
                        }

                        // Store in stereo channel buffer (needed for the delay effect)
                        chnBuf[k] = lsample | 0;
                        chnBuf[k+1] = rsample | 0;

                        // ...and add to stereo mix buffer
                        mMixBuf[k] += lsample | 0;
                        mMixBuf[k+1] += rsample | 0;
                    }
                }
            }

            // Next iteration. Return progress (1.0 == done!).
            mCurrentCol++;
            return mCurrentCol / mSong.numChannels;
        };

        // Create a AudioBuffer from the generated audio data
        this.createAudioBuffer = function(context) {
            var buffer = context.createBuffer(2, mNumWords / 2, 44100);
            for (var i = 0; i < 2; i ++) {
                var data = buffer.getChannelData(i);
                for (var j = i; j < mNumWords; j += 2) {
                    data[j >> 1] = mMixBuf[j] / 65536;
                }
            }
            return buffer;
        };

        // Create a WAVE formatted Uint8Array from the generated audio data
        this.createWave = function() {
            // Create WAVE header
            var headerLen = 44;
            var l1 = headerLen + mNumWords * 2 - 8;
            var l2 = l1 - 36;
            var wave = new Uint8Array(headerLen + mNumWords * 2);
            wave.set(
                [82,73,70,70,
                 l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
                 87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
                 68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
                 l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
            );

            // Append actual wave data
            for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
                // Note: We clamp here
                var y = mMixBuf[i];
                y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
                wave[idx++] = y & 255;
                wave[idx++] = (y >> 8) & 255;
            }

            // Return the WAVE formatted typed array
            return wave;
        };

        // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
        this.getData = function(t, n) {
            var i = 2 * Math.floor(t * 44100);
            var d = new Array(n);
            for (var j = 0; j < 2*n; j += 1) {
                var k = i + j;
                d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
            }
            return d;
        };
    };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const VillageHusk = {
          songData: [
            { // Instrument 3
              i: [
              0, // OSC1_WAVEFORM
              255, // OSC1_VOL
              116, // OSC1_SEMI
              79, // OSC1_XENV
              0, // OSC2_WAVEFORM
              255, // OSC2_VOL
              116, // OSC2_SEMI
              0, // OSC2_DETUNE
              83, // OSC2_XENV
              0, // NOISE_VOL
              4, // ENV_ATTACK
              6, // ENV_SUSTAIN
              69, // ENV_RELEASE
              52, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              14, // FX_FREQ
              0, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              0, // FX_PAN_AMT
              0, // FX_PAN_FREQ
              0, // FX_DELAY_AMT
              0 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,127,127,,,,,,127,127,,,,,,127,127,,,,,,127,127],
                 f: []}
              ]
            },
            { // Instrument 4
              i: [
              0, // OSC1_WAVEFORM
              255, // OSC1_VOL
              116, // OSC1_SEMI
              85, // OSC1_XENV
              0, // OSC2_WAVEFORM
              255, // OSC2_VOL
              116, // OSC2_SEMI
              0, // OSC2_DETUNE
              37, // OSC2_XENV
              14, // NOISE_VOL
              4, // ENV_ATTACK
              6, // ENV_SUSTAIN
              73, // ENV_RELEASE
              99, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              136, // FX_FREQ
              15, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              0, // FX_PAN_AMT
              0, // FX_PAN_FREQ
              66, // FX_DELAY_AMT
              6 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [,,,,,139,,,,,,,139,,,,,,,139,,,,,,,139],
                 f: []}
              ]
            },
            { // Instrument 5
              i: [
              0, // OSC1_WAVEFORM
              91, // OSC1_VOL
              128, // OSC1_SEMI
              0, // OSC1_XENV
              0, // OSC2_WAVEFORM
              95, // OSC2_VOL
              128, // OSC2_SEMI
              12, // OSC2_DETUNE
              0, // OSC2_XENV
              0, // NOISE_VOL
              12, // ENV_ATTACK
              0, // ENV_SUSTAIN
              72, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              255, // FX_FREQ
              0, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              83, // FX_PAN_AMT
              3, // FX_PAN_FREQ
              93, // FX_DELAY_AMT
              4 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,3,3,3,3,3,2,3,2,6,3,2,3,6,3,2,3,6,3,2,3,6,3,5,7],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [132,,132,,132,,,132,,,,,,,127,,139,,127,,,127,,,127,,,,135,,135,,135,,,135,,131,,127,,,130,,130,,130,,,130,,,130,,,,139,,139,,139,,,139,,135,,131,,,134,,134,,134,,,134,,,134,,,,,,,,,,,140,,,,135,,129,,,,,,,,135,,,138,,135],
                 f: []},
                {n: [127,,127,,127,,,127,,,,,,,127,,139,,127,,,127,,,127,,,,130,,130,,130,,,130,,,,,,,130,,130,,130,,,130,,,130,,,,134,,134,,134,,,134,,,,,,,134,,134,,134,,,134,,,134,,,,,,,,,,,135,,,,,,,,,,,,,,135,,,138,,135],
                 f: []},
                {n: [127,,127,,127,,,127,,,,139,127,,127,,139,,127,,,127,,,133,,133,,130,,130,,130,,,130,,,,,130,,130,,130,,130,,,130,,139,136,,136,,134,,134,,134,,,134,,,,,134,,134,,134,,134,,,134,,,140,,140,,,,,,,,,135,,,,,137,,,,,,,,,135,,,141,,,137],
                 f: []},
                {n: [127,,127,,127,,,133,,133,,130,,,127,,,,127,,,,,,,,,,130,,132,,130,,,136,,136,,133,,,130,,130,,,,,,,,,,,,134,,134,,134,,139,,,140,,137,,,134,,134,,,,,,,,,,,,,,,,,,,141,,,,,,135,,,,,,,,135,,,138],
                 f: []},
                {n: [127,,127,,127,,,133,,133,,130,,,127,,139,,127,,,127,,,127,,,,130,,132,,130,,,136,,136,,133,,,130,,130,,130,,,130,,,130,,,,134,,134,,134,,139,,,140,,137,,,134,,134,,134,,,134,,,134,,,,,,,,,,,141,,,,,,135,,,,,,,,135,,,138,,135],
                 f: []},
                {n: [127,,127,,127,,,127,,127,,127,,,,,,,,,,,,,,,,,130,,134,,130,,,130,,130,,130,,,,,,,,,,,,,,,,,,,,,,,,,,135,,138],
                 f: []}
              ]
            },
            { // Instrument 6
              i: [
              2, // OSC1_WAVEFORM
              40, // OSC1_VOL
              140, // OSC1_SEMI
              64, // OSC1_XENV
              0, // OSC2_WAVEFORM
              0, // OSC2_VOL
              140, // OSC2_SEMI
              0, // OSC2_DETUNE
              0, // OSC2_XENV
              192, // NOISE_VOL
              7, // ENV_ATTACK
              21, // ENV_SUSTAIN
              0, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              3, // FX_FILTER
              161, // FX_FREQ
              192, // FX_RESONANCE
              5, // FX_DIST
              27, // FX_DRIVE
              0, // FX_PAN_AMT
              7, // FX_PAN_FREQ
              25, // FX_DELAY_AMT
              1 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [127,,127,,127,,,127,,127,,127,,,127,,127,,127,,,127,,127,,127],
                 f: []}
              ]
            },
            { // Instrument 7
              i: [
              2, // OSC1_WAVEFORM
              192, // OSC1_VOL
              128, // OSC1_SEMI
              0, // OSC1_XENV
              2, // OSC2_WAVEFORM
              192, // OSC2_VOL
              140, // OSC2_SEMI
              18, // OSC2_DETUNE
              0, // OSC2_XENV
              0, // NOISE_VOL
              27, // ENV_ATTACK
              115, // ENV_SUSTAIN
              138, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              91, // LFO_AMT
              6, // LFO_FREQ
              1, // LFO_FX_FREQ
              2, // FX_FILTER
              8, // FX_FREQ
              92, // FX_RESONANCE
              21, // FX_DIST
              32, // FX_DRIVE
              148, // FX_PAN_AMT
              5, // FX_PAN_FREQ
              85, // FX_DELAY_AMT
              8 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2,3,2,3,,,,,,,,,,,,2,3,2,3,2,3,2,3,2,3,2,3],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,135],
                 f: []},
                {n: [,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,130],
                 f: []}
              ]
            },
          ],
          rowLen: 10023,   // In sample lengths
          patternLen: 28,  // Rows per pattern
          endPattern: 26,  // End pattern
          numChannels: 5  // Number of channels
        };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const Explosion = {
          songData: [
            { // Instrument 2
              i: [
              3, // OSC1_WAVEFORM
              130, // OSC1_VOL
              121, // OSC1_SEMI
              64, // OSC1_XENV
              2, // OSC2_WAVEFORM
              117, // OSC2_VOL
              109, // OSC2_SEMI
              0, // OSC2_DETUNE
              32, // OSC2_XENV
              0, // NOISE_VOL
              28, // ENV_ATTACK
              24, // ENV_SUSTAIN
              60, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              255, // FX_FREQ
              0, // FX_RESONANCE
              2, // FX_DIST
              32, // FX_DRIVE
              83, // FX_PAN_AMT
              5, // FX_PAN_FREQ
              92, // FX_DELAY_AMT
              1 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [139],
                 f: []}
              ]
            },
          ],
          rowLen: 3120,   // In sample lengths
          patternLen: 32,  // Rows per pattern
          endPattern: 0,  // End pattern
          numChannels: 1  // Number of channels
        };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const Wink = {
          songData: [
            { // Instrument 3
              i: [
              3, // OSC1_WAVEFORM
              146, // OSC1_VOL
              140, // OSC1_SEMI
              0, // OSC1_XENV
              1, // OSC2_WAVEFORM
              224, // OSC2_VOL
              128, // OSC2_SEMI
              3, // OSC2_DETUNE
              0, // OSC2_XENV
              0, // NOISE_VOL
              16, // ENV_ATTACK
              13, // ENV_SUSTAIN
              3, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              3, // LFO_WAVEFORM
              179, // LFO_AMT
              5, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              124, // FX_FREQ
              135, // FX_RESONANCE
              11, // FX_DIST
              32, // FX_DRIVE
              150, // FX_PAN_AMT
              3, // FX_PAN_FREQ
              28, // FX_DELAY_AMT
              6 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [146,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,139],
                 f: []}
              ]
            },
          ],
          rowLen: 3120,   // In sample lengths
          patternLen: 32,  // Rows per pattern
          endPattern: 0,  // End pattern
          numChannels: 1  // Number of channels
        };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const Wind = {
          songData: [
            { // Instrument 0
              i: [
              0, // OSC1_WAVEFORM
              0, // OSC1_VOL
              140, // OSC1_SEMI
              0, // OSC1_XENV
              0, // OSC2_WAVEFORM
              0, // OSC2_VOL
              140, // OSC2_SEMI
              0, // OSC2_DETUNE
              0, // OSC2_XENV
              255, // NOISE_VOL
              113, // ENV_ATTACK
              75, // ENV_SUSTAIN
              57, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              51, // LFO_AMT
              2, // LFO_FREQ
              1, // LFO_FX_FREQ
              2, // FX_FILTER
              58, // FX_FREQ
              239, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              88, // FX_PAN_AMT
              1, // FX_PAN_FREQ
              157, // FX_DELAY_AMT
              2 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [139,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,142],
                 f: []}
              ]
            },
          ],
          rowLen: 3120,   // In sample lengths
          patternLen: 32,  // Rows per pattern
          endPattern: 0,  // End pattern
          numChannels: 1  // Number of channels
        };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const Fail = {
          songData: [
            { // Instrument 4
              i: [
              0, // OSC1_WAVEFORM
              255, // OSC1_VOL
              116, // OSC1_SEMI
              64, // OSC1_XENV
              0, // OSC2_WAVEFORM
              255, // OSC2_VOL
              120, // OSC2_SEMI
              0, // OSC2_DETUNE
              64, // OSC2_XENV
              127, // NOISE_VOL
              4, // ENV_ATTACK
              6, // ENV_SUSTAIN
              35, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              14, // FX_FREQ
              0, // FX_RESONANCE
              10, // FX_DIST
              32, // FX_DRIVE
              0, // FX_PAN_AMT
              0, // FX_PAN_FREQ
              0, // FX_DELAY_AMT
              0 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [127,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,139],
                 f: []}
              ]
            },
          ],
          rowLen: 3120,   // In sample lengths
          patternLen: 32,  // Rows per pattern
          endPattern: 0,  // End pattern
          numChannels: 1  // Number of channels
        };

    // Audio


    const Audio = {
        init() {
            Audio.contextCreated = false;
            Audio.readyToPlay = false;
            Audio.musicEnabled = true;
            Audio.sfxEnabled = true;
            Audio.musicVolume = 0;
            Audio.sfxVolume = 0;

            Audio.sounds = {};
        },

        initContext() {
            //console.log('initContext()');
            if (Audio.contextCreated) return;

            // In Safari, ensure our target AudioContext is created inside a
            // click or tap event (this ensures we don't interact with it until
            // after user input).
            //
            // Chrome and Firefox are more relaxed, but this approach works for all 3.
            //ZZFX.x = Audio.ctx = new AudioContext();
            Audio.ctx = new AudioContext();
            Audio.gain_ = Audio.ctx.createGain();
            Audio.gain_.connect(Audio.ctx.destination);
            //ZZFX.destination = Audio.gain_;
            //console.log(Audio.ctx);

            Audio.contextCreated = true;
        },

        initTracks() {
            // In this game, we ensure the screen that calls this function happens after the
            // user has interacted at least once (and that interaction called initContext above),
            // so we know it's safe to interact with the audio context.
            if (!Audio.musicPlaying) {
                // Sfx

                Audio.wink = this.loadSoundBox(Wink);
                Audio.explosion = this.loadSoundBox(Explosion);
                Audio.wind = this.loadSoundBox(Wind);
                Audio.fail = this.loadSoundBox(Fail);
                Audio.music = this.loadSoundBox(VillageHusk);
                Audio.readyToPlay = true;

                // Start music

                Audio.play(Audio.music, Audio.ctx.currentTime + 0.1, true);

                Audio.musicPlaying = true;
            }
        },

        update() {
            if (!Audio.readyToPlay) return;

            this.sfxVolume = this.sfxEnabled ? 0.3 : 0;
            this.musicVolume = this.musicEnabled ? 1 : 0;

            //ZZFX.volume = this.sfxVolume;

            if (this.sfxEnabled) ;
        },

        play(sound, startTime, loop) {
            if (!Audio.readyToPlay) return;
            if (!sound) return;

            //ZZFX.play(...sound);
            //this.sources.explosion.start(Audio.ctx.currentTime);

            let source = Audio.ctx.createBufferSource();
            source.buffer = sound.buffer;
            source.loop = loop || false;
            source.connect(sound.gainNode);
            source.start(startTime || Audio.ctx.currentTime);
        },

        // It's important we do pausing and unpausing as specific events and not in general update(),
        // because update() is triggered by the animation frame trigger which does not run if the
        // page is not visible. (So, if you want the music to fade in the background, for example,
        // that's not helpful if it won't work because you aren't looking at the page!)

        pause() {
            if (Audio.readyToPlay) {
                Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);
            }
        },

        unpause() {
            if (Audio.readyToPlay) {
                Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);
            }
        },

        loadSoundBox(exportedSound) {
            let player = new CPlayer();
            player.init(exportedSound);

            for (;;) {
                if (player.generate() === 1) break;
            }

            let gainNode = Audio.ctx.createGain();
            gainNode.connect(Audio.gain_);

            let buffer = player.createAudioBuffer(Audio.ctx);

            // Return an object containing the original player, the audio node,
            // and the source buffer for playback later.
            return { player, gainNode, buffer };
        }
    };

    // Constants

    // The game's desired dimensions in pixels - the actual dimensions can be adjusted
    // slightly by the Viewport module.
    const TARGET_GAME_WIDTH = 320;
    const TARGET_GAME_HEIGHT = 180;

    // Shortcuts for marker locations on screen
    const INVENTORY_WOOD_POS = { u: 250, v: 131 };
    const INVENTORY_MEAT_POS = { u: 250, v: 143 };
    const INVENTORY_TORCH_POS = { u: 250, v: 155 };
    const INVENTORY_STONE_POS = { u: 250, v: 167 };
    const SANITY_POS = { u: 284, v: 9 };

    // Number of "facing left" villager frames (doubled for facing right)
    const VILLAGER_FRAMES = 12;

    // Frames per second (locked)
    //
    // Other constants below, like gravity, foot speed, etc., are represented as movement PER FRAME.
    const FPS = 42;

    const PALETTE = [
      '#0a1a2f',
      '#04373b',
      '#1a644c',
      '#40985c',
      '#d1cb95'
    ];

    function angle2vector(r, m) {
        return { x: Math.cos(r), y: Math.sin(r), m: m || 1 };
    }

    function rgba(r, g, b, a) {
        return `rgba(${r},${g},${b},${a})`;
    }

    function createCanvas(width, height) {
        let canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        let ctx = canvas.getContext('2d');
        return { canvas, ctx };
    }

    // SpriteSheet

    /**
     * This module is generated by `gulp buildAssets`.
     */
    const SpriteSheet =
        /* <generated> */
    { altar: [ [ 0, 0, 19, 29 ], [ 19, 0, 19, 29 ] ],
      bigarrows: [ [ 0, 29, 15, 8 ] ],
      blackcat: [ [ 0, 37, 24, 36 ], [ 24, 37, 24, 36 ] ],
      bridge: [ [ 0, 73, 31, 16 ], [ 31, 73, 31, 16 ] ],
      button: [ [ 0, 89, 9, 9 ], [ 9, 89, 9, 9 ], [ 18, 89, 9, 9 ] ],
      factory: [ [ 0, 98, 20, 14 ], [ 20, 98, 20, 14 ] ],
      font4: [ [ 0, 112, 270, 12 ] ],
      icons: [ [ 0, 124, 8, 8 ], [ 8, 124, 8, 8 ], [ 16, 124, 8, 8 ], [ 24, 124, 8, 8 ] ],
      influencebar: [ [ 0, 132, 93, 10 ], [ 93, 132, 93, 10 ] ],
      jobselect: [ [ 0, 142, 101, 14 ] ],
      keys: [ [ 0, 156, 18, 9 ], [ 18, 156, 18, 9 ], [ 36, 156, 18, 9 ] ],
      particle:
       [ [ 0, 165, 1, 1 ],
         [ 1, 165, 1, 1 ],
         [ 2, 165, 1, 1 ],
         [ 3, 165, 1, 1 ],
         [ 4, 165, 1, 1 ] ],
      sanitybar: [ [ 0, 166, 18, 82 ], [ 18, 166, 18, 82 ] ],
      smallarrows: [ [ 0, 248, 3, 5 ], [ 3, 248, 3, 5 ], [ 6, 248, 3, 5 ], [ 9, 248, 3, 5 ] ],
      techtree:
       [ [ 0, 253, 17, 15 ],
         [ 17, 253, 17, 15 ],
         [ 34, 253, 17, 15 ],
         [ 51, 253, 17, 15 ],
         [ 68, 253, 17, 15 ],
         [ 85, 253, 17, 15 ],
         [ 102, 253, 17, 15 ] ],
      villager:
       [ [ 0, 268, 22, 30 ],
         [ 22, 268, 22, 30 ],
         [ 44, 268, 22, 30 ],
         [ 66, 268, 22, 30 ],
         [ 88, 268, 22, 30 ],
         [ 110, 268, 22, 30 ],
         [ 132, 268, 22, 30 ],
         [ 154, 268, 22, 30 ],
         [ 176, 268, 22, 30 ],
         [ 198, 268, 22, 30 ],
         [ 220, 268, 22, 30 ],
         [ 242, 268, 22, 30 ] ],
      villagerchunk:
       [ [ 0, 298, 9, 9 ],
         [ 9, 298, 9, 9 ],
         [ 18, 298, 9, 9 ],
         [ 27, 298, 9, 9 ],
         [ 36, 298, 9, 9 ],
         [ 45, 298, 9, 9 ] ],
      villagerdeath: [ [ 0, 307, 13, 22 ] ],
      wink: [ [ 0, 329, 3, 5 ], [ 3, 329, 3, 5 ], [ 6, 329, 3, 5 ], [ 9, 329, 3, 5 ] ],
      terrain_FG1: [ [ 0, 334, 320, 150 ] ],
      terrain_FG2: [ [ 0, 484, 320, 150 ] ],
      terrain_FG3: [ [ 0, 634, 320, 150 ] ],
      base64:
       'data:image/png;base64,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' };
    /* </generated> */

    // Viewport


    /**
     * Viewport
     *
     * Represents the game display (for us, a canvas).
     */
    const Viewport = {
        init() {
            Viewport.canvas = document.getElementById('canvas');
            Viewport.ctx = Viewport.canvas.getContext('2d');
            Viewport.resize();
        },

        // Unlike past years, this canvas does not build in "buffers" to the gameplay canvas,
        // it locks the output canvas at exactly the desired dimensions, and you'll get black bars
        // (horizontal or vertical) depending on browser size.
        //
        // This may or may not be appropriate for every game, but it works for this one, and is
        // a little less code :).
        resize() {
            let dpr = window.devicePixelRatio,
                clientWidth = Viewport.canvas.clientWidth,
                clientHeight = Viewport.canvas.clientHeight;

            // Note: this check is just checking existing dimensions against cached dimensions,
            // help cut out some work if no resize took place. We DON'T hook into the actual
            // browser resize event.
            if (clientWidth !== Viewport.clientWidth || clientHeight !== Viewport.clientHeight) {
                Viewport.width = TARGET_GAME_WIDTH;
                Viewport.height = TARGET_GAME_HEIGHT;

                Viewport.clientWidth = clientWidth;
                Viewport.clientHeight = clientHeight;

                // What is this?
                //
                // Basically, imagine if the browser happens to be 640x360 pixels. If you set
                // your canvas to be size "320x180", and render our pixel art at that size, it
                // will be UPSCALED to 640x360, causing blurriness that cannot be avoided.
                //
                // Instead, we want to render AT LEAST at the actual pixel size. And in fact,
                // if the actual monitor pixels are 2x or 4x pixels like many modern screens,
                // we want to render at that scale and DOWNSCALE if necessary.
                //
                // TLDR: We set the CANVAS size to something that is AT LEAST AS LARGE as
                // (ratio between our desired size and browser pixels) multipled by DPR.
                let pixelScale = Math.ceil(clientWidth * dpr / TARGET_GAME_WIDTH);

                Viewport.canvas.width = TARGET_GAME_WIDTH * pixelScale;
                Viewport.canvas.height = TARGET_GAME_HEIGHT * pixelScale;
                Viewport.scale = pixelScale;

                // Make sure to set this every time the canvas changes size.
                Viewport.ctx.imageSmoothingEnabled = false;
            }

            // We do this every frame, not just on resize, due to browser sometimes "forgetting".
            Viewport.canvas.style.cursor = 'none';
        }
    };

    /**
     * Sprite
     *
     * Encapsulates loading sprite slices from the spritesheet, organizing them, and
     * modifying them or constructing using primitives. To save space, we use some techniques
     * like storing only a small slice of an image in the spritesheet, then using code
     * to duplicate it, add some randomness, etc.
     */
    const Sprite = {
        // This is an exception to the rule, loading the spritesheet is a special action that
        // happens BEFORE everything is initialized.
        loadSpritesheet(cb) {
            let image = new Image();
            image.onload = cb;
            image.src = SpriteSheet.base64;
            Sprite.sheet = image;
        },

        init() {
            // Standard (no special ops) sprites
            const defaultOpts = { anchor: { x: 0, y: 0 } };
            Sprite.font = initBasicSprite(SpriteSheet.font4[0]);
            Sprite.particle = SpriteSheet.particle.map(initBasicSprite);
            Sprite.blackcat = initBasicSpriteArray(SpriteSheet.blackcat, defaultOpts);
            Sprite.button = initBasicSpriteArray(SpriteSheet.button, defaultOpts);
            Sprite.influencebar = initBasicSpriteArray(SpriteSheet.influencebar, defaultOpts);
            Sprite.smallarrows = initBasicSpriteArray(SpriteSheet.smallarrows, defaultOpts);
            Sprite.jobselect = initBasicSpriteArray(SpriteSheet.jobselect, defaultOpts);
            Sprite.bridge = initBasicSpriteArray(SpriteSheet.bridge, defaultOpts);
            Sprite.bigarrows = initBasicSpriteArray(SpriteSheet.bigarrows, defaultOpts);
            Sprite.icons = initBasicSpriteArray(SpriteSheet.icons, defaultOpts);
            Sprite.factory = initBasicSpriteArray(SpriteSheet.factory, defaultOpts);
            Sprite.wink = initBasicSpriteArray(SpriteSheet.wink, defaultOpts);
            Sprite.keys = initBasicSpriteArray(SpriteSheet.keys, defaultOpts);
            Sprite.techtree = initBasicSpriteArray(SpriteSheet.techtree, defaultOpts);

            // Custom anchors
            Sprite.altar = initBasicSpriteArray(SpriteSheet.altar, { anchor: { x: 9, y: 28 } });
            Sprite.villagerdeath = initBasicSpriteArray(SpriteSheet.villagerdeath, { anchor: { x: 6, y: 21 } });
            Sprite.villagerchunk = initBasicSpriteArray(SpriteSheet.villagerchunk, { anchor: { x: 4, y: 4 } });

            // Sanity bar handling
            Sprite.sanitybar = initBasicSpriteArray(SpriteSheet.sanitybar, defaultOpts);
            Sprite.sanitybar[2] = initDynamicSprite(recolor(Sprite.sanitybar[1].img, '#0a1a2f'), defaultOpts);

            // Terrain handling
            Sprite.terrain = [
                initBasicSprite(SpriteSheet.terrain_FG1[0]),
                initBasicSprite(SpriteSheet.terrain_FG2[0]),
                initBasicSprite(SpriteSheet.terrain_FG3[0])
            ];
            for (let i = 0; i < 3; i++) {
                Sprite.terrain[i].img = augmentTerrain(Sprite.terrain[i].img, 30, PALETTE[i]);
            }

            // Villager
            Sprite.villager = initBasicSpriteArray(SpriteSheet.villager, { anchor: { x: 16, y: 29 } });
            const villagerFrames = Sprite.villager.length;
            Sprite.villager[1].img = copySpriteFrame(Sprite.villager[0].img, Sprite.villager[1].img, 22, 28);
            Sprite.villager[8].img = copySpriteFrame(Sprite.villager[7].img, Sprite.villager[8].img, 22, 29);
            Sprite.villager[9].img = copySpriteFrame(Sprite.villager[7].img, Sprite.villager[9].img, 22, 29);
            Sprite.villager[11].img = copySpriteFrame(Sprite.villager[10].img, Sprite.villager[11].img, 22, 29);
            for (let i = 0; i < villagerFrames; i++) {
                Sprite.villager[i + villagerFrames] = initDynamicSprite(flipHorizontal(Sprite.villager[i].img), { anchor: { x: 5, y: 29 } });
            }

        },

        /**
         * A small helper that draws a sprite onto a canvas, respecting the anchor point of
         * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if
         * that's appropriate!
         */
        drawSprite(ctx, sprite, u, v) {
            ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);
        },

        drawViewportSprite(sprite, pos, rotation) {
            let { u, v } = this.viewportSprite2uv(
                sprite,
                pos
            );
            if (rotation) {
                Viewport.ctx.save();
                Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);
                Viewport.ctx.rotate(rotation);
                Viewport.ctx.drawImage(
                    sprite.img,
                    -sprite.anchor.x,
                    -sprite.anchor.y
                );
                Viewport.ctx.restore();
            } else {
                Viewport.ctx.drawImage(sprite.img, u, v);
            }
        },

        drawSmashedSprite(sprite, pos, height) {
            let { u, v } = this.viewportSprite2uv(
                sprite,
                pos
            );

            Viewport.ctx.drawImage(sprite.img, u - 1, v - height + sprite.img.height, sprite.img.width + 2, height);
        },

        viewportSprite2uv(sprite, pos) {
            // HACK TODO
            if (pos.u) {
                return {
                    u: pos.u - sprite.anchor.x,
                    v: pos.v - sprite.anchor.y
                };
            }

            return {
                u: pos.x - sprite.anchor.x - (0) /*Camera.pos.x*/ + Viewport.center.u,
                v: pos.y - sprite.anchor.y - (0) /*Camera.pos.y*/ + Viewport.center.v
            };
        }
    };

    // Sprite utility functions

    function initBasicSpriteArray(data, opts) {
        return data.map(element => initBasicSprite(element, opts));
    }

    function initBasicSprite(data, opts) {
        return initDynamicSprite(loadCacheSlice(...data), opts);
    }

    function initDynamicSprite(source, opts) {
        let w = source.width,
            h = source.height;

        if (typeof opts !== 'object') {
            opts = {};
        }

        if (!opts.anchor) {
            opts.anchor = { x: (w / 2) | 0, y: (h / 2) | 0 };
        }

        if (!opts.bb) {
            opts.bb = [-opts.anchor.x, -opts.anchor.y, source.width, source.height];
        }

        return {
            img: source,
            ...opts
        };
    }

    function loadCacheSlice(x, y, w, h) {
        const source = Sprite.sheet;
        const sliceCanvas = createCanvas(w, h);
        sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);
        return sliceCanvas.canvas;
    }

    function flipHorizontal(source) {
        let canvas = createCanvas(source.width, source.height);
        canvas.ctx.translate(source.width, 0);
        canvas.ctx.scale(-1, 1);
        canvas.ctx.drawImage(source, 0, 0);
        return canvas.canvas;
    }

    function copySpriteFrame(source, dest, w, h) {
        let canvas = createCanvas(dest.width, dest.height);
        canvas.ctx.drawImage(dest, 0, 0);
        canvas.ctx.drawImage(source, 0, 0, w, h, 0, 0, w, h);
        return canvas.canvas;
    }

    function augmentTerrain(source, lines, color) {
        let canvas = createCanvas(320, 180);
        canvas.ctx.drawImage(source, 0, 0);
        canvas.ctx.fillStyle = color;
        canvas.ctx.fillRect(0, 180 - lines, 320, lines);
        return canvas.canvas;
    }

    function recolor(source, color) {
        let canvas = createCanvas(source.width, source.height);
        canvas.ctx.fillStyle = color;
        canvas.ctx.fillRect(0, 0, source.width, source.height);
        canvas.ctx.globalCompositeOperation = 'destination-in';
        canvas.ctx.drawImage(source, 0, 0);
        return canvas.canvas;
    }

    // Text


    const C_WIDTH = 5;
    const C_HEIGHT = 5;
    const FONT_SHEET_C_WIDTH = 6;
    const FONT_SHEET_WIDTH = 270;
    const DEFAULT_C_SHIFT = 5;

    // Very simple variable-width font implementation. The characters in the font strip
    // are left-aligned in their 5x5 pixel boxes, so in order to have variable width,
    // we just need to note the characters that AREN'T full width. Anything not in
    // this list has full shift (5+1 = 6 pixels).
    const C_SHIFT = {
        10: 0, // LF (\n)
        32: 3, // Space ( )
        33: 3, // Bang (!)
        39: 2, // Apostrophe (')
        40: 3, // Open Paren (
        41: 3, // Close Paren )
        44: 3, // Comma (,)
        46: 3, // Period (.)
        47: 6, // Slash (/)
        73: 2, // I
        77: 6, // M
        84: 6, // T
        86: 6, // V
        87: 6, // W
        88: 6, // X
        89: 6, // Y
        91: 4, // [ (s)
        109: 6, // m (up)
        111: 6, // o (down),
        1108: 10, // left arrow key
        1114: 10, // right arrow key
        1101: 19 // escape key
    };

    const C_ICONS = {
    };

    const Text = {
        init() {
            Text.white = Sprite.font.img;
            Text.black = recolor(Text.white, rgba(0, 0, 0, 1));
            Text.shadow = recolor(Text.white, rgba(44, 27, 46, 1));

            //Text.tan = recolor(Text.white, rgba(209, 180, 140, 1));
            //Text.pig = recolor(Text.white, rgba(227, 66, 98, 1));
            //Text.duotone = recolorDuotone(Text.white, '#f2b63d', '#fff4e0');
            //Text.duotone_red = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3', rgba(255, 0, 0, 0.7));

            Text.palette = PALETTE.map(color => recolor(Text.white, color));

            C_ICONS[1108] = Sprite.keys[0];
            C_ICONS[1114] = Sprite.keys[1];
            C_ICONS[1101] = Sprite.keys[2];
        },

        drawText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {
            for (let c of this.charactersToDraw(text, scale)) {
                if (C_ICONS[c.c]) {
                    ctx.drawImage(
                        C_ICONS[c.c].img,
                        u + c.u,
                        v + c.v - Math.floor((C_ICONS[c.c].img.height) / 2) + 2
                    );
                } else {
                    let k = (c.c - 32) * FONT_SHEET_C_WIDTH;
                    if (shadow) {
                        ctx.drawImage(
                            shadow,
                            k % FONT_SHEET_WIDTH,
                            (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                            C_WIDTH,
                            C_HEIGHT,
                            u + c.u,
                            v + c.v + 1,
                            C_WIDTH * scale,
                            C_HEIGHT * scale
                        );
                    }
                    ctx.drawImage(
                        font,
                        k % FONT_SHEET_WIDTH,
                        (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                        C_WIDTH,
                        C_HEIGHT,
                        u + c.u,
                        v + c.v,
                        C_WIDTH * scale,
                        C_HEIGHT * scale
                    );
                }
            }
        },

        drawParagraph(ctx, text, u, v, width, scale = 1, font = Text.white, shadow) {
            const lines = this.breakParagraph(text, width, scale);

            for (let i = 0; i < lines.length; i++) {
                this.drawText(ctx, lines[i], u, v + i * (C_HEIGHT + 2) * scale, scale, font, shadow);
            }
        },

        breakParagraph(text, width, scale = 1) {
            const lines = [];
            let line = '';
            const words = text.split(' ');
            while (words.length > 0) {
                const lineWidth = this.measure(line + ' ' + words[0], scale).w;
                if (lineWidth > width) {
                    lines.push(line);
                    line = '';
                }
                line = (line.length > 0 ? line + ' ' : '') + words.shift();
            }
            if (line.length > 0) {
                lines.push(line);
            }
            return lines;
        },

        measure(text, scale = 1) {
            let w = 0, h = 0;

            for (let c of this.charactersToDraw(text, scale)) {
                w = Math.max(w, c.u + (C_SHIFT[c.c] || DEFAULT_C_SHIFT) * scale);
                h = c.v + (C_HEIGHT + 2) * scale;
            }

            return { w, h };
        },

        *charactersToDraw(text, scale = 1) {
            let u = 0, v = 0;

            for (let idx = 0; idx < text.length; idx++) {
                let c = text.charCodeAt(idx);

                if (c === 10) {
                    // Newline
                    u = 0;
                    v += (C_HEIGHT + 2) * scale;
                    continue;
                }

                if (c === 92) {
                    // Backslash
                    idx++;
                    c = 1000 + text.charCodeAt(idx);
                }

                yield { c, u, v };

                u += (C_SHIFT[c] || DEFAULT_C_SHIFT) * scale;
            }
        }
    };

    // KeyboardAdapter


    const KeyboardAdapter = {
        init() {
            KeyboardAdapter.held = [];

            window.addEventListener('keydown', event => {
                //let k = KeyboardAdapter.map[event.code];
                // Uncomment to debug key presses
                // console.log(event.key, event.keyCode, event.code, k);

                // Hack to ensure we initialize audio after user interacts with game
                Audio.initContext();

                //if (Input.Action.includes(event.code)) {
                //if (k) {
                //    KeyboardAdapter.held[k] = true;
                  KeyboardAdapter.held[event.code] = true;
                //}
            });

            window.addEventListener('keyup', event => {
                //let k = KeyboardAdapter.map[event.code];
                //if (k) {
                //    KeyboardAdapter.held[k] = false;
                //}
                KeyboardAdapter.held[event.code] = false;

                /*if (event.key >= '1' && event.key <= '9') {
                    game.nextLevel = Number(event.key) - 1;
                    game.screens.pop();
                }*/
            });

            KeyboardAdapter.reset();
        },

        //update() {
            // For keyboards, we want to convert the state of the various arrow keys being held down
            // into a directional vector. We use the browser's event to handle the held state of
            // the other action buttons, so we don't need to process them here.
            /*let state =
                (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +
                (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +
                (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +
                (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);*/

            //KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];
        //},

        reset() {
            //KeyboardAdapter.direction = 0;
            for (let action of Input.Action) {
                KeyboardAdapter.held[action] = false;
            }
            //KeyboardAdapter.held = [];
            //KeyboardAdapter.held.length = 0;
        }
    };

    // Input


    const Input = {
        // Game Inputs

        // Extreme hack
        //
        Action: [
            'ArrowUp',
            'ArrowLeft',
            'ArrowDown',
            'ArrowRight',
            'Escape',
            'Space',
            'KeyV',
            'KeyH',
            'KeyA',
            'KeyS',
            'KeyB',
            'KeyT',
            'KeyM'
        ],

        init() {
            // A vector representing the direction the user is pressing/facing,
            // separate from pressing and releasing inputs. Treating "direction"
            // separately makes it easier to handle gamepad sticks.
            //this.direction = { x: 0, y: 0, m: 0 };

            // "Pressed" means an input was pressed THIS FRAME.
            this.pressed = {};

            // "Released" means an input was released THIS FRAME.
            this.released = {};

            // "Held" means an input is held down. The input was "Pressed" either
            // this frame or in a past frame, and has not been "Released" yet.
            this.held = {};

            KeyboardAdapter.init();
        },

        update() {
            // We could have some kind of "input adapter toggle", but it's easier to just treat all inputs
            // as valid -- if you're pressing the "attack" button on either gamepad or keyboard, then you're
            // attacking. For directional input, we instead check whether there's movement on the thumbstick,
            // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.

            //KeyboardAdapter.update();

            for (let action of Input.Action) {
                let held = KeyboardAdapter.held[action];
                this.pressed[action] = !this.held[action] && held;
                this.released[action] = this.held[action] && !held;

                this.held[action] = held;
            }

            //this.pointer = pointerAdapter.pointer;
            //this.direction = KeyboardAdapter.direction;
            //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;
        }
    };

    // AshParticle


    class AshParticle {
        constructor() {
            this.t = -1;
            this.d = 60;

            this.pos = { u: Math.random() * 320, v: Math.random() * 200 };
            this.layer = Math.floor(Math.random() * 3) + 1;
            this.alpha = 1;
        }

        update() {
            if (++this.t === this.d) {
                this.cull = true;
            }

            if (this.t > 36) {
                this.alpha -= 0.02;
            }

            this.pos.v += 0.1;
            if (this.pos.v < 3) this.pos.v += 0.02;
            if (this.pos.v < 2) this.pos.v += 0.02;

            if (Math.random() < 0.05) {
                this.pos.u += 0.5;
            }
        }

        draw() {
            Viewport.ctx.globalAlpha = this.alpha;
            Viewport.ctx.drawImage(Sprite.particle[this.layer - 1].img, Math.floor(this.pos.u), Math.floor(this.pos.v));
            Viewport.ctx.globalAlpha = 1;
        }
    }

    // Particle


    class VillagerChunkParticle {
        constructor(pos) {
            this.t = -1;
            this.d = 30;

            this.angle = Math.random() * Math.PI + Math.PI;
            this.vector = angle2vector(this.angle);
            this.m = 50 + Math.random() * 25;
            this.a = Math.random() * Math.PI * 2;
            this.ad = 0.1;

            this.pos = { u: pos.u, v: pos.v - 12 };
            this.pos.u += this.vector.x * 3;
            this.pos.v += this.vector.y * 3;

            this.frame = Math.floor(Math.random() * 6);
        }

        update() {
            if (++this.t === this.d) {
                this.cull = true;
            }

            this.pos.u += (this.m / this.d) * this.vector.x;
            this.pos.v += (this.m / this.d) * this.vector.y;
            this.vector.x *= 0.95;
            this.vector.y *= 0.95;
            this.vector.y += 0.05;

            this.a += this.ad;
        }

        draw() {
            Sprite.drawViewportSprite(Sprite.villagerchunk[this.frame], this.pos, this.a);
        }
    }

    // SacrificeParticle


    class SacrificeParticle {
        constructor(villager) {
            this.t = -1;
            this.d = 30;
            this.villager = villager;
        }

        update() {
            if (++this.t === this.d) {
                game.gameScene.grantSanity(10);
                this.cull = true;
            }

            if (this.t >= 24 && this.t <= 27) {
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
            }
            if (this.t === 24) {
                Audio.play(Audio.explosion);
            }

            this.villager.pos.v -= 0.2;
        }

        draw() {
            let v = Math.floor(this.villager.pos.v);

            if (this.t >= 0 && this.t < 15) {
                let shake = (this.t % 3) - 1;
                Sprite.drawViewportSprite(Sprite.villager[0], { u: this.villager.pos.u + shake, v: v });
            } else if (this.t >= 15 && this.t <= 25) {
                Sprite.drawViewportSprite(Sprite.villagerdeath[0], { u: this.villager.pos.u, v: v });
            }
        }
    }

    // Button


    class Button {
        constructor(u, v, hotkey, text) {
            this.u = u;
            this.v = v;
            this.hotkey = hotkey;
            this.text = text;
            this.visible = false;
            this.active = false;
        }

        update() {
            if (!this.visible) return;
        }

        draw() {
            if (!this.visible) return;

            const frame = this.active ? 0 : 2;
            const colorIndex = this.active ? 4 : 2;
            const bgColorIndex = this.active ? 0 : 2;
            Viewport.ctx.drawImage(Sprite.button[frame].img, this.u, this.v);
            Text.drawText(Viewport.ctx, this.hotkey, this.u + 2, this.v + 2, 1, Text.palette[bgColorIndex]);
            Text.drawText(Viewport.ctx, this.text.toUpperCase(), this.u + 11, this.v + 2, 1, Text.palette[colorIndex]);
        }
    }

    // TweenChain

    class TweenChain {
        constructor(tweenArray) {
            this.t = -1;
            this.tweenArray = tweenArray;
        }

        update() {
            this.t++;

            if (this.t < this.tweenArray[0].t1) {
                this.value = this.tweenArray[0].v1;
                this.facing = (this.tweenArray[0].v2 - this.tweenArray[0].v1 >= 0 ? 1 : 0);
                return;
            }

            if (this.t >= this.tweenArray[this.tweenArray.length - 1].t2) {
                this.value = this.tweenArray[this.tweenArray.length - 1].v2;
                this.facing = (this.tweenArray[this.tweenArray.length - 1].v2 - this.tweenArray[this.tweenArray.length - 1].v1 >= 0 ? 1 : 0);
                this.finished = true;
                return;
            }

            for (let i = 0; i < this.tweenArray.length; i++) {
                if (this.t >= this.tweenArray[i].t1 && this.t < this.tweenArray[i].t2) {
                    // A tween chain can have an "undefined" start value, which means
                    // just inherit the last value of the previous tween.
                    if (this.tweenArray[i].v1 === undefined) {
                        this.tweenArray[i].v1 = this.tweenArray[i - 1].v2;
                    }

                    // Apply stagger on the fly; this allows for randomization of the DESTINATION
                    // (we assume the start point does not move).
                    if (this.tweenArray[i].stagger) {
                        this.tweenArray[i].v2 += Math.floor(Math.random() * this.tweenArray[i].stagger - this.tweenArray[i].stagger / 2);
                        this.tweenArray[i].stagger = undefined;
                    }

                    this.value = (this.tweenArray[i].v2 - this.tweenArray[i].v1)
                        * (this.t - this.tweenArray[i].t1)
                        / (this.tweenArray[i].t2 - this.tweenArray[i].t1)
                        + this.tweenArray[i].v1;

                    // For every frame, we provide a utility "facing" value: 1 if the current
                    // movement trends RIGHT, 0 if the current movement trends LEFT.
                    this.facing = (this.tweenArray[i].v2 - this.tweenArray[i].v1 >= 0 ? 1 : 0);
                    break;
                }
            }
        }
    }

    // HeightMapData
    //
    // This file is generated by `gulp buildAssets`.

    const HeightMapData =
    /* <generated-data> */
    [ [],
      [ 149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        148,
        148,
        148,
        148,
        148,
        148,
        147,
        147,
        147,
        146,
        146,
        146,
        145,
        145,
        144,
        144,
        144,
        143,
        143,
        142,
        141,
        141,
        141,
        140,
        140,
        140,
        139,
        139,
        139,
        139,
        139,
        138,
        138,
        138,
        138,
        138,
        138,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        136,
        136,
        136,
        135,
        135,
        135,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        135,
        135,
        135,
        136,
        136,
        136,
        137,
        137,
        137,
        137,
        137,
        137,
        138,
        138,
        138,
        138,
        139,
        139,
        139,
        139,
        140,
        140,
        140,
        140,
        141,
        141,
        141,
        141,
        142,
        142,
        142,
        142,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        145,
        145,
        146,
        145,
        145,
        145,
        145,
        145,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        145,
        146,
        146,
        147,
        147,
        148,
        148,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        148,
        148,
        149,
        149,
        149,
        149,
        150,
        150,
        150,
        150,
        151,
        151,
        152,
        152,
        152,
        153,
        153,
        153,
        154,
        154,
        154,
        154,
        154,
        154,
        153,
        153,
        153,
        153,
        152,
        152,
        152,
        152,
        151,
        151,
        151,
        151,
        151,
        151,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149 ],
      [ 126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        127,
        128,
        128,
        129,
        129,
        129,
        130,
        130,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        132,
        132,
        132,
        132,
        132,
        132,
        133,
        133,
        133,
        133,
        133,
        134,
        134,
        135,
        136,
        136,
        137,
        138,
        138,
        139,
        139,
        139,
        140,
        140,
        140,
        140,
        139,
        139,
        139,
        139,
        139,
        139,
        138,
        138,
        138,
        138,
        138,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        139,
        139,
        139,
        139,
        140,
        140,
        141,
        141,
        141,
        142,
        142,
        142,
        143,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        144,
        144,
        144,
        145,
        145,
        145,
        145,
        145,
        145,
        145,
        146,
        145,
        145,
        145,
        145,
        144,
        144,
        144,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143 ],
      [] ]
    /* </generated-data> */
    ;

    // Villager


    const IDLE = 0;
    const WOODCUTTER = 1;
    const BUTCHER = 2;
    const TALLOWER = 3;
    const STONECUTTER = 4;

    class IdleTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 30, v1: 0, v2: 0 }
            ]);
            this.frame = 0;
            this.layer = 1;
        }

        completeTask() { }
    }

    class ButcherTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: -76, stagger: 20 },
                { t1: 120, t2: 180, v1: undefined, v2: -76, stagger: 20 },
                { t1: 180, t2: 300, v1: undefined, v2: 0 }
            ]);
            this.layer = 1;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
            this.equipmentframe = (this.t > 60 && this.t < 210) ? 3 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.gatherMeat();
        }
    }

    class WoodcutterTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: 140, stagger: 15 },
                { t1: 120, t2: 180, v1: undefined, v2: 140, stagger: 15 },
                { t1: 180, t2: 300, v1: undefined, v2: 0 }
            ]);
            this.layer = 1;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 130 && this.t < 170) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
            this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.gatherWood();
        }
    }

    class TallowerTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: 47 },
                { t1: 120, t2: 180, v1: 47, v2: 47 },
                { t1: 180, t2: 300, v1: 47, v2: 0 }
            ]);
            this.layer = 2;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + 7 + facing * VILLAGER_FRAMES;
            //this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.craftTorch();
        }
    }

    class StonecutterTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: -141 },
                { t1: 120, t2: 180, v1: -141, v2: -141 },
                { t1: 180, t2: 300, v1: -141, v2: 0 }
            ]);
            this.layer = 1;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
            this.equipmentframe = (this.t > 60 && this.t < 210) ? 5 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.gatherStone();
        }
    }

    const TaskClass = {
        [WOODCUTTER]: WoodcutterTask,
        [BUTCHER]: ButcherTask,
        [TALLOWER]: TallowerTask,
        [STONECUTTER]: StonecutterTask,
        [IDLE]: IdleTask
    };

    class Villager {
        static JOB_NAMES = ['', 'WOODCUTTER', 'BUTCHER', 'TALLOWER', 'STONEMASON', 'FIREKEEPER', 'TOTEMCARVER'];

        constructor(job) {
            this.job = job;
            this.t = 0;
            this.pos = { u: 0, v: 0 };
        }

        update() {
            if (!this.task) {
                this.task = new TaskClass[this.job]();
            }

            this.task.update();

            this.layer = this.task.layer;
            this.pos.u = 160 + this.task.value;
            this.pos.v = HeightMapData[this.layer][Math.floor(this.pos.u)] - 32 + 1;
            this.frame = this.task.frame || 0;
            this.equipmentframe = this.task.equipmentframe;

            if (this.task.finished) {
                this.task.completeTask(this);
                this.task = undefined;
            }
        }

        draw() {
            Sprite.drawViewportSprite(Sprite.villager[this.frame], this.pos);

            if (this.equipmentframe > -1) {
                Sprite.drawViewportSprite(Sprite.villager[this.equipmentframe], this.pos);
            }
        }

        newTask() {
            return new TaskClass[this.job]();
        }
    }

    // TextFloatParticle


    class TextFloatParticle {
        constructor(pos, text, paletteRange) {
            this.pos = { ...pos };
            this.text = text;
            this.paletteRange = paletteRange;
            this.t = -1;
            this.d = 30;
        }

        update() {
            if (++this.t === this.d) this.cull = true;
            this.pos.v -= 0.2;
            this.paletteColor = Math.round((this.paletteRange[1] - this.paletteRange[0]) * (this.t/this.d) + this.paletteRange[0]);
        }

        draw() {
            Text.drawText(Viewport.ctx, this.text, this.pos.u, this.pos.v, 1, Text.palette[this.paletteColor]);
        }
    }

    // WinkParticle


    class WinkParticle {
        constructor() {
            this.t = -1;
            this.d = 15;
            this.winkframe = 3;
            this.layer = 1;
        }

        update() {
            if (++this.t === this.d) {
                this.cull = true;
            }

            if (this.t === 2) {
                this.winkframe = 0;
            } else if (this.t === 6) {
                this.winkframe++;
            } else if (this.t === 8) {
                this.winkframe++;
            } else if (this.t === 10) {
                this.winkframe++;
            }
        }

        draw() {
            console.log('draw wink');
            Viewport.ctx.drawImage(Sprite.wink[this.winkframe].img, 160 + 11 - 1, 73 - 30 + 9 - 2);
        }
    }

    // ScreenShake

    class ScreenShake {
        constructor(frames, hAmplitude, vAmplitude) {
            this.frames = frames;
            this.hAmplitude = hAmplitude;
            this.vAmplitude = vAmplitude;
            this.hSamples = [];
            this.vSamples = [];

            var sampleCount = frames / 2;
            for (let i = 0; i <= sampleCount; i++) {
                this.hSamples.push(Math.random() * 2 - 1);
                this.vSamples.push(Math.random() * 2 - 1);
            }
            this.frame = -1;
        }

        update() {
            this.frame++;
            if (this.frame >= this.frames) {
                this.x = 0;
                this.y = 0;
                return false;
            }

            // https://jonny.morrill.me/en/blog/gamedev-how-to-implement-a-camera-shake-effect/
            // let s = (this.frames / 10) * (this.frame / this.frames);
            let s = this.frame / 2;
            let s0 = s | 0;
            let s1 = s0 + 1;
            let decay = 1 - this.frame / this.frames;

            this.x =
                this.hAmplitude *
                decay *
                (this.hSamples[s0] +
                    (s - s0) * (this.hSamples[s1] - this.hSamples[s0]));
            this.y =
                this.vAmplitude *
                decay *
                (this.vSamples[s0] +
                    (s - s0) * (this.vSamples[s1] - this.vSamples[s0]));

            return true;
        }
    }

    // TechScene


    class TechScene {
        constructor(tech, lastUnlock) {
            this.tech = tech;
            this.t = 0;

            lastUnlock = lastUnlock || Object.values(this.tech)[0];
            this.pos = { x: lastUnlock.x, y: lastUnlock.y };
        }

        update() {
            game.gameScene.update(false);

            this.t++;
            this.bounceX = Math.floor(Math.cos(this.t / 8) * 3);

            if (Input.pressed['ArrowRight']) {
                this.pos.x++;
            }

            if (Input.pressed['ArrowLeft']) {
                this.pos.x--;
            }

            if (Input.pressed['ArrowUp']) {
                this.pos.y--;
            }
            if (Input.pressed['ArrowDown']) {
                this.pos.y++;
            }

            if (Input.pressed['Space']) {
                if (game.gameScene.buyTech(game.gameScene.getTechNode(this.pos.x, this.pos.y))) {
                    Audio.play(Audio.wink);
                } else {
                    Audio.play(Audio.fail);
                }
            }

            if (Input.pressed['Escape']) {
                game.scenes.pop();
            }
        }

        draw() {
            Viewport.ctx.fillStyle = rgba(0, 0, 0, 0.72);
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            let centerx = 80 - 11;
            let centery = 90 - 9;
            let offsetx = (-this.pos.x) * 23;
            let offsety = (-this.pos.y) * 19;

            let cardx = 180;
            let cardy = 40;

            for (let node of Object.values(this.tech)) {
                if (node && node.visible) {
                    if (node.unlocked) {
                        Viewport.ctx.drawImage(Sprite.techtree[1].img, offsetx + centerx + node.x * 23, offsety + centery + node.y * 19);
                    } else {
                        Viewport.ctx.drawImage(Sprite.techtree[0].img, offsetx + centerx + node.x * 23, offsety + centery + node.y * 19);
                    }

                    if (node.x == this.pos.x && node.y == this.pos.y) {
                        Viewport.ctx.drawImage(Sprite.techtree[2].img, offsetx + centerx + node.x * 23, offsety + centery + node.y * 19);

                        node.unlocked ? 4 : 3;

                        Text.drawText(Viewport.ctx, node.title.toUpperCase(), cardx, cardy, 1, Text.palette[4]);
                        Text.drawParagraph(Viewport.ctx, node.description.toUpperCase(), cardx, cardy + 10, 132, 1, Text.palette[3]);

                        if (!node.unlocked) {
                            let costColor = game.gameScene.canAffordCosts(node) ? 4 : 2;
                            Text.drawText(Viewport.ctx, 'UNLOCK:', cardx, cardy+30, 1, Text.palette[3]);
                            Text.drawText(Viewport.ctx, node.unlockCost.toUpperCase(), cardx + 56, cardy+30, 1, Text.palette[costColor]);
                        }

                        Text.drawText(Viewport.ctx, 'PER TURN:', cardx, cardy+40, 1, Text.palette[3]);
                        Text.drawParagraph(Viewport.ctx, node.perTurn.toUpperCase(), cardx + 56, cardy+40, 132 - 56, 1, Text.palette[4]);
                    }
                }
            }
        }
    }

    // DefeatScene


    class DefeatScene {
        constructor(stats) {
            this.stats = stats;

            this.text = [
                'THE LAST SPARK OF SANITY FADES IN ULTHAR, AND WITH IT',
                'ANY HOPE OF DELIVERANCE FOR YOU AND YOUR KIN.',
                '',
                'WOOD GATHERED: ' + this.stats.woodGathered,
                'MEAT BUTCHERED: ' + this.stats.meatGathered,
                'TORCHES CRAFTED: ' + this.stats.torchesCrafted,
                'STONE MINED: ' + this.stats.stoneGathered,
                'SECONDS SURVIVED: ' + this.stats.seconds
            ];
            this.frames = 0;
        }

        update() {
            this.frames++;

            if (Input.pressed['Space']) {
                game.scenes.pop();
            }
        }

        draw() {
            Viewport.ctx.fillStyle = '#0a1a2f';
            Viewport.ctx.fillRect(-5, 0, Viewport.width + 5, Viewport.height);

            const gameOverWidth = Text.measure('GAME OVER', 2).w;
            Text.drawText(Viewport.ctx, 'GAME OVER', (Viewport.width - gameOverWidth) / 2, 10, 2, Text.palette[4]);

            //Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 73 - 30);
            Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 61 - 30);

            for (let i = 0; i < this.text.length; i++) {
                let width = Text.measure(this.text[i], 1).w;
                Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 80 + i * 10, 1, Text.palette[4]);
            }
        }
    }

    // TechTree

    const TechTree = {
        create() {
            return {
                woodcutter: {
                    title: 'Woodcutters',
                    description: 'Recruit villagers to gather wood.',
                    perTurn: '-1 Meat\n+5 Wood',
                    unlockCost: '5 Meat',
                    meat: 5,
                    x: 2, y: 2,
                    right: true,
                    down: true
                },
                butcher: {
                    title: 'Butchers',
                    description: 'Recruit villagers to gather meat.',
                    perTurn: '-1 Meat\n+5 Meat',
                    unlockCost: '10 Wood',
                    wood: 10,
                    x: 2, y: 3,
                    down: true
                },
                tallower: {
                    title: 'Tallowers',
                    description: 'Recruit villagers to render fat and make torches.',
                    perTurn: '-3 Meat\n-2 Wood\n+1 Torch',
                    unlockCost: '10 Wood',
                    wood: 10,
                    x: 2, y: 4,
                    down: true
                },
                stonecutter: {
                    title: 'Stonemasons',
                    description: 'Recruit villagers to gather stone.',
                    perTurn: '-1 Meat\n-1 Torch\n+5 Stone',
                    unlockCost: '10 Wood',
                    wood: 10,
                    x: 2, y: 5
                },
                woodplus: {
                    title: 'Wood+',
                    description: 'Gather 20% more wood.',
                    perTurn: '+1 Wood',
                    unlockCost: '10 Wood 10 Stone',
                    wood: 10,
                    stone: 10,
                    x: 3, y: 2,
                    right: true
                },
                woodplusplus: {
                    title: 'Wood++',
                    description: 'Gather 20% more wood.',
                    perTurn: '+1 Wood',
                    unlockCost: '30 Wood 30 Stone',
                    wood: 30,
                    stone: 30,
                    x: 4, y: 2
                }
            };
        }
    };

    // GameScene


    const BUTTON_RECRUIT_VILLAGER = 0;
    const BUTTON_SACRIFICE_VILLAGER = 1;
    const BUTTON_REPAIR_BRIDGE = 2;
    const BUTTON_REPAIR_HALL = 3;
    const BUTTON_REPAIR_ALTAR = 4;
    const BUTTON_HELP = 5;

    class GameScene {
        constructor() {
            game.gameScene = this;
            this.entities = [];
            this.screenshakes = [];

            // Clock
            this.t = 0;
            this.influence = 5;
            this.sanity = 100;

            // Inventory
            this.meat = 0;
            this.wood = 0;
            this.stone = 0;
            this.torches = 0;

            // Playthrough Stats
            this.meatGathered = 0;
            this.woodGathered = 0;
            this.stoneGathered = 0;
            this.villagersRecruited = 0;
            this.torchesCrafted = 0;

            this.buttons = [];
            //this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button((320-80)/2, 15, 'V', 'Recruit Villager');
            //this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button((320-80)/2, 15, 'S', 'Sacrifice Villager');
            this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button(5, 3, 'V', 'Recruit Villager');
            this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button(5, 13, 'S', 'Sacrifice Villager');
            this.buttons[BUTTON_REPAIR_BRIDGE] = new Button(5, 23, 'B', 'REPAIR BRIDGE');
            this.buttons[BUTTON_REPAIR_HALL] = new Button(5, 33, 'T', 'REPAIR TALLOW HALL');
            this.buttons[BUTTON_REPAIR_ALTAR] = new Button(5, 43, 'A', 'BUILD ALTAR');
            this.buttons[BUTTON_HELP] = new Button(285, 168, 'H', 'HELP');
            this.buttons[BUTTON_HELP].visible = true;
            this.buttons[BUTTON_HELP].active = true;

            this.selectedJob = WOODCUTTER;
            this.jobsDisplayed = [WOODCUTTER];

            this.villagers = [];
            this.villagersWithJob = [[], [], [], [], [], [], [], []];

            this.techAltar = false;

            this.tech = TechTree.create();
            this.unlockTech(this.tech.woodcutter);
        }

        update(handleInput = true) {
            // Set up displayed jobs
            this.jobsDisplayed = [WOODCUTTER];
            if (this.tech.butcher.unlocked) {
                this.jobsDisplayed.push(BUTCHER);
            }
            if (this.tech.tallower.unlocked) {
                this.jobsDisplayed.push(TALLOWER);
            }
            if (this.tech.stonecutter.unlocked) {
                this.jobsDisplayed.push(STONECUTTER);
            }

            // Player input

            if (handleInput) {

                    // move
            ///this.pos.x += this.vel.x;
            ///this.pos.y += this.vel.y;

                if (Input.pressed['KeyV']) {
                    this.recruitVillager();
                }

            /*if (Input.pressed['KeyB']) {
                this.buildBridge();
            }*/

            /*if (Input.pressed['KeyT']) {
                this.buildHall();
            }*/

                if (Input.pressed['KeyA']) {
                    this.buildAltar();
                }

                if (Input.pressed['ArrowDown']) {
                    this.moveJobSelector(1);
                }

                if (Input.pressed['ArrowUp']) {
                    this.moveJobSelector(-1);
                }

                if (Input.pressed['ArrowRight']) {
                    this.hireVillager(this.selectedJob);
                }

                if (Input.pressed['ArrowLeft']) {
                    this.fireVillager(this.selectedJob);
                }

                if (Input.pressed['KeyS']) {
                    this.sacrificeVillager();
                }

                if (Input.pressed['Space']) {
                    this.sanity -= 10;
                }

                if (Input.pressed['KeyH']) {
                    //game.scenes.push(new HelpScene());
                    game.scenes.push(new TechScene(this.tech));
                }

            }

            // Game ticks

            this.t++;

            if (!this.nextSanityTick) {
                this.nextSanityTick = this.t + 12;
            }

            if (this.t >= this.nextSanityTick) {
                this.sanity -= 0.2;
                this.influence += 0.2;
                this.nextSanityTick = this.t + 12;
            }

            if (this.t === 1) {
                Audio.play(Audio.wind);
            }

            if (this.t === 36) {
                this.addScreenShake(new ScreenShake(6, 6, 6));
            }

            // Button UI Elements

            this.buttons[BUTTON_RECRUIT_VILLAGER].active = (this.influence >= this.nextWorkerCost());
            this.buttons[BUTTON_RECRUIT_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_RECRUIT_VILLAGER].active);

            this.buttons[BUTTON_SACRIFICE_VILLAGER].active = (true);
            this.buttons[BUTTON_SACRIFICE_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_SACRIFICE_VILLAGER].active);

            //this.buttons[BUTTON_REPAIR_BRIDGE].active = (this.wood >= 10);
            //this.buttons[BUTTON_REPAIR_BRIDGE].visible = !this.techBridge && this.wood >= 10;

            //this.buttons[BUTTON_REPAIR_HALL].active = (this.wood >= 10);
            //this.buttons[BUTTON_REPAIR_HALL].visible = this.tech.butcher.unlocked && !this.techTorches && this.wood >= 10;

            this.buttons[BUTTON_REPAIR_ALTAR].active = (this.stone >= 10);
            this.buttons[BUTTON_REPAIR_ALTAR].visible = this.tech.tallower.unlocked && !this.techAltar && this.stone >= 10;

            let visibleButtonY = 3;
            for (let i = 0; i < 5; i++) {
                if (this.buttons[i].visible) {
                    this.buttons[i].y = visibleButtonY;
                    visibleButtonY += 10;
                }
            }

            // Villagers

            for (const villager of this.villagers) {
                villager.update();
            }

            // Entities

            if (this.t > 35) {
                for (const entity of this.entities) {
                    entity.update();
                }
                this.entities = this.entities.filter(entity => !entity.cull);
            }

            // Check

            if (this.sanity < 0) {
                this.playerLost();
            }

            // Ash Particles

            if (this.entities.length < 33) {
                this.entities.push(new AshParticle());
            }

            if (this.t % 60 === 0) ;

            for (let i = 0; i < this.screenshakes.length; i++) {
                if (!this.screenshakes[i].update()) {
                    this.screenshakes.splice(i, 1);
                    i--;
                }
            }
        }

        draw() {
            let shakeX = 0, shakeY = 0;
            this.screenshakes.forEach(shake => {
                shakeX += shake.x;
                shakeY += shake.y;
            });
            Viewport.ctx.translate(shakeX, shakeY);

            let terrainY = this.t > 36 ? 0 : (285 - 285 * this.t / 36);

            // Background

            Viewport.ctx.fillStyle = '#40985e';
            Viewport.ctx.fillRect(0, 0, Viewport.width + 5, Viewport.height);

            // Layer 3 (farthest)

            Viewport.ctx.drawImage(Sprite.terrain[2].img, 0, Math.floor(0 + terrainY * 0.8 * 0.8));

            for (let entity of this.entities) {
                if (entity.layer === 3) entity.draw();
            }

            for (let villager of this.villagers) {
                if (villager.layer === 2) villager.draw();
            }

            // Layer 2 (middle)

            Viewport.ctx.drawImage(Sprite.terrain[1].img, 0, Math.floor(0 + terrainY * 0.8));

            for (let entity of this.entities) {
                if (entity.layer === 2) entity.draw();
            }

            for (let villager of this.villagers) {
                if (villager.layer === 2) villager.draw();
            }

            // Layer 1 (closest)

            Viewport.ctx.drawImage(Sprite.terrain[0].img, 0, Math.floor(0 + terrainY));

            // Black cat perch

            Viewport.ctx.drawImage(Sprite.blackcat[0].img, 160, 73 - 30);

            for (let entity of this.entities) {
                if (entity.layer === 1 || !entity.layer) entity.draw();
            }

            for (let villager of this.villagers) {
                if (villager.layer === 1) villager.draw();
            }

            /*Viewport.ctx.fillStyle = '#0a1a2f';
            Viewport.ctx.fillRect(-5, Viewport.height - 31, Viewport.width + 5, 31);*/

            // Bridge

            if (this.t > 40) {
            if (this.tech.butcher.unlocked) {
                Viewport.ctx.drawImage(Sprite.bridge[1].img, 112, 133 - 32);
            } else {
                Viewport.ctx.drawImage(Sprite.bridge[0].img, 112, 133 - 32);
            }

            // Tallower Hall

            if (this.tech.tallower.unlocked) {
                Viewport.ctx.drawImage(Sprite.factory[1].img, 198, 133 - 32);
            } else {
                Viewport.ctx.drawImage(Sprite.factory[0].img, 198, 133 - 32);
            }

            // Altar

            if (this.techAltar) {
                let altarY = Math.floor(Math.sin(this.t / 25) * 2);
                Viewport.ctx.drawImage(Sprite.altar[0].img, 238, 116 - 30);
                Viewport.ctx.drawImage(Sprite.altar[1].img, 238, 115 - 30 + altarY);
            }

            /*
                // (Debug) raw numbers
                let crunk = String(Math.floor(this.sanity)) + ',' + String(Math.floor(this.influence)) + ',' + String(this.villagers.length);
                Text.drawText(Viewport.ctx, crunk, 3, 3, 1, Text.palette[1]);
            */

            if (game.scene === this) {
                // Hide button prompts if Help Screen is displayed, to avoid confusion
                for (const button of this.buttons) {
                    button.draw();
                }
            }

            this.drawSanityBar();
            this.drawInfluenceBar();
            this.drawJobSelectUI();
            this.drawInventory();
            }
        }

        drawSanityBar() {
            let k = Math.floor((this.sanity / 100) * 78);
            Viewport.ctx.drawImage(Sprite.sanitybar[0].img, 320-18-5, -3);
            Viewport.ctx.drawImage(Sprite.sanitybar[1].img, 320-18-5, -3);
            Viewport.ctx.drawImage(Sprite.sanitybar[2].img,
                0, 2 + (78 - k),
                18, k,
                320-18-5, -3 + 2 + (78 - k),
                18, k
            );
        }

        drawInfluenceBar() {
            let k = Math.floor(Math.min(this.influence / this.nextWorkerCost(), 1) * 80);
            Viewport.ctx.drawImage(Sprite.influencebar[0].img, (320-80)/2, 3);
            Viewport.ctx.drawImage(Sprite.influencebar[1].img,
                2, 3,
                k, 4,
                (320-80)/2 + 2, 3 + 3,
                k, 4
            );
        }

        drawJobSelectUI() {
            const cornerX = 7;
            const cornerY = 120;
            const verticalMargin = 10;

            let selectedIdx = 0;

            for (let i = 0; i < this.jobsDisplayed.length; i++) {
                if (this.selectedJob === this.jobsDisplayed[i]) {
                    selectedIdx = i;
                }

                const color = this.selectedJob === this.jobsDisplayed[i] ? Text.palette[3] : Text.palette[2];
                const numberText = String(this.villagersWithJob[this.jobsDisplayed[i]].length);
                const width = Text.measure(numberText).w;
                Text.drawText(Viewport.ctx, Villager.JOB_NAMES[this.jobsDisplayed[i]], cornerX + 5, cornerY + 4 + verticalMargin * i, 1, color);
                Text.drawText(Viewport.ctx, numberText, cornerX + 92 - width, cornerY + 4 + verticalMargin * i, 1, color);
            }

            const leftArrow = this.villagersWithJob[this.selectedJob].length > 0 ? 0 : 2;
            const rightArrow = this.villagersWithJob[IDLE].length > 0 ? 1 : 3;

            Viewport.ctx.drawImage(Sprite.jobselect[0].img, cornerX, cornerY + selectedIdx * verticalMargin);
            Viewport.ctx.drawImage(Sprite.smallarrows[leftArrow].img, cornerX + 77, cornerY + 4 + selectedIdx * verticalMargin);
            Viewport.ctx.drawImage(Sprite.smallarrows[rightArrow].img, cornerX + 94, cornerY + 4 + selectedIdx * verticalMargin);
        }

        drawInventory() {
            let woodWidth = Text.measure(String(this.wood), 1).w;
            let meatWidth = Text.measure(String(this.meat), 1).w;
            let stoneWidth = Text.measure(String(this.stone), 1).w;
            let torchWidth = Text.measure(String(this.torches), 1).w;

            Viewport.ctx.drawImage(Sprite.icons[0].img, INVENTORY_WOOD_POS.u - 60, INVENTORY_WOOD_POS.v - 1);
            Text.drawText(Viewport.ctx, 'WOOD', INVENTORY_WOOD_POS.u - 50, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);
            Text.drawText(Viewport.ctx, String(this.wood), INVENTORY_WOOD_POS.u - woodWidth, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);

            if (this.tech.butcher.unlocked) {
                Viewport.ctx.drawImage(Sprite.icons[2].img, INVENTORY_MEAT_POS.u - 60, INVENTORY_MEAT_POS.v - 1);
                Text.drawText(Viewport.ctx, 'MEAT', INVENTORY_MEAT_POS.u - 50, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
                Text.drawText(Viewport.ctx, String(this.meat), INVENTORY_MEAT_POS.u - meatWidth, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
            }

            if (this.tech.tallower.unlocked) {
                Viewport.ctx.drawImage(Sprite.icons[3].img, INVENTORY_TORCH_POS.u - 60, INVENTORY_TORCH_POS.v - 1);
                Text.drawText(Viewport.ctx, 'TORCHES', INVENTORY_TORCH_POS.u - 50, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
                Text.drawText(Viewport.ctx, String(this.torches), INVENTORY_TORCH_POS.u - torchWidth, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
            }

            if (this.tech.stonecutter.unlocked) {
                Viewport.ctx.drawImage(Sprite.icons[1].img, INVENTORY_STONE_POS.u - 60, INVENTORY_STONE_POS.v - 1);
                Text.drawText(Viewport.ctx, 'STONE', INVENTORY_STONE_POS.u - 50, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
                Text.drawText(Viewport.ctx, String(this.stone), INVENTORY_STONE_POS.u - stoneWidth, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
            }
        }

        addScreenShake(screenshake) {
            // This screen shake applies to the entire rendered screen, including GUI
            this.screenshakes.push(screenshake);
        }

        moveJobSelector(delta) {
            let idx = this.jobsDisplayed.indexOf(this.selectedJob);
            idx = (idx + delta + this.jobsDisplayed.length) % this.jobsDisplayed.length;
            this.selectedJob = this.jobsDisplayed[idx];
        }

        recruitVillager() {
            const cost = this.nextWorkerCost();
            if (this.influence >= cost) {
                this.influence -= cost;

                const villager = new Villager(this.selectedJob || WOODCUTTER);
                this.villagers.push(villager);
                this.villagersWithJob[villager.job].push(villager);
                this.villagersRecruited++;

                this.entities.push(new WinkParticle());
                Audio.play(Audio.wink);
                return true;
            } else {
                Audio.play(Audio.fail);
                this.addScreenShake(new ScreenShake(4, 6, 6));
                return false;
            }
        }

        hireVillager() {
            if (this.villagersWithJob[IDLE].length > 0) {
                // TODO
                const villager = this.villagersWithJob[IDLE].pop();
                villager.job = this.selectedJob;
                this.villagersWithJob[this.selectedJob].push(villager);
                return true;
            }
            return false;
        }

        fireVillager() {
            if (this.villagersWithJob[this.selectedJob].length > 0) {
                // TODO
                const villager = this.villagersWithJob[this.selectedJob].pop();
                villager.job = IDLE;
                this.villagersWithJob[IDLE].push(villager);
                return true;
            }
            return false;
        }

        sacrificeVillager() {
            if (this.villagersWithJob[this.selectedJob].length > 0) {
                // TODO - pick right villager
                const villager = this.villagersWithJob[this.selectedJob].pop();

                this.villagers.splice(this.villagers.indexOf(villager), 1);

                this.entities.push(new SacrificeParticle(villager));
                this.entities.push(new WinkParticle());
                Audio.play(Audio.wink);

                //villager.job = SACRIFICE;
                //this.villagersWithJob[SACRIFICE].push(villager);
                //this.activeSacrifice = new SacrificeParticle();
                //console.log('VILLAGER DEAD');
                return true;
            }
            return false;
        }

        consumeMeat() {
            if (this.meat > 0) {
                this.meat--;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-1', [4, 2]));
            } else {
                this.sanity--;
                this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '-1', [0, 2]));
            }
        }

        grantSanity(value) {
            if (this.sanity < 100) {
                this.sanity = Math.min(100, this.sanity + value);
                this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '+' + value, [0, 2]));
            }
        }

        gatherMeat() {
            this.meat += 5;
            this.meatGathered += 5;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '+5', [4, 2]));
        }

        gatherWood() {
            this.wood += 5;
            this.woodGathered += 5;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '+5', [4, 2]));
        }

        craftTorch() {
            this.torches += 1;
            this.torchesCrafted += 1;
            this.wood -= 2;
            this.meat -= 2;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: INVENTORY_TORCH_POS.u + 6, v: INVENTORY_TORCH_POS.v }, '+1', [4, 2]));
            this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-2', [4, 2]));
            this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-2', [4, 2]));
        }

        gatherStone() {
            this.stone += 5;
            this.stoneGathered += 5;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: 100, v: 100 }, '+5', [4, 2]));
            this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '+5', [4, 2]));
        }

        /*buildBridge() {
            const button = this.buttons[BUTTON_REPAIR_BRIDGE];

            if (button.active && button.visible && this.wood >= 10 && !this.techBridge) {
                this.wood -= 10;
                this.techBridge = true;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

                // TODO build bridge animation
            }
        }*/

            /*
        buildHall() {
            const button = this.buttons[BUTTON_REPAIR_HALL];

            if (button.active && button.visible && this.wood >= 10 && !this.tech.tallower.unlocked) {
                this.wood -= 10;
                this.techTorches = true;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

                // TODO build hall animation
            }
        }
            */

        buildAltar() {
            const button = this.buttons[BUTTON_REPAIR_ALTAR];

            if (button.active && button.visible && this.stone >= 10 && !this.techAltar) {
                this.stone -= 10;
                this.techAltar = true;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '-10', [4, 2]));

                // TODO build altar animation
            }
        }

        nextWorkerCost() {
            return Math.floor(1 * Math.pow(1.3, this.villagers.length));
        }

        playerLost() {
            const stats = {
                seconds: Math.floor(this.t / 60),
                woodGathered: this.woodGathered,
                meatGathered: this.meatGathered,
                torchesCrafted: this.torchesCrafted,
                stoneGathered: this.stoneGathered,
            };
            game.scenes.pop();
            game.scenes.push(new DefeatScene(stats));
        }

        getTechNode(x, y) {
            return Object.values(this.tech).find(node => node.x === x && node.y === y);
        }

        /**
         * Unlock tech node immediately without paying costs or validating.
         */
        unlockTech(node) {
            node.visible = true;
            node.unlocked = true;
            if (node.right) this.getTechNode(node.x + 1, node.y).visible = true;
            if (node.left) this.getTechNode(node.x - 1, node.y).visible = true;
            if (node.up) this.getTechNode(node.x , node.y - 1).visible = true;
            if (node.down) this.getTechNode(node.x, node.y + 1).visible = true;
            this.lastUnlock = node;
        }

        /**
         * Pay costs for and unlock a tech node, if possible.
         */
        buyTech(node) {
            if (node.unlocked) return false;
            if (!this.canAffordCosts(node)) return false;
            this.unlockTech(node);
            if (node.wood) this.wood -= node.wood;
            if (node.meat) this.meat -= node.meat;
            return true;
        }

        canAffordCosts(obj) {
            if (obj.wood && this.wood < obj.wood) return false;
            if (obj.meat && this.meat < obj.meat) return false;
            return true;
        }
    }

    // IntroScene


    class IntroScene {
        constructor() {
            this.t = 0;
            this.fadet = -1;
            this.entities = [];
        }

        update() {
            this.t++;

            if (this.fadet >= 0) this.fadet++;

            if (this.fadet === 1) {
                Audio.initTracks();
            }

            if (this.fadet > 20) {
                game.scenes.pop();

                const gameScene = new GameScene();
                game.scenes.push(gameScene);
                gameScene.entities = this.entities;
            }

            if (Input.pressed['Space']) {
                this.fadet = 0;
            }

            if (this.entities.length < 33) {
                this.entities.push(new AshParticle());
            }

            for (let entity of this.entities) {
                entity.update();
            }

            this.entities = this.entities.filter(entity => !entity.cull);
        }

        draw() {
            Viewport.ctx.fillStyle = PALETTE[0];
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            Viewport.ctx.globalAlpha = Math.min(this.t / 20, 1);
            Viewport.ctx.fillStyle = PALETTE[3];
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
            Viewport.ctx.globalAlpha = 1;

            for (let entity of this.entities) {
                entity.draw();
            }

            if (this.t > 30) {
                let adjustment = Math.max(1 - this.t / 54, 0);

                if (!this.x || this.t % 3 === 0) {
                    this.x = [0,1,2,3,4,5,6,7,8].map(x => adjustment * (Math.random() * 12 - 6));
                    this.alpha = [0,1,2,3,4,5,6,7,8].map(x => 1 - adjustment * Math.random());
                }

                for (let i = 0; i < 9; i++) {
                    let y = i * 4;
                    Viewport.ctx.globalAlpha = this.alpha[i];
                    Viewport.ctx.drawImage(Sprite.blackcat[0].img, 0, y, 24, 4, 160 + this.x[i], 73 - 30 + y, 24, 4);
                    Viewport.ctx.globalAlpha = 1;
                }
            }

            if (this.t > 40) {
                let title = 'THE ASHES OF ULTHAR';
                let titleWidth = Text.measure(title, 2).w;
                Text.drawText(Viewport.ctx, title, 168 - titleWidth / 2, 13 - this.fadet * 3, 2, Text.palette[4], Text.palette[1]);
            }

            if (this.t > 48 && this.fadet < 0) {
                let text = 'PRESS SPACE TO PLAY';
                let width = Text.measure(text, 1).w;
                Text.drawText(Viewport.ctx, text, 168 - width / 2, 150, 1, Text.palette[4], Text.palette[1]);
            }
        }
    }

    // Game


    /**
     * Game state.
     */
    class Game {
        init() {
            Sprite.loadSpritesheet(() => {
                Viewport.init();
                Sprite.init();
                Text.init();
                Input.init();
                Audio.init();

                //Camera.init();

                window.addEventListener('blur', () => this.pause());
                window.addEventListener('focus', () => this.unpause());

                this.reset();
                this.start();
            });
        }

        reset() {
            this.scenes = [];
            this.lastFrame = 0;
            this.nextLevel = 0;

            this.scores = [
                { time: 300 * 60, enemiesAlive: 10 },
                { time: 300 * 60, enemiesAlive: 10 },
                { time: 300 * 60, enemiesAlive: 10 },
                { time: 300 * 60, enemiesAlive: 10 }
            ];

            this.scenes.push(new IntroScene());
        }

        start() {
            this.frame = 0;
            this.framestamps = [0];
            this.update();
            window.requestAnimationFrame((xyz) => this.onFrame(xyz));
        }

        onFrame(currentms) {
            let delta = (currentms - this.lastFrame) - (1000 / FPS);

            if (delta >= 0) {
                this.frame++;
                this.lastFrame = (currentms - delta);

                // The above calculation is right for smoothing out frames, but if
                // we end up far behind the currentms, we can "fast play" for a long time
                // which is not desired. Fast-forward if we fall behind more than 5 frames.
                if (currentms - this.lastFrame > 5 * 1000 / FPS) {
                    this.lastFrame = currentms;
                }

                Viewport.resize();
                this.update();
                this.draw(Viewport.ctx);

                // this.framestamps.push(currentms);
                // if (this.framestamps.length >= 120) {
                //     this.framestamps.shift();
                // }
                // this.fps = 1000 / ((this.framestamps[this.framestamps.length - 1] - this.framestamps[0]) / this.framestamps.length);
            }
            window.requestAnimationFrame((xyz) => this.onFrame(xyz));
        }

        update() {
            // Gather user input
            Input.update();

            // Handle special keys that are screen-independent
            if (Input.pressed['KeyM']) {
                console.log('KeyM - toggling music');
                Audio.musicEnabled = !Audio.musicEnabled;
            }
            /*if (Input.pressed[Input.Action.SFX_TOGGLE]) {
                Audio.sfxEnabled = !Audio.sfxEnabled;
            }*/

            // Hand off control to the current "screen" (for example, game screen or menu)
            if (this.scenes.length === 0) {
                this.scenes.push(new GameScene());
            }
            this.scene = this.scenes[this.scenes.length - 1];
            this.scene.update();

            // Do per-frame audio updates
            Audio.update();
        }

        draw() {
            // Reset canvas transform and scale
            Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);
            Viewport.ctx.scale(Viewport.scale, Viewport.scale);

            for (let i = 0; i < this.scenes.length; i++) {
                this.scenes[i].draw();
            }

            //Text.drawText(Viewport.ctx, String(this.fps), 15, 15, 1, Text.white);
        }

        pause() {
            if (this.paused) return;
            this.paused = true;
            Audio.pause();
        }

        unpause() {
            if (!this.paused) return;
            this.paused = false;
            Audio.unpause();
        }
    }

    const game = new Game();

    /**
     * Create and launch game.
     */
    game.init();

})();</script>