<meta charset="utf8"><style>body,html{width:100vw;height:100vh;margin:0;padding:0;background-color:#2c1b2e}#d1{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}#d2{max-width:100vw;max-height:100vh;aspect-ratio:48/27}#canvas{width:100%;height:100%}</style><div id="d1"><div id="d2"><canvas id="canvas"></canvas></div></div><script>(function () {
    'use strict';

    /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
    *
    * Copyright (c) 2011-2013 Marcus Geelnard
    *
    * This software is provided 'as-is', without any express or implied
    * warranty. In no event will the authors be held liable for any damages
    * arising from the use of this software.
    *
    * Permission is granted to anyone to use this software for any purpose,
    * including commercial applications, and to alter it and redistribute it
    * freely, subject to the following restrictions:
    *
    * 1. The origin of this software must not be misrepresented; you must not
    *    claim that you wrote the original software. If you use this software
    *    in a product, an acknowledgment in the product documentation would be
    *    appreciated but is not required.
    *
    * 2. Altered source versions must be plainly marked as such, and must not be
    *    misrepresented as being the original software.
    *
    * 3. This notice may not be removed or altered from any source
    *    distribution.
    *
    */


    // Some general notes and recommendations:
    //  * This code uses modern ECMAScript features, such as ** instead of
    //    Math.pow(). You may have to modify the code to make it work on older
    //    browsers.
    //  * If you're not using all the functionality (e.g. not all oscillator types,
    //    or certain effects), you can reduce the size of the player routine even
    //    further by deleting the code.


    const CPlayer = function() {

        //--------------------------------------------------------------------------
        // Private methods
        //--------------------------------------------------------------------------

        // Oscillators
        var osc_sin = function (value) {
            return Math.sin(value * 6.283184);
        };

        var osc_saw = function (value) {
            return 2 * (value % 1) - 1;
        };

        var osc_square = function (value) {
            return (value % 1) < 0.5 ? 1 : -1;
        };

        var osc_tri = function (value) {
            var v2 = (value % 1) * 4;
            if(v2 < 2) return v2 - 1;
            return 3 - v2;
        };

        var getnotefreq = function (n) {
            // 174.61.. / 44100 = 0.003959503758 (F3)
            return 0.003959503758 * (2 ** ((n - 128) / 12));
        };

        var createNote = function (instr, n, rowLen) {
            var osc1 = mOscillators[instr.i[0]],
                o1vol = instr.i[1],
                o1xenv = instr.i[3]/32,
                osc2 = mOscillators[instr.i[4]],
                o2vol = instr.i[5],
                o2xenv = instr.i[8]/32,
                noiseVol = instr.i[9],
                attack = instr.i[10] * instr.i[10] * 4,
                sustain = instr.i[11] * instr.i[11] * 4,
                release = instr.i[12] * instr.i[12] * 4,
                releaseInv = 1 / release,
                expDecay = -instr.i[13]/16,
                arp = instr.i[14],
                arpInterval = rowLen * (2 **(2 - instr.i[15]));

            var noteBuf = new Int32Array(attack + sustain + release);

            // Re-trig oscillators
            var c1 = 0, c2 = 0;

            // Local variables.
            var j, j2, e, rsample, o1t, o2t;

            // Generate one note (attack + sustain + release)
            for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
                if (j2 >= 0) {
                    // Switch arpeggio note.
                    arp = (arp >> 8) | ((arp & 255) << 4);
                    j2 -= arpInterval;

                    // Calculate note frequencies for the oscillators
                    o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                    o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
                }

                // Envelope
                e = 1;
                if (j < attack) {
                    e = j / attack;
                } else if (j >= attack + sustain) {
                    e = (j - attack - sustain) * releaseInv;
                    e = (1 - e) * (3 ** (expDecay * e));
                }

                // Oscillator 1
                c1 += o1t * e ** o1xenv;
                rsample = osc1(c1) * o1vol;

                // Oscillator 2
                c2 += o2t * e ** o2xenv;
                rsample += osc2(c2) * o2vol;

                // Noise oscillator
                if (noiseVol) {
                    rsample += (2 * Math.random() - 1) * noiseVol;
                }

                // Add to (mono) channel buffer
                noteBuf[j] = (80 * rsample * e) | 0;
            }

            return noteBuf;
        };


        //--------------------------------------------------------------------------
        // Private members
        //--------------------------------------------------------------------------

        // Array of oscillator functions
        var mOscillators = [
            osc_sin,
            osc_square,
            osc_saw,
            osc_tri
        ];

        // Private variables set up by init()
        var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf;


        //--------------------------------------------------------------------------
        // Initialization
        //--------------------------------------------------------------------------

        this.init = function (song) {
            // Define the song
            mSong = song;

            // Init iteration state variables
            mLastRow = song.endPattern;
            mCurrentCol = 0;

            // Prepare song info
            mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

            // Create work buffer (initially cleared)
            mMixBuf = new Int32Array(mNumWords);
        };


        //--------------------------------------------------------------------------
        // Public methods
        //--------------------------------------------------------------------------

        // Generate audio data for a single track
        this.generate = function () {
            // Local variables
            var i, j, p, row, col, n, cp,
                k, t, rsample, rowStartSample, f;

            // Put performance critical items in local variables
            var chnBuf = new Int32Array(mNumWords),
                instr = mSong.songData[mCurrentCol],
                rowLen = mSong.rowLen,
                patternLen = mSong.patternLen;

            // Clear effect state
            var low = 0, band = 0, high;
            var lsample, filterActive = false;

            // Clear note cache.
            var noteCache = [];

             // Patterns
             for (p = 0; p <= mLastRow; ++p) {
                cp = instr.p[p];

                // Pattern rows
                for (row = 0; row < patternLen; ++row) {
                    // Execute effect command.
                    var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                    if (cmdNo) {
                        instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                        // Clear the note cache since the instrument has changed.
                        if (cmdNo < 17) {
                            noteCache = [];
                        }
                    }

                    // Put performance critical instrument properties in local variables
                    var oscLFO = mOscillators[instr.i[16]],
                        lfoAmt = instr.i[17] / 512,
                        lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                        fxLFO = instr.i[19],
                        fxFilter = instr.i[20],
                        fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                        q = 1 - instr.i[22] / 255,
                        dist = instr.i[23] * 1e-5,
                        drive = instr.i[24] / 32,
                        panAmt = instr.i[25] / 512,
                        panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                        dlyAmt = instr.i[27] / 255,
                        dly = instr.i[28] * rowLen & -2;  // Must be an even number

                    // Calculate start sample number for this row in the pattern
                    rowStartSample = (p * patternLen + row) * rowLen;

                    // Generate notes for this pattern row
                    for (col = 0; col < 4; ++col) {
                        n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                        if (n) {
                            if (!noteCache[n]) {
                                noteCache[n] = createNote(instr, n, rowLen);
                            }

                            // Copy note from the note cache
                            var noteBuf = noteCache[n];
                            for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                              chnBuf[i] += noteBuf[j];
                            }
                        }
                    }

                    // Perform effects for this pattern row
                    for (j = 0; j < rowLen; j++) {
                        // Dry mono-sample
                        k = (rowStartSample + j) * 2;
                        rsample = chnBuf[k];

                        // We only do effects if we have some sound input
                        if (rsample || filterActive) {
                            // State variable filter
                            f = fxFreq;
                            if (fxLFO) {
                                f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                            }
                            f = 1.5 * Math.sin(f);
                            low += f * band;
                            high = q * (rsample - band) - low;
                            band += f * high;
                            rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                            // Distortion
                            if (dist) {
                                rsample *= dist;
                                rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                                rsample /= dist;
                            }

                            // Drive
                            rsample *= drive;

                            // Is the filter active (i.e. still audiable)?
                            filterActive = rsample * rsample > 1e-5;

                            // Panning
                            t = Math.sin(panFreq * k) * panAmt + 0.5;
                            lsample = rsample * (1 - t);
                            rsample *= t;
                        } else {
                            lsample = 0;
                        }

                        // Delay is always done, since it does not need sound input
                        if (k >= dly) {
                            // Left channel = left + right[-p] * t
                            lsample += chnBuf[k-dly+1] * dlyAmt;

                            // Right channel = right + left[-p] * t
                            rsample += chnBuf[k-dly] * dlyAmt;
                        }

                        // Store in stereo channel buffer (needed for the delay effect)
                        chnBuf[k] = lsample | 0;
                        chnBuf[k+1] = rsample | 0;

                        // ...and add to stereo mix buffer
                        mMixBuf[k] += lsample | 0;
                        mMixBuf[k+1] += rsample | 0;
                    }
                }
            }

            // Next iteration. Return progress (1.0 == done!).
            mCurrentCol++;
            return mCurrentCol / mSong.numChannels;
        };

        // Create a AudioBuffer from the generated audio data
        this.createAudioBuffer = function(context) {
            var buffer = context.createBuffer(2, mNumWords / 2, 44100);
            for (var i = 0; i < 2; i ++) {
                var data = buffer.getChannelData(i);
                for (var j = i; j < mNumWords; j += 2) {
                    data[j >> 1] = mMixBuf[j] / 65536;
                }
            }
            return buffer;
        };

        // Create a WAVE formatted Uint8Array from the generated audio data
        this.createWave = function() {
            // Create WAVE header
            var headerLen = 44;
            var l1 = headerLen + mNumWords * 2 - 8;
            var l2 = l1 - 36;
            var wave = new Uint8Array(headerLen + mNumWords * 2);
            wave.set(
                [82,73,70,70,
                 l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
                 87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
                 68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
                 l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
            );

            // Append actual wave data
            for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
                // Note: We clamp here
                var y = mMixBuf[i];
                y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
                wave[idx++] = y & 255;
                wave[idx++] = (y >> 8) & 255;
            }

            // Return the WAVE formatted typed array
            return wave;
        };

        // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
        this.getData = function(t, n) {
            var i = 2 * Math.floor(t * 44100);
            var d = new Array(n);
            for (var j = 0; j < 2*n; j += 1) {
                var k = i + j;
                d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
            }
            return d;
        };
    };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const VillageHusk = {
          songData: [
            { // Instrument 3
              i: [
              0, // OSC1_WAVEFORM
              255, // OSC1_VOL
              116, // OSC1_SEMI
              79, // OSC1_XENV
              0, // OSC2_WAVEFORM
              255, // OSC2_VOL
              116, // OSC2_SEMI
              0, // OSC2_DETUNE
              83, // OSC2_XENV
              0, // NOISE_VOL
              4, // ENV_ATTACK
              6, // ENV_SUSTAIN
              69, // ENV_RELEASE
              52, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              14, // FX_FREQ
              0, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              0, // FX_PAN_AMT
              0, // FX_PAN_FREQ
              0, // FX_DELAY_AMT
              0 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,127,127,,,,,,127,127,,,,,,127,127,,,,,,127,127],
                 f: []}
              ]
            },
            { // Instrument 4
              i: [
              0, // OSC1_WAVEFORM
              255, // OSC1_VOL
              116, // OSC1_SEMI
              85, // OSC1_XENV
              0, // OSC2_WAVEFORM
              255, // OSC2_VOL
              116, // OSC2_SEMI
              0, // OSC2_DETUNE
              37, // OSC2_XENV
              14, // NOISE_VOL
              4, // ENV_ATTACK
              6, // ENV_SUSTAIN
              73, // ENV_RELEASE
              99, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              136, // FX_FREQ
              15, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              0, // FX_PAN_AMT
              0, // FX_PAN_FREQ
              66, // FX_DELAY_AMT
              6 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [,,,,,139,,,,,,,139,,,,,,,139,,,,,,,139],
                 f: []}
              ]
            },
            { // Instrument 5
              i: [
              0, // OSC1_WAVEFORM
              91, // OSC1_VOL
              128, // OSC1_SEMI
              0, // OSC1_XENV
              0, // OSC2_WAVEFORM
              95, // OSC2_VOL
              128, // OSC2_SEMI
              12, // OSC2_DETUNE
              0, // OSC2_XENV
              0, // NOISE_VOL
              12, // ENV_ATTACK
              0, // ENV_SUSTAIN
              72, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              255, // FX_FREQ
              0, // FX_RESONANCE
              0, // FX_DIST
              32, // FX_DRIVE
              83, // FX_PAN_AMT
              3, // FX_PAN_FREQ
              93, // FX_DELAY_AMT
              4 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,3,3,3,3,3,2,3,2,6,3,2,3,6,3,2,3,6,3,2,3,6,3,5,7],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [132,,132,,132,,,132,,,,,,,127,,139,,127,,,127,,,127,,,,135,,135,,135,,,135,,131,,127,,,130,,130,,130,,,130,,,130,,,,139,,139,,139,,,139,,135,,131,,,134,,134,,134,,,134,,,134,,,,,,,,,,,140,,,,135,,129,,,,,,,,135,,,138,,135],
                 f: []},
                {n: [127,,127,,127,,,127,,,,,,,127,,139,,127,,,127,,,127,,,,130,,130,,130,,,130,,,,,,,130,,130,,130,,,130,,,130,,,,134,,134,,134,,,134,,,,,,,134,,134,,134,,,134,,,134,,,,,,,,,,,135,,,,,,,,,,,,,,135,,,138,,135],
                 f: []},
                {n: [127,,127,,127,,,127,,,,139,127,,127,,139,,127,,,127,,,133,,133,,130,,130,,130,,,130,,,,,130,,130,,130,,130,,,130,,139,136,,136,,134,,134,,134,,,134,,,,,134,,134,,134,,134,,,134,,,140,,140,,,,,,,,,135,,,,,137,,,,,,,,,135,,,141,,,137],
                 f: []},
                {n: [127,,127,,127,,,133,,133,,130,,,127,,,,127,,,,,,,,,,130,,132,,130,,,136,,136,,133,,,130,,130,,,,,,,,,,,,134,,134,,134,,139,,,140,,137,,,134,,134,,,,,,,,,,,,,,,,,,,141,,,,,,135,,,,,,,,135,,,138],
                 f: []},
                {n: [127,,127,,127,,,133,,133,,130,,,127,,139,,127,,,127,,,127,,,,130,,132,,130,,,136,,136,,133,,,130,,130,,130,,,130,,,130,,,,134,,134,,134,,139,,,140,,137,,,134,,134,,134,,,134,,,134,,,,,,,,,,,141,,,,,,135,,,,,,,,135,,,138,,135],
                 f: []},
                {n: [127,,127,,127,,,127,,127,,127,,,,,,,,,,,,,,,,,130,,134,,130,,,130,,130,,130,,,,,,,,,,,,,,,,,,,,,,,,,,135,,138],
                 f: []}
              ]
            },
            { // Instrument 6
              i: [
              2, // OSC1_WAVEFORM
              40, // OSC1_VOL
              140, // OSC1_SEMI
              64, // OSC1_XENV
              0, // OSC2_WAVEFORM
              0, // OSC2_VOL
              140, // OSC2_SEMI
              0, // OSC2_DETUNE
              0, // OSC2_XENV
              192, // NOISE_VOL
              7, // ENV_ATTACK
              21, // ENV_SUSTAIN
              0, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              3, // FX_FILTER
              161, // FX_FREQ
              192, // FX_RESONANCE
              5, // FX_DIST
              27, // FX_DRIVE
              0, // FX_PAN_AMT
              7, // FX_PAN_FREQ
              25, // FX_DELAY_AMT
              1 // FX_DELAY_TIME
              ],
              // Patterns
              p: [,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [127,,127,,127,,,127,,127,,127,,,127,,127,,127,,,127,,127,,127],
                 f: []}
              ]
            },
            { // Instrument 7
              i: [
              2, // OSC1_WAVEFORM
              192, // OSC1_VOL
              128, // OSC1_SEMI
              0, // OSC1_XENV
              2, // OSC2_WAVEFORM
              192, // OSC2_VOL
              140, // OSC2_SEMI
              18, // OSC2_DETUNE
              0, // OSC2_XENV
              0, // NOISE_VOL
              27, // ENV_ATTACK
              115, // ENV_SUSTAIN
              138, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              91, // LFO_AMT
              6, // LFO_FREQ
              1, // LFO_FX_FREQ
              2, // FX_FILTER
              8, // FX_FREQ
              92, // FX_RESONANCE
              21, // FX_DIST
              32, // FX_DRIVE
              148, // FX_PAN_AMT
              5, // FX_PAN_FREQ
              85, // FX_DELAY_AMT
              8 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2,3,2,3,,,,,,,,,,,,2,3,2,3,2,3,2,3,2,3,2,3],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,135],
                 f: []},
                {n: [,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,130],
                 f: []}
              ]
            },
          ],
          rowLen: 10023,   // In sample lengths
          patternLen: 28,  // Rows per pattern
          endPattern: 26,  // End pattern
          numChannels: 5  // Number of channels
        };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const Explosion = {
          songData: [
            { // Instrument 2
              i: [
              3, // OSC1_WAVEFORM
              130, // OSC1_VOL
              121, // OSC1_SEMI
              64, // OSC1_XENV
              2, // OSC2_WAVEFORM
              117, // OSC2_VOL
              109, // OSC2_SEMI
              0, // OSC2_DETUNE
              32, // OSC2_XENV
              0, // NOISE_VOL
              28, // ENV_ATTACK
              24, // ENV_SUSTAIN
              60, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              0, // LFO_WAVEFORM
              0, // LFO_AMT
              0, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              255, // FX_FREQ
              0, // FX_RESONANCE
              2, // FX_DIST
              32, // FX_DRIVE
              83, // FX_PAN_AMT
              5, // FX_PAN_FREQ
              92, // FX_DELAY_AMT
              1 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [139],
                 f: []}
              ]
            },
          ],
          rowLen: 3120,   // In sample lengths
          patternLen: 32,  // Rows per pattern
          endPattern: 0,  // End pattern
          numChannels: 1  // Number of channels
        };

    // This music has been exported by SoundBox. You can use it with
        // http://sb.bitsnbites.eu/player-small.js in your own product.

        // See http://sb.bitsnbites.eu/demo.html for an example of how to
        // use it in a demo.

        // Song data
        const Wink = {
          songData: [
            { // Instrument 3
              i: [
              3, // OSC1_WAVEFORM
              146, // OSC1_VOL
              140, // OSC1_SEMI
              0, // OSC1_XENV
              1, // OSC2_WAVEFORM
              224, // OSC2_VOL
              128, // OSC2_SEMI
              3, // OSC2_DETUNE
              0, // OSC2_XENV
              0, // NOISE_VOL
              16, // ENV_ATTACK
              13, // ENV_SUSTAIN
              3, // ENV_RELEASE
              0, // ENV_EXP_DECAY
              0, // ARP_CHORD
              0, // ARP_SPEED
              3, // LFO_WAVEFORM
              179, // LFO_AMT
              5, // LFO_FREQ
              0, // LFO_FX_FREQ
              2, // FX_FILTER
              124, // FX_FREQ
              135, // FX_RESONANCE
              11, // FX_DIST
              32, // FX_DRIVE
              150, // FX_PAN_AMT
              3, // FX_PAN_FREQ
              28, // FX_DELAY_AMT
              6 // FX_DELAY_TIME
              ],
              // Patterns
              p: [2],
              // Columns
              c: [
                {n: [],
                 f: []},
                {n: [146,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,139],
                 f: []}
              ]
            },
          ],
          rowLen: 3120,   // In sample lengths
          patternLen: 32,  // Rows per pattern
          endPattern: 0,  // End pattern
          numChannels: 1  // Number of channels
        };

    // Audio


    const Audio = {
        init() {
            Audio.contextCreated = false;
            Audio.readyToPlay = false;
            Audio.musicEnabled = true;
            Audio.sfxEnabled = true;
            Audio.musicVolume = 0;
            Audio.sfxVolume = 0;

            Audio.sounds = {};
        },

        initContext() {
            //console.log('initContext()');
            if (Audio.contextCreated) return;

            // In Safari, ensure our target AudioContext is created inside a
            // click or tap event (this ensures we don't interact with it until
            // after user input).
            //
            // Chrome and Firefox are more relaxed, but this approach works for all 3.
            //ZZFX.x = Audio.ctx = new AudioContext();
            Audio.ctx = new AudioContext();
            Audio.gain_ = Audio.ctx.createGain();
            Audio.gain_.connect(Audio.ctx.destination);
            //ZZFX.destination = Audio.gain_;
            //console.log(Audio.ctx);

            Audio.contextCreated = true;
        },

        initTracks() {
            // In this game, we ensure the screen that calls this function happens after the
            // user has interacted at least once (and that interaction called initContext above),
            // so we know it's safe to interact with the audio context.
            if (!Audio.musicPlaying) {
                // Sfx

                Audio.wink = this.loadSoundBox(Wink);
                Audio.explosion = this.loadSoundBox(Explosion);
                Audio.music = this.loadSoundBox(VillageHusk);
                Audio.readyToPlay = true;

                // Start music

                Audio.play(Audio.music, Audio.ctx.currentTime + 0.1, true);

                Audio.musicPlaying = true;
            }
        },

        update() {
            if (!Audio.readyToPlay) return;

            this.sfxVolume = this.sfxEnabled ? 0.3 : 0;
            this.musicVolume = this.musicEnabled ? 1 : 0;

            //ZZFX.volume = this.sfxVolume;

            if (this.sfxEnabled) ;
        },

        play(sound, startTime, loop) {
            if (!Audio.readyToPlay) return;
            if (!sound) return;

            //ZZFX.play(...sound);
            //this.sources.explosion.start(Audio.ctx.currentTime);

            let source = Audio.ctx.createBufferSource();
            source.buffer = sound.buffer;
            source.loop = loop || false;
            source.connect(sound.gainNode);
            source.start(startTime || Audio.ctx.currentTime);
        },

        // It's important we do pausing and unpausing as specific events and not in general update(),
        // because update() is triggered by the animation frame trigger which does not run if the
        // page is not visible. (So, if you want the music to fade in the background, for example,
        // that's not helpful if it won't work because you aren't looking at the page!)

        pause() {
            if (Audio.readyToPlay) {
                Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);
            }
        },

        unpause() {
            if (Audio.readyToPlay) {
                Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);
            }
        },

        loadSoundBox(exportedSound) {
            let player = new CPlayer();
            player.init(exportedSound);

            for (;;) {
                if (player.generate() === 1) break;
            }

            let gainNode = Audio.ctx.createGain();
            gainNode.connect(Audio.gain_);

            let buffer = player.createAudioBuffer(Audio.ctx);

            // Return an object containing the original player, the audio node,
            // and the source buffer for playback later.
            return { player, gainNode, buffer };
        }
    };

    // Constants

    // The game's desired dimensions in pixels - the actual dimensions can be adjusted
    // slightly by the Viewport module.
    const TARGET_GAME_WIDTH = 320;
    const TARGET_GAME_HEIGHT = 180;

    // Shortcuts for marker locations on screen
    const INVENTORY_WOOD_POS = { u: 250, v: 131 };
    const INVENTORY_MEAT_POS = { u: 250, v: 143 };
    const INVENTORY_TORCH_POS = { u: 250, v: 155 };
    const INVENTORY_STONE_POS = { u: 250, v: 167 };
    const SANITY_POS = { u: 284, v: 9 };

    // Number of "facing left" villager frames (doubled for facing right)
    const VILLAGER_FRAMES = 12;

    // Frames per second (locked)
    //
    // Other constants below, like gravity, foot speed, etc., are represented as movement PER FRAME.
    const FPS = 42;

    const PALETTE = [
      '#0a1a2f',
      '#04373b',
      '#1a644c',
      '#40985c',
      '#d1cb95'
    ];

    function angle2vector(r, m) {
        return { x: Math.cos(r), y: Math.sin(r), m: m || 1 };
    }

    function rgba(r, g, b, a) {
        return `rgba(${r},${g},${b},${a})`;
    }

    function createCanvas(width, height) {
        let canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        let ctx = canvas.getContext('2d');
        return { canvas, ctx };
    }

    // SpriteSheet

    /**
     * This module is generated by `gulp buildAssets`.
     */
    const SpriteSheet =
        /* <generated> */
    { altar: [ [ 0, 0, 19, 29 ], [ 19, 0, 19, 29 ] ],
      bigarrows: [ [ 0, 29, 15, 8 ] ],
      blackcat: [ [ 0, 37, 24, 36 ], [ 24, 37, 24, 36 ] ],
      bridge: [ [ 0, 73, 31, 16 ], [ 31, 73, 31, 16 ] ],
      button: [ [ 0, 89, 9, 9 ], [ 9, 89, 9, 9 ], [ 18, 89, 9, 9 ] ],
      factory: [ [ 0, 98, 20, 14 ], [ 20, 98, 20, 14 ] ],
      font4: [ [ 0, 112, 270, 12 ] ],
      icons: [ [ 0, 124, 8, 8 ], [ 8, 124, 8, 8 ], [ 16, 124, 8, 8 ], [ 24, 124, 8, 8 ] ],
      influencebar: [ [ 0, 132, 93, 10 ], [ 93, 132, 93, 10 ] ],
      jobselect: [ [ 0, 142, 101, 14 ] ],
      keys: [ [ 0, 156, 18, 9 ], [ 18, 156, 18, 9 ], [ 36, 156, 18, 9 ] ],
      particle:
       [ [ 0, 165, 1, 1 ],
         [ 1, 165, 1, 1 ],
         [ 2, 165, 1, 1 ],
         [ 3, 165, 1, 1 ],
         [ 4, 165, 1, 1 ] ],
      sanitybar: [ [ 0, 166, 18, 82 ], [ 18, 166, 18, 82 ] ],
      smallarrows: [ [ 0, 248, 3, 5 ], [ 3, 248, 3, 5 ], [ 6, 248, 3, 5 ], [ 9, 248, 3, 5 ] ],
      villager:
       [ [ 0, 253, 22, 30 ],
         [ 22, 253, 22, 30 ],
         [ 44, 253, 22, 30 ],
         [ 66, 253, 22, 30 ],
         [ 88, 253, 22, 30 ],
         [ 110, 253, 22, 30 ],
         [ 132, 253, 22, 30 ],
         [ 154, 253, 22, 30 ],
         [ 176, 253, 22, 30 ],
         [ 198, 253, 22, 30 ],
         [ 220, 253, 22, 30 ],
         [ 242, 253, 22, 30 ] ],
      villagerchunk:
       [ [ 0, 283, 9, 9 ],
         [ 9, 283, 9, 9 ],
         [ 18, 283, 9, 9 ],
         [ 27, 283, 9, 9 ],
         [ 36, 283, 9, 9 ],
         [ 45, 283, 9, 9 ] ],
      villagerdeath: [ [ 0, 292, 13, 22 ] ],
      wink: [ [ 0, 314, 3, 5 ], [ 3, 314, 3, 5 ], [ 6, 314, 3, 5 ], [ 9, 314, 3, 5 ] ],
      terrain_FG1: [ [ 0, 319, 320, 150 ] ],
      terrain_FG2: [ [ 0, 469, 320, 150 ] ],
      terrain_FG3: [ [ 0, 619, 320, 150 ] ],
      base64:
       'data:image/png;base64,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' };
    /* </generated> */

    // Viewport


    /**
     * Viewport
     *
     * Represents the game display (for us, a canvas).
     */
    const Viewport = {
        init() {
            Viewport.canvas = document.getElementById('canvas');
            Viewport.ctx = Viewport.canvas.getContext('2d');
            Viewport.resize(true);
        },

        // Resize the canvas to give us approximately our desired game display size.
        //
        // Rather than attempt to explain it, here's a concrete example:
        //
        //     we start with a desired game dimension:   480x270px
        //          get the actual browser dimensions:  1309x468px
        //          factor in the display's DPR ratio:  2618x936px
        //         now calculate the horizontal scale:       5.45x
        //                     and the vertical scale:       3.46x
        //            our new offical game scaling is:        5.4x
        //       and our official viewport dimensions:   484x173px
        //
        // This approach emphasizes correct aspect ratio and maintains full-window rendering, at
        // the potential cost of limiting visibility of the game itself in either the X or Y axis.
        // If you use this approach, make sure your GUI can "float" (otherwise there may be whole
        // UI elements the player cannot see!).
        resize(force) {
            let dpr = window.devicePixelRatio,
                width = Viewport.canvas.clientWidth,
                height = Viewport.canvas.clientHeight,
                dprWidth = width * dpr,
                dprHeight = height * dpr;

            if (
                force ||
                Viewport.canvas.width !== dprWidth ||
                Viewport.canvas.height !== dprHeight
            ) {
                Viewport.canvas.width = dprWidth;
                Viewport.canvas.height = dprHeight;

                Viewport.scale = ((Math.min(dprWidth / TARGET_GAME_WIDTH, dprHeight / TARGET_GAME_HEIGHT) * 10) | 0) / 10;
                Viewport.width = Math.ceil(dprWidth / Viewport.scale);
                Viewport.height = Math.ceil(dprHeight / Viewport.scale);
                Viewport.center = {
                    u: (Viewport.width / 2) | 0,
                    v: (Viewport.height / 2) | 0
                };
                Viewport.clientWidth = width;
                Viewport.clientHeight = height;

                // Note: smoothing flag gets reset on every resize by some browsers, which is why
                // we do it here.
                Viewport.ctx.imageSmoothingEnabled = false;
            }

            // We do this every frame, not just on resize, due to browser sometimes "forgetting".
            Viewport.canvas.style.cursor = 'none';
        },

        fillViewportRect() {
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
        },

        isOnScreen(uv) {
            return uv.u >= 0 && uv.v >= 0 && uv.u < Viewport.width && uv.v < Viewport.height;
        }
    };

    /**
     * Sprite
     *
     * Encapsulates loading sprite slices from the spritesheet, organizing them, and
     * modifying them or constructing using primitives. To save space, we use some techniques
     * like storing only a small slice of an image in the spritesheet, then using code
     * to duplicate it, add some randomness, etc.
     */
    const Sprite = {
        // This is an exception to the rule, loading the spritesheet is a special action that
        // happens BEFORE everything is initialized.
        loadSpritesheet(cb) {
            let image = new Image();
            image.onload = cb;
            image.src = SpriteSheet.base64;
            Sprite.sheet = image;
        },

        init() {
            // Standard (no special ops) sprites
            const defaultOpts = { anchor: { x: 0, y: 0 } };
            Sprite.font = initBasicSprite(SpriteSheet.font4[0]);
            Sprite.particle = SpriteSheet.particle.map(initBasicSprite);
            Sprite.blackcat = initBasicSpriteArray(SpriteSheet.blackcat, defaultOpts);
            Sprite.button = initBasicSpriteArray(SpriteSheet.button, defaultOpts);
            Sprite.influencebar = initBasicSpriteArray(SpriteSheet.influencebar, defaultOpts);
            Sprite.smallarrows = initBasicSpriteArray(SpriteSheet.smallarrows, defaultOpts);
            Sprite.jobselect = initBasicSpriteArray(SpriteSheet.jobselect, defaultOpts);
            Sprite.bridge = initBasicSpriteArray(SpriteSheet.bridge, defaultOpts);
            Sprite.bigarrows = initBasicSpriteArray(SpriteSheet.bigarrows, defaultOpts);
            Sprite.icons = initBasicSpriteArray(SpriteSheet.icons, defaultOpts);
            Sprite.factory = initBasicSpriteArray(SpriteSheet.factory, defaultOpts);
            Sprite.wink = initBasicSpriteArray(SpriteSheet.wink, defaultOpts);
            Sprite.keys = initBasicSpriteArray(SpriteSheet.keys, defaultOpts);

            // Custom anchors
            Sprite.altar = initBasicSpriteArray(SpriteSheet.altar, { anchor: { x: 9, y: 28 } });
            Sprite.villagerdeath = initBasicSpriteArray(SpriteSheet.villagerdeath, { anchor: { x: 6, y: 21 } });
            Sprite.villagerchunk = initBasicSpriteArray(SpriteSheet.villagerchunk, { anchor: { x: 4, y: 4 } });

            // Sanity bar handling
            Sprite.sanitybar = initBasicSpriteArray(SpriteSheet.sanitybar, defaultOpts);
            Sprite.sanitybar[2] = initDynamicSprite(recolor(Sprite.sanitybar[1].img, '#0a1a2f'), defaultOpts);

            // Terrain handling
            Sprite.terrain = [
                initBasicSprite(SpriteSheet.terrain_FG1[0]),
                initBasicSprite(SpriteSheet.terrain_FG2[0]),
                initBasicSprite(SpriteSheet.terrain_FG3[0])
            ];
            for (let i = 0; i < 3; i++) {
                Sprite.terrain[i].img = augmentTerrain(Sprite.terrain[i].img, 30, PALETTE[i]);
            }

            // Villager
            Sprite.villager = initBasicSpriteArray(SpriteSheet.villager, { anchor: { x: 16, y: 29 } });
            const villagerFrames = Sprite.villager.length;
            Sprite.villager[1].img = copySpriteFrame(Sprite.villager[0].img, Sprite.villager[1].img, 22, 28);
            Sprite.villager[8].img = copySpriteFrame(Sprite.villager[7].img, Sprite.villager[8].img, 22, 29);
            Sprite.villager[9].img = copySpriteFrame(Sprite.villager[7].img, Sprite.villager[9].img, 22, 29);
            Sprite.villager[11].img = copySpriteFrame(Sprite.villager[10].img, Sprite.villager[11].img, 22, 29);
            for (let i = 0; i < villagerFrames; i++) {
                Sprite.villager[i + villagerFrames] = initDynamicSprite(flipHorizontal(Sprite.villager[i].img), { anchor: { x: 5, y: 29 } });
            }
        },

        /**
         * A small helper that draws a sprite onto a canvas, respecting the anchor point of
         * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if
         * that's appropriate!
         */
        drawSprite(ctx, sprite, u, v) {
            ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);
        },

        drawViewportSprite(sprite, pos, rotation) {
            let { u, v } = this.viewportSprite2uv(
                sprite,
                pos
            );
            if (rotation) {
                Viewport.ctx.save();
                Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);
                Viewport.ctx.rotate(rotation);
                Viewport.ctx.drawImage(
                    sprite.img,
                    -sprite.anchor.x,
                    -sprite.anchor.y
                );
                Viewport.ctx.restore();
            } else {
                Viewport.ctx.drawImage(sprite.img, u, v);
            }
        },

        drawSmashedSprite(sprite, pos, height) {
            let { u, v } = this.viewportSprite2uv(
                sprite,
                pos
            );

            Viewport.ctx.drawImage(sprite.img, u - 1, v - height + sprite.img.height, sprite.img.width + 2, height);
        },

        viewportSprite2uv(sprite, pos) {
            // HACK TODO
            if (pos.u) {
                return {
                    u: pos.u - sprite.anchor.x,
                    v: pos.v - sprite.anchor.y
                };
            }

            return {
                u: pos.x - sprite.anchor.x - (0) /*Camera.pos.x*/ + Viewport.center.u,
                v: pos.y - sprite.anchor.y - (0) /*Camera.pos.y*/ + Viewport.center.v
            };
        }
    };

    // Sprite utility functions

    function initBasicSpriteArray(data, opts) {
        return data.map(element => initBasicSprite(element, opts));
    }

    function initBasicSprite(data, opts) {
        return initDynamicSprite(loadCacheSlice(...data), opts);
    }

    function initDynamicSprite(source, opts) {
        let w = source.width,
            h = source.height;

        if (typeof opts !== 'object') {
            opts = {};
        }

        if (!opts.anchor) {
            opts.anchor = { x: (w / 2) | 0, y: (h / 2) | 0 };
        }

        if (!opts.bb) {
            opts.bb = [-opts.anchor.x, -opts.anchor.y, source.width, source.height];
        }

        return {
            img: source,
            ...opts
        };
    }

    function loadCacheSlice(x, y, w, h) {
        const source = Sprite.sheet;
        const sliceCanvas = createCanvas(w, h);
        sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);
        return sliceCanvas.canvas;
    }

    function flipHorizontal(source) {
        let canvas = createCanvas(source.width, source.height);
        canvas.ctx.translate(source.width, 0);
        canvas.ctx.scale(-1, 1);
        canvas.ctx.drawImage(source, 0, 0);
        return canvas.canvas;
    }

    function copySpriteFrame(source, dest, w, h) {
        let canvas = createCanvas(dest.width, dest.height);
        canvas.ctx.drawImage(dest, 0, 0);
        canvas.ctx.drawImage(source, 0, 0, w, h, 0, 0, w, h);
        return canvas.canvas;
    }

    function augmentTerrain(source, lines, color) {
        let canvas = createCanvas(320, 180);
        canvas.ctx.drawImage(source, 0, 0);
        canvas.ctx.fillStyle = color;
        canvas.ctx.fillRect(0, 180 - lines, 320, lines);
        return canvas.canvas;
    }

    function recolor(source, color) {
        let canvas = createCanvas(source.width, source.height);
        canvas.ctx.fillStyle = color;
        canvas.ctx.fillRect(0, 0, source.width, source.height);
        canvas.ctx.globalCompositeOperation = 'destination-in';
        canvas.ctx.drawImage(source, 0, 0);
        return canvas.canvas;
    }

    // Text


    const C_WIDTH = 5;
    const C_HEIGHT = 5;
    const FONT_SHEET_C_WIDTH = 6;
    const FONT_SHEET_WIDTH = 270;
    const DEFAULT_C_SHIFT = 5;

    // Very simple variable-width font implementation. The characters in the font strip
    // are left-aligned in their 5x5 pixel boxes, so in order to have variable width,
    // we just need to note the characters that AREN'T full width. Anything not in
    // this list has full shift (5+1 = 6 pixels).
    const C_SHIFT = {
        10: 0, // LF (\n)
        32: 3, // Space ( )
        33: 3, // Bang (!)
        39: 2, // Apostrophe (')
        40: 3, // Open Paren (
        41: 3, // Close Paren )
        44: 3, // Comma (,)
        46: 3, // Period (.)
        47: 6, // Slash (/)
        73: 2, // I
        77: 6, // M
        84: 6, // T
        86: 6, // V
        87: 6, // W
        88: 6, // X
        89: 6, // Y
        91: 4, // [ (s)
        109: 6, // m (up)
        111: 6, // o (down),
        1108: 10, // left arrow key
        1114: 10, // right arrow key
        1101: 19 // escape key
    };

    const C_ICONS = {
    };

    const Text = {
        init() {
            Text.white = Sprite.font.img;
            Text.black = recolor(Text.white, rgba(0, 0, 0, 1));
            Text.shadow = recolor(Text.white, rgba(44, 27, 46, 1));

            //Text.tan = recolor(Text.white, rgba(209, 180, 140, 1));
            //Text.pig = recolor(Text.white, rgba(227, 66, 98, 1));
            //Text.duotone = recolorDuotone(Text.white, '#f2b63d', '#fff4e0');
            //Text.duotone_red = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3', rgba(255, 0, 0, 0.7));

            Text.palette = PALETTE.map(color => recolor(Text.white, color));

            C_ICONS[1108] = Sprite.keys[0];
            C_ICONS[1114] = Sprite.keys[1];
            C_ICONS[1101] = Sprite.keys[2];
        },

        drawText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {
            for (let c of this.charactersToDraw(text, scale)) {
                if (C_ICONS[c.c]) {
                    ctx.drawImage(
                        C_ICONS[c.c].img,
                        u + c.u,
                        v + c.v - Math.floor((C_ICONS[c.c].img.height) / 2) + 2
                    );
                } else {
                    let k = (c.c - 32) * FONT_SHEET_C_WIDTH;
                    if (shadow) {
                        ctx.drawImage(
                            shadow,
                            k % FONT_SHEET_WIDTH,
                            (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                            C_WIDTH,
                            C_HEIGHT,
                            u + c.u,
                            v + c.v + 1,
                            C_WIDTH * scale,
                            C_HEIGHT * scale
                        );
                    }
                    ctx.drawImage(
                        font,
                        k % FONT_SHEET_WIDTH,
                        (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                        C_WIDTH,
                        C_HEIGHT,
                        u + c.u,
                        v + c.v,
                        C_WIDTH * scale,
                        C_HEIGHT * scale
                    );
                }
            }
        },

        drawParagraph(ctx, text, u, v, width, scale = 1, font = Text.white, shadow) {
            const lines = this.breakParagraph(text, width, scale);

            for (let i = 0; i < lines.length; i++) {
                this.drawText(ctx, lines[i], u, v + i * (C_HEIGHT + 2) * scale, scale, font, shadow);
            }
        },

        breakParagraph(text, width, scale = 1) {
            const lines = [];
            let line = '';
            const words = text.split(' ');
            while (words.length > 0) {
                const lineWidth = this.measure(line + ' ' + words[0], scale).w;
                if (lineWidth > width) {
                    lines.push(line);
                    line = '';
                }
                line = line + ' ' + words.shift();
            }
            if (line.length > 0) {
                lines.push(line);
            }
            return lines;
        },

        measure(text, scale = 1) {
            let w = 0, h = 0;

            for (let c of this.charactersToDraw(text, scale)) {
                w = Math.max(w, c.u + (C_SHIFT[c.c] || DEFAULT_C_SHIFT) * scale);
                h = c.v + (C_HEIGHT + 2) * scale;
            }

            return { w, h };
        },

        *charactersToDraw(text, scale = 1) {
            let u = 0, v = 0;

            for (let idx = 0; idx < text.length; idx++) {
                let c = text.charCodeAt(idx);

                if (c === 10) {
                    // Newline
                    u = 0;
                    v += (C_HEIGHT + 2) * scale;
                    continue;
                }

                if (c === 92) {
                    // Backslash
                    idx++;
                    c = 1000 + text.charCodeAt(idx);
                }

                yield { c, u, v };

                u += (C_SHIFT[c] || DEFAULT_C_SHIFT) * scale;
            }
        }
    };

    // KeyboardAdapter


    const KeyboardAdapter = {
        init() {
            KeyboardAdapter.held = [];

            window.addEventListener('keydown', event => {
                //let k = KeyboardAdapter.map[event.code];
                // Uncomment to debug key presses
                // console.log(event.key, event.keyCode, event.code, k);

                // Hack to ensure we initialize audio after user interacts with game
                Audio.initContext();

                //if (Input.Action.includes(event.code)) {
                //if (k) {
                //    KeyboardAdapter.held[k] = true;
                  KeyboardAdapter.held[event.code] = true;
                //}
            });

            window.addEventListener('keyup', event => {
                //let k = KeyboardAdapter.map[event.code];
                //if (k) {
                //    KeyboardAdapter.held[k] = false;
                //}
                KeyboardAdapter.held[event.code] = false;

                /*if (event.key >= '1' && event.key <= '9') {
                    game.nextLevel = Number(event.key) - 1;
                    game.screens.pop();
                }*/
            });

            KeyboardAdapter.reset();
        },

        //update() {
            // For keyboards, we want to convert the state of the various arrow keys being held down
            // into a directional vector. We use the browser's event to handle the held state of
            // the other action buttons, so we don't need to process them here.
            /*let state =
                (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +
                (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +
                (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +
                (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);*/

            //KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];
        //},

        reset() {
            //KeyboardAdapter.direction = 0;
            for (let action of Input.Action) {
                KeyboardAdapter.held[action] = false;
            }
            //KeyboardAdapter.held = [];
            //KeyboardAdapter.held.length = 0;
        }
    };

    // Input


    const Input = {
        // Game Inputs

        // Extreme hack
        //
        Action: [
            'ArrowUp',
            'ArrowLeft',
            'ArrowDown',
            'ArrowRight',
            'Escape',
            'Space',
            'KeyV',
            'KeyH',
            'KeyA',
            'KeyS',
            'KeyB',
            'KeyT',
            'KeyM'
        ],

        init() {
            // A vector representing the direction the user is pressing/facing,
            // separate from pressing and releasing inputs. Treating "direction"
            // separately makes it easier to handle gamepad sticks.
            //this.direction = { x: 0, y: 0, m: 0 };

            // "Pressed" means an input was pressed THIS FRAME.
            this.pressed = {};

            // "Released" means an input was released THIS FRAME.
            this.released = {};

            // "Held" means an input is held down. The input was "Pressed" either
            // this frame or in a past frame, and has not been "Released" yet.
            this.held = {};

            KeyboardAdapter.init();
        },

        update() {
            // We could have some kind of "input adapter toggle", but it's easier to just treat all inputs
            // as valid -- if you're pressing the "attack" button on either gamepad or keyboard, then you're
            // attacking. For directional input, we instead check whether there's movement on the thumbstick,
            // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.

            //KeyboardAdapter.update();

            for (let action of Input.Action) {
                let held = KeyboardAdapter.held[action];
                this.pressed[action] = !this.held[action] && held;
                this.released[action] = this.held[action] && !held;

                this.held[action] = held;
            }

            //this.pointer = pointerAdapter.pointer;
            //this.direction = KeyboardAdapter.direction;
            //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;
        }
    };

    // AshParticle


    class AshParticle {
        constructor() {
            this.t = -1;
            this.d = 60;

            this.pos = { u: Math.random() * 320, v: Math.random() * 200 };
            this.layer = Math.floor(Math.random() * 3) + 1;
            this.alpha = 1;
        }

        update() {
            if (++this.t === this.d) {
                this.cull = true;
            }

            if (this.t > 36) {
                this.alpha -= 0.02;
            }

            this.pos.v += 0.1;
            if (this.pos.v < 3) this.pos.v += 0.02;
            if (this.pos.v < 2) this.pos.v += 0.02;

            if (Math.random() < 0.05) {
                this.pos.u += 0.5;
            }
        }

        draw() {
            Viewport.ctx.globalAlpha = this.alpha;
            Viewport.ctx.drawImage(Sprite.particle[this.layer - 1].img, Math.floor(this.pos.u), Math.floor(this.pos.v));
            Viewport.ctx.globalAlpha = 1;
        }
    }

    // Particle


    class VillagerChunkParticle {
        constructor(pos) {
            this.t = -1;
            this.d = 30;

            this.angle = Math.random() * Math.PI + Math.PI;
            this.vector = angle2vector(this.angle);
            this.m = 50 + Math.random() * 25;
            this.a = Math.random() * Math.PI * 2;
            this.ad = 0.1;

            this.pos = { u: pos.u, v: pos.v - 12 };
            this.pos.u += this.vector.x * 3;
            this.pos.v += this.vector.y * 3;

            this.frame = Math.floor(Math.random() * 6);
        }

        update() {
            if (++this.t === this.d) {
                this.cull = true;
            }

            this.pos.u += (this.m / this.d) * this.vector.x;
            this.pos.v += (this.m / this.d) * this.vector.y;
            this.vector.x *= 0.95;
            this.vector.y *= 0.95;
            this.vector.y += 0.05;

            this.a += this.ad;
        }

        draw() {
            Sprite.drawViewportSprite(Sprite.villagerchunk[this.frame], this.pos, this.a);
        }
    }

    // SacrificeParticle


    class SacrificeParticle {
        constructor(villager) {
            this.t = -1;
            this.d = 30;
            this.villager = villager;
        }

        update() {
            if (++this.t === this.d) {
                game.gameScene.grantSanity(10);
                this.cull = true;
            }

            if (this.t >= 24 && this.t <= 27) {
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
                game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
            }
            if (this.t === 24) {
                Audio.play(Audio.explosion);
            }

            this.villager.pos.v -= 0.2;
        }

        draw() {
            let v = Math.floor(this.villager.pos.v);

            if (this.t >= 0 && this.t < 15) {
                let shake = (this.t % 3) - 1;
                Sprite.drawViewportSprite(Sprite.villager[0], { u: this.villager.pos.u + shake, v: v });
            } else if (this.t >= 15 && this.t <= 25) {
                Sprite.drawViewportSprite(Sprite.villagerdeath[0], { u: this.villager.pos.u, v: v });
            }
        }
    }

    // Button


    class Button {
        constructor(u, v, hotkey, text) {
            this.u = u;
            this.v = v;
            this.hotkey = hotkey;
            this.text = text;
            this.visible = false;
            this.active = false;
        }

        update() {
            if (!this.visible) return;
        }

        draw() {
            if (!this.visible) return;

            const frame = this.active ? 0 : 2;
            const colorIndex = this.active ? 4 : 2;
            const bgColorIndex = this.active ? 0 : 2;
            Viewport.ctx.drawImage(Sprite.button[frame].img, this.u, this.v);
            Text.drawText(Viewport.ctx, this.hotkey, this.u + 2, this.v + 2, 1, Text.palette[bgColorIndex]);
            Text.drawText(Viewport.ctx, this.text.toUpperCase(), this.u + 11, this.v + 2, 1, Text.palette[colorIndex]);
        }
    }

    // TweenChain

    class TweenChain {
        constructor(tweenArray) {
            this.t = -1;
            this.tweenArray = tweenArray;
        }

        update() {
            this.t++;

            if (this.t < this.tweenArray[0].t1) {
                this.value = this.tweenArray[0].v1;
                this.facing = (this.tweenArray[0].v2 - this.tweenArray[0].v1 >= 0 ? 1 : 0);
                return;
            }

            if (this.t >= this.tweenArray[this.tweenArray.length - 1].t2) {
                this.value = this.tweenArray[this.tweenArray.length - 1].v2;
                this.facing = (this.tweenArray[this.tweenArray.length - 1].v2 - this.tweenArray[this.tweenArray.length - 1].v1 >= 0 ? 1 : 0);
                this.finished = true;
                return;
            }

            for (let i = 0; i < this.tweenArray.length; i++) {
                if (this.t >= this.tweenArray[i].t1 && this.t < this.tweenArray[i].t2) {
                    // A tween chain can have an "undefined" start value, which means
                    // just inherit the last value of the previous tween.
                    if (this.tweenArray[i].v1 === undefined) {
                        this.tweenArray[i].v1 = this.tweenArray[i - 1].v2;
                    }

                    // Apply stagger on the fly; this allows for randomization of the DESTINATION
                    // (we assume the start point does not move).
                    if (this.tweenArray[i].stagger) {
                        this.tweenArray[i].v2 += Math.floor(Math.random() * this.tweenArray[i].stagger - this.tweenArray[i].stagger / 2);
                        this.tweenArray[i].stagger = undefined;
                    }

                    this.value = (this.tweenArray[i].v2 - this.tweenArray[i].v1)
                        * (this.t - this.tweenArray[i].t1)
                        / (this.tweenArray[i].t2 - this.tweenArray[i].t1)
                        + this.tweenArray[i].v1;

                    // For every frame, we provide a utility "facing" value: 1 if the current
                    // movement trends RIGHT, 0 if the current movement trends LEFT.
                    this.facing = (this.tweenArray[i].v2 - this.tweenArray[i].v1 >= 0 ? 1 : 0);
                    break;
                }
            }
        }
    }

    // HeightMapData
    //
    // This file is generated by `gulp buildAssets`.

    const HeightMapData =
    /* <generated-data> */
    [ [],
      [ 149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        148,
        148,
        148,
        148,
        148,
        148,
        147,
        147,
        147,
        146,
        146,
        146,
        145,
        145,
        144,
        144,
        144,
        143,
        143,
        142,
        141,
        141,
        141,
        140,
        140,
        140,
        139,
        139,
        139,
        139,
        139,
        138,
        138,
        138,
        138,
        138,
        138,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        136,
        136,
        136,
        135,
        135,
        135,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        134,
        135,
        135,
        135,
        136,
        136,
        136,
        137,
        137,
        137,
        137,
        137,
        137,
        138,
        138,
        138,
        138,
        139,
        139,
        139,
        139,
        140,
        140,
        140,
        140,
        141,
        141,
        141,
        141,
        142,
        142,
        142,
        142,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        145,
        145,
        146,
        145,
        145,
        145,
        145,
        145,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        145,
        146,
        146,
        147,
        147,
        148,
        148,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        148,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        147,
        148,
        148,
        149,
        149,
        149,
        149,
        150,
        150,
        150,
        150,
        151,
        151,
        152,
        152,
        152,
        153,
        153,
        153,
        154,
        154,
        154,
        154,
        154,
        154,
        153,
        153,
        153,
        153,
        152,
        152,
        152,
        152,
        151,
        151,
        151,
        151,
        151,
        151,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        150,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149,
        149 ],
      [ 126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        126,
        127,
        128,
        128,
        129,
        129,
        129,
        130,
        130,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        131,
        132,
        132,
        132,
        132,
        132,
        132,
        133,
        133,
        133,
        133,
        133,
        134,
        134,
        135,
        136,
        136,
        137,
        138,
        138,
        139,
        139,
        139,
        140,
        140,
        140,
        140,
        139,
        139,
        139,
        139,
        139,
        139,
        138,
        138,
        138,
        138,
        138,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        137,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        138,
        139,
        139,
        139,
        139,
        140,
        140,
        141,
        141,
        141,
        142,
        142,
        142,
        143,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        142,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        144,
        144,
        144,
        145,
        145,
        145,
        145,
        145,
        145,
        145,
        146,
        145,
        145,
        145,
        145,
        144,
        144,
        144,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        144,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143,
        143 ],
      [] ]
    /* </generated-data> */
    ;

    // Villager


    const IDLE = 0;
    const WOODCUTTER = 1;
    const BUTCHER = 2;
    const TALLOWER = 3;
    const STONECUTTER = 4;

    class IdleTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 30, v1: 0, v2: 0 }
            ]);
            this.frame = 0;
            this.layer = 1;
        }

        completeTask() { }
    }

    class ButcherTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: -76, stagger: 20 },
                { t1: 120, t2: 180, v1: undefined, v2: -76, stagger: 20 },
                { t1: 180, t2: 300, v1: undefined, v2: 0 }
            ]);
            this.layer = 1;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
            this.equipmentframe = (this.t > 60 && this.t < 210) ? 3 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.gatherMeat();
        }
    }

    class WoodcutterTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: 140, stagger: 15 },
                { t1: 120, t2: 180, v1: undefined, v2: 140, stagger: 15 },
                { t1: 180, t2: 300, v1: undefined, v2: 0 }
            ]);
            this.layer = 1;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 130 && this.t < 170) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
            this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.gatherWood();
        }
    }

    class TallowerTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: 47 },
                { t1: 120, t2: 180, v1: 47, v2: 47 },
                { t1: 180, t2: 300, v1: 47, v2: 0 }
            ]);
            this.layer = 2;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + 7 + facing * VILLAGER_FRAMES;
            //this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.craftTorch();
        }
    }

    class StonecutterTask extends TweenChain {
        constructor() {
            super([
                { t1: 0, t2: 120, v1: 0, v2: -141 },
                { t1: 120, t2: 180, v1: -141, v2: -141 },
                { t1: 180, t2: 300, v1: -141, v2: 0 }
            ]);
            this.layer = 1;
            this.frame = 0;
        }

        update() {
            super.update();

            const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

            this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
            this.equipmentframe = (this.t > 60 && this.t < 210) ? 5 + facing * VILLAGER_FRAMES : undefined;
        }

        completeTask() {
            game.gameScene.gatherStone();
        }
    }

    const TaskClass = {
        [WOODCUTTER]: WoodcutterTask,
        [BUTCHER]: ButcherTask,
        [TALLOWER]: TallowerTask,
        [STONECUTTER]: StonecutterTask,
        [IDLE]: IdleTask
    };

    class Villager {
        static JOB_NAMES = ['', 'WOODCUTTER', 'BUTCHER', 'TALLOWER', 'STONEMASON', 'FIREKEEPER', 'TOTEMCARVER'];

        constructor(job) {
            this.job = job;
            this.t = 0;
            this.pos = { u: 0, v: 0 };
        }

        update() {
            if (!this.task) {
                this.task = new TaskClass[this.job]();
            }

            this.task.update();

            this.layer = this.task.layer;
            this.pos.u = 160 + this.task.value;
            this.pos.v = HeightMapData[this.layer][Math.floor(this.pos.u)] - 32 + 1;
            this.frame = this.task.frame || 0;
            this.equipmentframe = this.task.equipmentframe;

            if (this.task.finished) {
                this.task.completeTask(this);
                this.task = undefined;
            }
        }

        draw() {
            Sprite.drawViewportSprite(Sprite.villager[this.frame], this.pos);

            if (this.equipmentframe > -1) {
                Sprite.drawViewportSprite(Sprite.villager[this.equipmentframe], this.pos);
            }
        }

        newTask() {
            return new TaskClass[this.job]();
        }
    }

    // TextFloatParticle


    class TextFloatParticle {
        constructor(pos, text, paletteRange) {
            this.pos = { ...pos };
            this.text = text;
            this.paletteRange = paletteRange;
            this.t = -1;
            this.d = 30;
        }

        update() {
            if (++this.t === this.d) this.cull = true;
            this.pos.v -= 0.2;
            this.paletteColor = Math.round((this.paletteRange[1] - this.paletteRange[0]) * (this.t/this.d) + this.paletteRange[0]);
        }

        draw() {
            Text.drawText(Viewport.ctx, this.text, this.pos.u, this.pos.v, 1, Text.palette[this.paletteColor]);
        }
    }

    // WinkParticle


    class WinkParticle {
        constructor() {
            this.t = -1;
            this.d = 15;
            this.winkframe = 3;
            this.layer = 1;
        }

        update() {
            if (++this.t === this.d) {
                this.cull = true;
            }

            if (this.t === 2) {
                this.winkframe = 0;
            } else if (this.t === 6) {
                this.winkframe++;
            } else if (this.t === 8) {
                this.winkframe++;
            } else if (this.t === 10) {
                this.winkframe++;
            }
        }

        draw() {
            console.log('draw wink');
            Viewport.ctx.drawImage(Sprite.wink[this.winkframe].img, 160 + 11 - 1, 73 - 30 + 9 - 2);
        }
    }

    // HelpScene


    class HelpScene {
        static pagesUnlocked = 4;
        static help = [
            {
                title: 'SANITY',
                text: 'The sanity of the village is already eroding. If it runs out before you accomplish your mission, you lose.',
                arrow: [278, 38]
            },
            {
                title: 'INFLUENCE',
                text: 'Use your influence to control villagers. The more villagers you have, the longer it takes to gain another.',
                arrow: [100, 3]
            },
            {
                title: 'JOBS',
                text: 'Use the arrow keys to switch jobs and change the number of villagers assigned to a job. As you unlock additional jobs, adjust the number of villagers assigned to accomplish your goals.',
                arrow: [65, 122]
            },
            {
                title: 'RESOURCES',
                text: 'Resources are produced constantly by villagers each turn. Some resources consume other resources to produce, so watch resource levels carefully.',
                arrow: [170, 128]
            }
        ];

        constructor(page) {
            this.page = page || 0;
            this.t = 0;
        }

        update() {
            this.t++;
            this.bounceX = Math.floor(Math.cos(this.t / 8) * 3);

            if (Input.pressed['ArrowRight']) {
                this.page = (this.page + 1) % HelpScene.pagesUnlocked;
            }

            if (Input.pressed['ArrowLeft']) {
                this.page = (this.page + HelpScene.pagesUnlocked - 1) % HelpScene.pagesUnlocked;
            }

            if (Input.pressed['Escape']) {
                game.scenes.pop();
            }
        }

        draw() {
            Viewport.ctx.fillStyle = rgba(0, 0, 0, 0.66);
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            const page = HelpScene.help[this.page];

            const titleText = page.title.toUpperCase();
            const titleWidth = Text.measure(titleText, 1).w;
            Text.drawText(Viewport.ctx, titleText, (Viewport.width - titleWidth) / 2, 35, 1, Text.palette[4]);
            Text.drawParagraph(Viewport.ctx, page.text.toUpperCase(), 80, 50, 180, 1, Text.palette[4]);

            if (page.arrow) {
                Viewport.ctx.drawImage(Sprite.bigarrows[0].img, page.arrow[0] + this.bounceX, page.arrow[1]);
            }

            const helpText = `HELP PAGE ${this.page + 1}/${HelpScene.pagesUnlocked}    \\l\\r MORE HELP    \\e BACK`;
            const helpWidth = Text.measure(helpText, 1).w;
            Text.drawText(Viewport.ctx, helpText, (Viewport.width - helpWidth) / 2, 170, 1, Text.palette[4]);
        }
    }

    // DefeatScene


    class DefeatScene {
        constructor(stats) {
            this.stats = stats;

            this.text = [
                'THE LAST SPARK OF SANITY FADES IN ULTHAR, AND WITH IT',
                'ANY HOPE OF DELIVERANCE FOR YOU AND YOUR KIN.',
                '',
                'WOOD GATHERED: ' + this.stats.woodGathered,
                'MEAT BUTCHERED: ' + this.stats.meatGathered,
                'TORCHES CRAFTED: ' + this.stats.torchesCrafted,
                'STONE MINED: ' + this.stats.stoneGathered,
                'SECONDS SURVIVED: ' + this.stats.seconds
            ];
            this.frames = 0;
        }

        update() {
            this.frames++;

            if (Input.pressed['Space']) {
                game.scenes.pop();
            }
        }

        draw() {
            Viewport.ctx.fillStyle = '#0a1a2f';
            Viewport.ctx.fillRect(-5, 0, Viewport.width + 5, Viewport.height);

            const gameOverWidth = Text.measure('GAME OVER', 2).w;
            Text.drawText(Viewport.ctx, 'GAME OVER', (Viewport.width - gameOverWidth) / 2, 10, 2, Text.palette[4]);

            //Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 73 - 30);
            Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 61 - 30);

            for (let i = 0; i < this.text.length; i++) {
                let width = Text.measure(this.text[i], 1).w;
                Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 80 + i * 10, 1, Text.palette[4]);
            }
        }
    }

    // GameScene


    const BUTTON_RECRUIT_VILLAGER = 0;
    const BUTTON_SACRIFICE_VILLAGER = 1;
    const BUTTON_REPAIR_BRIDGE = 2;
    const BUTTON_REPAIR_HALL = 3;
    const BUTTON_REPAIR_ALTAR = 4;
    const BUTTON_HELP = 5;

    class GameScene {
        constructor() {
            game.gameScene = this;
            this.entities = [];
            this.screenshakes = [];

            // Clock
            this.t = 0;
            this.influence = 5;
            this.sanity = 100;

            // Inventory
            this.meat = 0;
            this.wood = 0;
            this.stone = 0;
            this.torches = 0;

            // Playthrough Stats
            this.meatGathered = 0;
            this.woodGathered = 0;
            this.stoneGathered = 0;
            this.villagersRecruited = 0;
            this.torchesCrafted = 0;

            this.buttons = [];
            //this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button((320-80)/2, 15, 'V', 'Recruit Villager');
            //this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button((320-80)/2, 15, 'S', 'Sacrifice Villager');
            this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button(5, 3, 'V', 'Recruit Villager');
            this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button(5, 13, 'S', 'Sacrifice Villager');
            this.buttons[BUTTON_REPAIR_BRIDGE] = new Button(5, 23, 'B', 'REPAIR BRIDGE');
            this.buttons[BUTTON_REPAIR_HALL] = new Button(5, 33, 'T', 'REPAIR TALLOW HALL');
            this.buttons[BUTTON_REPAIR_ALTAR] = new Button(5, 43, 'A', 'BUILD ALTAR');
            this.buttons[BUTTON_HELP] = new Button(285, 168, 'H', 'HELP');
            this.buttons[BUTTON_HELP].visible = true;
            this.buttons[BUTTON_HELP].active = true;

            this.selectedJob = WOODCUTTER;
            this.jobsDisplayed = [WOODCUTTER];

            this.villagers = [];
            this.villagersWithJob = [[], [], [], [], [], [], [], []];

            this.techBridge = false;
            this.techTorches = false;
            this.techStone = false;
            this.techAltar = false;
        }

        update() {
            // Set up displayed jobs
            this.jobsDisplayed = [WOODCUTTER];
            if (this.techBridge) {
                this.jobsDisplayed.push(BUTCHER);
            }
            if (this.techTorches) {
                this.jobsDisplayed.push(TALLOWER);
            }
            if (this.techStone) {
                this.jobsDisplayed.push(STONECUTTER);
            }

            if (this.torches > 0 && !this.techStone) {
                this.techStone = true;
            }

            // Player input

                    // move
            ///this.pos.x += this.vel.x;
            ///this.pos.y += this.vel.y;

            if (Input.pressed['KeyV']) {
                this.recruitVillager();
            }

            if (Input.pressed['KeyB']) {
                this.buildBridge();
            }

            if (Input.pressed['KeyT']) {
                this.buildHall();
            }

            if (Input.pressed['KeyA']) {
                this.buildAltar();
            }

            if (Input.pressed['ArrowDown']) {
                this.moveJobSelector(1);
            }

            if (Input.pressed['ArrowUp']) {
                this.moveJobSelector(-1);
            }

            if (Input.pressed['ArrowRight']) {
                this.hireVillager(this.selectedJob);
            }

            if (Input.pressed['ArrowLeft']) {
                this.fireVillager(this.selectedJob);
            }

            if (Input.pressed['KeyS']) {
                this.sacrificeVillager();
            }

            if (Input.pressed['Space']) {
                this.sanity -= 10;
            }

            if (Input.pressed['KeyH']) {
                game.scenes.push(new HelpScene());
            }

            // Game ticks

            this.t++;

            if (!this.nextSanityTick) {
                this.nextSanityTick = this.t + 12;
            }

            if (this.t >= this.nextSanityTick) {
                this.sanity -= 0.2;
                this.influence += 0.2;
                this.nextSanityTick = this.t + 12;
            }

            if (this.t === 40) {
                Audio.play(Audio.start);
            }

            // Button UI Elements

            this.buttons[BUTTON_RECRUIT_VILLAGER].active = (this.influence >= this.nextWorkerCost());
            this.buttons[BUTTON_RECRUIT_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_RECRUIT_VILLAGER].active);

            this.buttons[BUTTON_SACRIFICE_VILLAGER].active = (true);
            this.buttons[BUTTON_SACRIFICE_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_SACRIFICE_VILLAGER].active);

            this.buttons[BUTTON_REPAIR_BRIDGE].active = (this.wood >= 10);
            this.buttons[BUTTON_REPAIR_BRIDGE].visible = !this.techBridge && this.wood >= 10;

            this.buttons[BUTTON_REPAIR_HALL].active = (this.wood >= 10);
            this.buttons[BUTTON_REPAIR_HALL].visible = this.techBridge && !this.techTorches && this.wood >= 10;

            this.buttons[BUTTON_REPAIR_ALTAR].active = (this.stone >= 10);
            this.buttons[BUTTON_REPAIR_ALTAR].visible = this.techTorches && !this.techAltar && this.stone >= 10;

            let visibleButtonY = 3;
            for (let i = 0; i < 5; i++) {
                if (this.buttons[i].visible) {
                    this.buttons[i].y = visibleButtonY;
                    visibleButtonY += 10;
                }
            }

            // Villagers

            for (const villager of this.villagers) {
                villager.update();
            }

            // Entities

            if (this.t > 35) {
                for (const entity of this.entities) {
                    entity.update();
                }
                this.entities = this.entities.filter(entity => !entity.cull);
            }

            // Check

            if (this.sanity < 0) {
                this.playerLost();
            }

            // Ash Particles

            if (this.entities.length < 33) {
                this.entities.push(new AshParticle());
            }

            if (this.t % 60 === 0) ;
        }

        draw() {
            let terrainY = this.t > 36 ? 0 : (285 - 285 * this.t / 36);

            // Background

            Viewport.ctx.fillStyle = '#40985e';
            Viewport.ctx.fillRect(0, 0, Viewport.width + 5, Viewport.height);

            // Layer 3 (farthest)

            Viewport.ctx.drawImage(Sprite.terrain[2].img, 0, Math.floor(0 + terrainY * 0.8 * 0.8));

            for (let entity of this.entities) {
                if (entity.layer === 3) entity.draw();
            }

            for (let villager of this.villagers) {
                if (villager.layer === 2) villager.draw();
            }

            // Layer 2 (middle)

            Viewport.ctx.drawImage(Sprite.terrain[1].img, 0, Math.floor(0 + terrainY * 0.8));

            for (let entity of this.entities) {
                if (entity.layer === 2) entity.draw();
            }

            for (let villager of this.villagers) {
                if (villager.layer === 2) villager.draw();
            }

            // Layer 1 (closest)

            Viewport.ctx.drawImage(Sprite.terrain[0].img, 0, Math.floor(0 + terrainY));

            // Black cat perch

            Viewport.ctx.drawImage(Sprite.blackcat[0].img, 160, 73 - 30);

            for (let entity of this.entities) {
                if (entity.layer === 1 || !entity.layer) entity.draw();
            }

            for (let villager of this.villagers) {
                if (villager.layer === 1) villager.draw();
            }

            /*Viewport.ctx.fillStyle = '#0a1a2f';
            Viewport.ctx.fillRect(-5, Viewport.height - 31, Viewport.width + 5, 31);*/

            // Bridge

            if (this.t > 40) {
            if (this.techBridge) {
                Viewport.ctx.drawImage(Sprite.bridge[1].img, 112, 133 - 32);
            } else {
                Viewport.ctx.drawImage(Sprite.bridge[0].img, 112, 133 - 32);
            }

            // Tallower Hall

            if (this.techTorches) {
                Viewport.ctx.drawImage(Sprite.factory[1].img, 198, 133 - 32);
            } else {
                Viewport.ctx.drawImage(Sprite.factory[0].img, 198, 133 - 32);
            }

            // Altar

            if (this.techAltar) {
                let altarY = Math.floor(Math.sin(this.t / 25) * 2);
                Viewport.ctx.drawImage(Sprite.altar[0].img, 238, 116 - 30);
                Viewport.ctx.drawImage(Sprite.altar[1].img, 238, 115 - 30 + altarY);
            }

            /*
                // (Debug) raw numbers
                let crunk = String(Math.floor(this.sanity)) + ',' + String(Math.floor(this.influence)) + ',' + String(this.villagers.length);
                Text.drawText(Viewport.ctx, crunk, 3, 3, 1, Text.palette[1]);
            */

            if (game.scene === this) {
                // Hide button prompts if Help Screen is displayed, to avoid confusion
                for (const button of this.buttons) {
                    button.draw();
                }
            }

            this.drawSanityBar();
            this.drawInfluenceBar();
            this.drawJobSelectUI();
            this.drawInventory();
            }
        }

        drawSanityBar() {
            let k = Math.floor((this.sanity / 100) * 78);
            Viewport.ctx.drawImage(Sprite.sanitybar[0].img, 320-18-5, -3);
            Viewport.ctx.drawImage(Sprite.sanitybar[1].img, 320-18-5, -3);
            Viewport.ctx.drawImage(Sprite.sanitybar[2].img,
                0, 2 + (78 - k),
                18, k,
                320-18-5, -3 + 2 + (78 - k),
                18, k
            );
        }

        drawInfluenceBar() {
            let k = Math.floor(Math.min(this.influence / this.nextWorkerCost(), 1) * 80);
            Viewport.ctx.drawImage(Sprite.influencebar[0].img, (320-80)/2, 3);
            Viewport.ctx.drawImage(Sprite.influencebar[1].img,
                2, 3,
                k, 4,
                (320-80)/2 + 2, 3 + 3,
                k, 4
            );
        }

        drawJobSelectUI() {
            const cornerX = 7;
            const cornerY = 120;
            const verticalMargin = 10;

            let selectedIdx = 0;

            for (let i = 0; i < this.jobsDisplayed.length; i++) {
                if (this.selectedJob === this.jobsDisplayed[i]) {
                    selectedIdx = i;
                }

                const color = this.selectedJob === this.jobsDisplayed[i] ? Text.palette[3] : Text.palette[2];
                const numberText = String(this.villagersWithJob[this.jobsDisplayed[i]].length);
                const width = Text.measure(numberText).w;
                Text.drawText(Viewport.ctx, Villager.JOB_NAMES[this.jobsDisplayed[i]], cornerX + 5, cornerY + 4 + verticalMargin * i, 1, color);
                Text.drawText(Viewport.ctx, numberText, cornerX + 92 - width, cornerY + 4 + verticalMargin * i, 1, color);
            }

            const leftArrow = this.villagersWithJob[this.selectedJob].length > 0 ? 0 : 2;
            const rightArrow = this.villagersWithJob[IDLE].length > 0 ? 1 : 3;

            Viewport.ctx.drawImage(Sprite.jobselect[0].img, cornerX, cornerY + selectedIdx * verticalMargin);
            Viewport.ctx.drawImage(Sprite.smallarrows[leftArrow].img, cornerX + 77, cornerY + 4 + selectedIdx * verticalMargin);
            Viewport.ctx.drawImage(Sprite.smallarrows[rightArrow].img, cornerX + 94, cornerY + 4 + selectedIdx * verticalMargin);
        }

        drawInventory() {
            let woodWidth = Text.measure(String(this.wood), 1).w;
            let meatWidth = Text.measure(String(this.meat), 1).w;
            let stoneWidth = Text.measure(String(this.stone), 1).w;
            let torchWidth = Text.measure(String(this.torches), 1).w;

            Viewport.ctx.drawImage(Sprite.icons[0].img, INVENTORY_WOOD_POS.u - 60, INVENTORY_WOOD_POS.v - 1);
            Text.drawText(Viewport.ctx, 'WOOD', INVENTORY_WOOD_POS.u - 50, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);
            Text.drawText(Viewport.ctx, String(this.wood), INVENTORY_WOOD_POS.u - woodWidth, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);

            if (this.techBridge) {
                Viewport.ctx.drawImage(Sprite.icons[2].img, INVENTORY_MEAT_POS.u - 60, INVENTORY_MEAT_POS.v - 1);
                Text.drawText(Viewport.ctx, 'MEAT', INVENTORY_MEAT_POS.u - 50, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
                Text.drawText(Viewport.ctx, String(this.meat), INVENTORY_MEAT_POS.u - meatWidth, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
            }

            if (this.techTorches) {
                Viewport.ctx.drawImage(Sprite.icons[3].img, INVENTORY_TORCH_POS.u - 60, INVENTORY_TORCH_POS.v - 1);
                Text.drawText(Viewport.ctx, 'TORCHES', INVENTORY_TORCH_POS.u - 50, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
                Text.drawText(Viewport.ctx, String(this.torches), INVENTORY_TORCH_POS.u - torchWidth, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
            }

            if (this.techStone) {
                Viewport.ctx.drawImage(Sprite.icons[1].img, INVENTORY_STONE_POS.u - 60, INVENTORY_STONE_POS.v - 1);
                Text.drawText(Viewport.ctx, 'STONE', INVENTORY_STONE_POS.u - 50, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
                Text.drawText(Viewport.ctx, String(this.stone), INVENTORY_STONE_POS.u - stoneWidth, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
            }

        }

        addScreenShake(screenshake) {
            // This screen shake applies to the entire rendered screen, including GUI
            this.screenshakes.push(screenshake);
        }

        moveJobSelector(delta) {
            let idx = this.jobsDisplayed.indexOf(this.selectedJob);
            idx = (idx + delta + this.jobsDisplayed.length) % this.jobsDisplayed.length;
            this.selectedJob = this.jobsDisplayed[idx];
        }

        recruitVillager() {
            const cost = this.nextWorkerCost();
            if (this.influence >= cost) {
                this.influence -= cost;

                const villager = new Villager(this.selectedJob || WOODCUTTER);
                this.villagers.push(villager);
                this.villagersWithJob[villager.job].push(villager);
                this.villagersRecruited++;

                this.entities.push(new WinkParticle());
                Audio.play(Audio.wink);
                return true;
            }

            return false;
        }

        hireVillager() {
            if (this.villagersWithJob[IDLE].length > 0) {
                // TODO
                const villager = this.villagersWithJob[IDLE].pop();
                villager.job = this.selectedJob;
                this.villagersWithJob[this.selectedJob].push(villager);
                return true;
            }
            return false;
        }

        fireVillager() {
            if (this.villagersWithJob[this.selectedJob].length > 0) {
                // TODO
                const villager = this.villagersWithJob[this.selectedJob].pop();
                villager.job = IDLE;
                this.villagersWithJob[IDLE].push(villager);
                return true;
            }
            return false;
        }

        sacrificeVillager() {
            if (this.villagersWithJob[this.selectedJob].length > 0) {
                // TODO - pick right villager
                const villager = this.villagersWithJob[this.selectedJob].pop();

                this.villagers.splice(this.villagers.indexOf(villager), 1);

                this.entities.push(new SacrificeParticle(villager));
                this.entities.push(new WinkParticle());
                Audio.play(Audio.wink);

                //villager.job = SACRIFICE;
                //this.villagersWithJob[SACRIFICE].push(villager);
                //this.activeSacrifice = new SacrificeParticle();
                //console.log('VILLAGER DEAD');
                return true;
            }
            return false;
        }

        consumeMeat() {
            if (this.meat > 0) {
                this.meat--;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-1', [4, 2]));
            } else {
                this.sanity--;
                this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '-1', [0, 2]));
            }
        }

        grantSanity(value) {
            if (this.sanity < 100) {
                this.sanity = Math.min(100, this.sanity + value);
                this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '+' + value, [0, 2]));
            }
        }

        gatherMeat() {
            this.meat += 5;
            this.meatGathered += 5;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '+5', [4, 2]));
        }

        gatherWood() {
            this.wood += 5;
            this.woodGathered += 5;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '+5', [4, 2]));
        }

        craftTorch() {
            this.torches += 1;
            this.torchesCrafted += 1;
            this.wood -= 2;
            this.meat -= 2;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: INVENTORY_TORCH_POS.u + 6, v: INVENTORY_TORCH_POS.v }, '+1', [4, 2]));
            this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-2', [4, 2]));
            this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-2', [4, 2]));
        }

        gatherStone() {
            this.stone += 5;
            this.stoneGathered += 5;
            this.consumeMeat();
            this.entities.push(new TextFloatParticle({ u: 100, v: 100 }, '+5', [4, 2]));
            this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '+5', [4, 2]));
        }

        buildBridge() {
            const button = this.buttons[BUTTON_REPAIR_BRIDGE];

            if (button.active && button.visible && this.wood >= 10 && !this.techBridge) {
                this.wood -= 10;
                this.techBridge = true;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

                // TODO build bridge animation
            }
        }

        buildHall() {
            const button = this.buttons[BUTTON_REPAIR_HALL];

            if (button.active && button.visible && this.wood >= 10 && !this.techTorches) {
                this.wood -= 10;
                this.techTorches = true;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

                // TODO build hall animation
            }
        }

        buildAltar() {
            const button = this.buttons[BUTTON_REPAIR_ALTAR];

            if (button.active && button.visible && this.stone >= 10 && !this.techAltar) {
                this.stone -= 10;
                this.techAltar = true;
                this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '-10', [4, 2]));

                // TODO build altar animation
            }
        }

        nextWorkerCost() {
            return Math.floor(1 * Math.pow(1.3, this.villagers.length));
        }

        playerLost() {
            const stats = {
                seconds: Math.floor(this.t / 60),
                woodGathered: this.woodGathered,
                meatGathered: this.meatGathered,
                torchesCrafted: this.torchesCrafted,
                stoneGathered: this.stoneGathered,
            };
            game.scenes.pop();
            game.scenes.push(new DefeatScene(stats));
        }
    }

    // IntroScene


    class IntroScene {
        constructor() {
            this.t = 0;
            this.fadet = -1;
            this.entities = [];
        }

        update() {
            this.t++;

            if (this.fadet >= 0) this.fadet++;

            if (this.fadet === 1) {
                Audio.initTracks();
            }

            if (this.fadet > 20) {
                game.scenes.pop();

                const gameScene = new GameScene();
                game.scenes.push(gameScene);
                gameScene.entities = this.entities;
            }

            if (Input.pressed['Space']) {
                this.fadet = 0;
            }

            if (this.entities.length < 33) {
                this.entities.push(new AshParticle());
            }

            for (let entity of this.entities) {
                entity.update();
            }

            this.entities = this.entities.filter(entity => !entity.cull);
        }

        draw() {
            Viewport.ctx.fillStyle = PALETTE[0];
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

            Viewport.ctx.globalAlpha = Math.min(this.t / 20, 1);
            Viewport.ctx.fillStyle = PALETTE[3];
            Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
            Viewport.ctx.globalAlpha = 1;

            for (let entity of this.entities) {
                entity.draw();
            }

            if (this.t > 30) {
                let adjustment = Math.max(1 - this.t / 54, 0);

                if (!this.x || this.t % 3 === 0) {
                    this.x = [0,1,2,3,4,5,6,7,8].map(x => adjustment * (Math.random() * 12 - 6));
                    this.alpha = [0,1,2,3,4,5,6,7,8].map(x => 1 - adjustment * Math.random());
                }

                for (let i = 0; i < 9; i++) {
                    let y = i * 4;
                    Viewport.ctx.globalAlpha = this.alpha[i];
                    Viewport.ctx.drawImage(Sprite.blackcat[0].img, 0, y, 24, 4, 160 + this.x[i], 73 - 30 + y, 24, 4);
                    Viewport.ctx.globalAlpha = 1;
                }
            }

            if (this.t > 40) {
                let title = 'THE ASHES OF ULTHAR';
                let titleWidth = Text.measure(title, 2).w;
                Text.drawText(Viewport.ctx, title, 168 - titleWidth / 2, 13 - this.fadet * 3, 2, Text.palette[4], Text.palette[1]);
            }

            if (this.t > 48 && this.fadet < 0) {
                let text = 'PRESS SPACE TO PLAY';
                let width = Text.measure(text, 1).w;
                Text.drawText(Viewport.ctx, text, 168 - width / 2, 150, 1, Text.palette[4], Text.palette[1]);
            }
        }
    }

    // Game


    /**
     * Game state.
     */
    class Game {
        init() {
            Sprite.loadSpritesheet(() => {
                Viewport.init();
                Sprite.init();
                Text.init();
                Input.init();
                Audio.init();

                //Camera.init();

                window.addEventListener('blur', () => this.pause());
                window.addEventListener('focus', () => this.unpause());

                this.reset();
                this.start();
            });
        }

        reset() {
            this.scenes = [];
            this.lastFrame = 0;
            this.nextLevel = 0;

            this.scores = [
                { time: 300 * 60, enemiesAlive: 10 },
                { time: 300 * 60, enemiesAlive: 10 },
                { time: 300 * 60, enemiesAlive: 10 },
                { time: 300 * 60, enemiesAlive: 10 }
            ];

            this.scenes.push(new IntroScene());
        }

        start() {
            this.frame = 0;
            this.framestamps = [0];
            this.update();
            window.requestAnimationFrame((xyz) => this.onFrame(xyz));
        }

        onFrame(currentms) {
            let delta = (currentms - this.lastFrame) - (1000 / FPS);

            if (delta >= 0) {
                this.frame++;
                this.lastFrame = (currentms - delta);

                // The above calculation is right for smoothing out frames, but if
                // we end up far behind the currentms, we can "fast play" for a long time
                // which is not desired. Fast-forward if we fall behind more than 5 frames.
                if (currentms - this.lastFrame > 5 * 1000 / FPS) {
                    this.lastFrame = currentms;
                }

                Viewport.resize();
                this.update();
                this.draw(Viewport.ctx);

                // this.framestamps.push(currentms);
                // if (this.framestamps.length >= 120) {
                //     this.framestamps.shift();
                // }
                // this.fps = 1000 / ((this.framestamps[this.framestamps.length - 1] - this.framestamps[0]) / this.framestamps.length);
            }
            window.requestAnimationFrame((xyz) => this.onFrame(xyz));
        }

        update() {
            // Gather user input
            Input.update();

            // Handle special keys that are screen-independent
            if (Input.pressed['KeyM']) {
                console.log('KeyM - toggling music');
                Audio.musicEnabled = !Audio.musicEnabled;
            }
            /*if (Input.pressed[Input.Action.SFX_TOGGLE]) {
                Audio.sfxEnabled = !Audio.sfxEnabled;
            }*/

            // Hand off control to the current "screen" (for example, game screen or menu)
            if (this.scenes.length === 0) {
                this.scenes.push(new GameScene());
            }
            this.scene = this.scenes[this.scenes.length - 1];
            this.scene.update();

            // Do per-frame audio updates
            Audio.update();
        }

        draw() {
            // Reset canvas transform and scale
            Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);
            Viewport.ctx.scale(Viewport.scale, Viewport.scale);

            for (let i = 0; i < this.scenes.length; i++) {
                this.scenes[i].draw();
            }

            //Text.drawText(Viewport.ctx, String(this.fps), 15, 15, 1, Text.white);
        }

        pause() {
            if (this.paused) return;
            this.paused = true;
            Audio.pause();
        }

        unpause() {
            if (!this.paused) return;
            this.paused = false;
            Audio.unpause();
        }
    }

    const game = new Game();

    /**
     * Create and launch game.
     */
    game.init();

})();</script>