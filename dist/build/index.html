<meta charset="utf8"><style>body,html{width:100vw;height:100vh;margin:0;padding:0;background-color:#2c1b2e}#d1{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}#d2{max-width:100vw;max-height:100vh;aspect-ratio:48/27}#canvas{width:100%;height:100%}</style><div id="d1"><div id="d2"><canvas id="canvas"></canvas></div></div><script>(function () {
  'use strict';

  /*

  ZzFX - Zuper Zmall Zound Zynth v1.1.8
  By Frank Force 2019
  https://github.com/KilledByAPixel/ZzFX

  ZzFX Features

  - Tiny synth engine with 20 controllable parameters.
  - Play sounds via code, no need for sound assed files!
  - Compatible with most modern web browsers.
  - Small code footprint, the micro version is under 1 kilobyte.
  - Can produce a huge variety of sound effect types.
  - Sounds can be played with a short call. zzfx(...[,,,,.1,,,,9])
  - A small bit of randomness appied to sounds when played.
  - Use ZZFX.GetNote to get frequencies on a standard diatonic scale.
  - Sounds can be saved out as wav files for offline playback.
  - No additional libraries or dependencies are required.

  */
  /*

    ZzFX MIT License

    Copyright (c) 2019 - Frank Force

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

  */


  // zzfx object with some extra functionalty
  const ZZFX = {
      // master volume scale
      volume: .3,

      // sample rate for audio
      sampleRate: 44100,

      // create shared audio context
      x: new (window.AudioContext || webkitAudioContext),

      destination: undefined,

      // play a sound from zzfx paramerters
      play: function(...parameters)
      {
          // build samples and start sound
          return this.playSamples(this.buildSamples(...parameters));
      },

      // play an array of samples
      playSamples: function(...samples)
      {
          // create buffer and source
          const buffer = this.x.createBuffer(samples.length, samples[0].length, this.sampleRate),
              source = this.x.createBufferSource();

          samples.map((d,i)=> buffer.getChannelData(i).set(d));
          source.buffer = buffer;
          source.connect(this.destination);
          source.start();
          return source;
      },

      // build an array of samples
      buildSamples: function
      (
          volume = 1,
          randomness = .05,
          frequency = 220,
          attack = 0,
          sustain = 0,
          release = .1,
          shape = 0,
          shapeCurve = 1,
          slide = 0,
          deltaSlide = 0,
          pitchJump = 0,
          pitchJumpTime = 0,
          repeatTime = 0,
          noise = 0,
          modulation = 0,
          bitCrush = 0,
          delay = 0,
          sustainVolume = 1,
          decay = 0,
          tremolo = 0
      )
      {
          // init parameters
          const PI2 = Math.PI*2;
          let sampleRate = this.sampleRate,
          sign = v => v>0?1:-1,
          startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,
          startFrequency = frequency *=
              (1 + randomness*2*Math.random() - randomness) * PI2 / sampleRate,
          b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, f, length;

          // scale by sample rate
          attack = attack * sampleRate + 9; // minimum attack to prevent pop
          decay *= sampleRate;
          sustain *= sampleRate;
          release *= sampleRate;
          delay *= sampleRate;
          deltaSlide *= 500 * PI2 / sampleRate**3;
          modulation *= PI2 / sampleRate;
          pitchJump *= PI2 / sampleRate;
          pitchJumpTime *= sampleRate;
          repeatTime = repeatTime * sampleRate | 0;

          // generate waveform
          for(length = attack + decay + sustain + release + delay | 0;
              i < length; b[i++] = s)
          {
              if (!(++c%(bitCrush*100|0)))                      // bit crush
              {
                  s = shape? shape>1? shape>2? shape>3?         // wave shape
                      Math.sin((t%PI2)**3) :                    // 4 noise
                      Math.max(Math.min(Math.tan(t),1),-1):     // 3 tan
                      1-(2*t/PI2%2+2)%2:                        // 2 saw
                      1-4*Math.abs(Math.round(t/PI2)-t/PI2):    // 1 triangle
                      Math.sin(t);                              // 0 sin

                  s = (repeatTime ?
                          1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo
                          : 1) *
                      sign(s)*(Math.abs(s)**shapeCurve) *       // curve 0=square, 2=pointy
                      volume * this.volume * (                  // envelope
                      i < attack ? i/attack :                   // attack
                      i < attack + decay ?                      // decay
                      1-((i-attack)/decay)*(1-sustainVolume) :  // decay falloff
                      i < attack  + decay + sustain ?           // sustain
                      sustainVolume :                           // sustain volume
                      i < length - delay ?                      // release
                      (length - i - delay)/release *            // release falloff
                      sustainVolume :                           // release volume
                      0);                                       // post release

                  s = delay ? s/2 + (delay > i ? 0 :            // delay
                      (i<length-delay? 1 : (length-i)/delay) *  // release delay
                      b[i-delay|0]/2) : s;                      // sample delay
              }

              f = (frequency += slide += deltaSlide) *          // frequency
                  Math.cos(modulation*tm++);                    // modulation
              t += f - f*noise*(1 - (Math.sin(i)+1)*1e9%2);     // noise

              if (j && ++j > pitchJumpTime)       // pitch jump
              {
                  frequency += pitchJump;         // apply pitch jump
                  startFrequency += pitchJump;    // also apply to start
                  j = 0;                          // stop pitch jump time
              }

              if (repeatTime && !(++r % repeatTime)) // repeat
              {
                  frequency = startFrequency;     // reset frequency
                  slide = startSlide;             // reset slide
                  j = j || 1;                     // reset pitch jump time
              }
          }

          return b;
      },

      // get frequency of a musical note on a diatonic scale
      getNote: function(semitoneOffset=0, rootNoteFrequency=440)
      {
          return rootNoteFrequency * 2**(semitoneOffset/12);
      }

  }; // ZZFX

  /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
  *
  * Copyright (c) 2011-2013 Marcus Geelnard
  *
  * This software is provided 'as-is', without any express or implied
  * warranty. In no event will the authors be held liable for any damages
  * arising from the use of this software.
  *
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  *
  * 1. The origin of this software must not be misrepresented; you must not
  *    claim that you wrote the original software. If you use this software
  *    in a product, an acknowledgment in the product documentation would be
  *    appreciated but is not required.
  *
  * 2. Altered source versions must be plainly marked as such, and must not be
  *    misrepresented as being the original software.
  *
  * 3. This notice may not be removed or altered from any source
  *    distribution.
  *
  */


  // Some general notes and recommendations:
  //  * This code uses modern ECMAScript features, such as ** instead of
  //    Math.pow(). You may have to modify the code to make it work on older
  //    browsers.
  //  * If you're not using all the functionality (e.g. not all oscillator types,
  //    or certain effects), you can reduce the size of the player routine even
  //    further by deleting the code.


  const CPlayer = function() {

      //--------------------------------------------------------------------------
      // Private methods
      //--------------------------------------------------------------------------

      // Oscillators
      var osc_sin = function (value) {
          return Math.sin(value * 6.283184);
      };

      var osc_saw = function (value) {
          return 2 * (value % 1) - 1;
      };

      var osc_square = function (value) {
          return (value % 1) < 0.5 ? 1 : -1;
      };

      var osc_tri = function (value) {
          var v2 = (value % 1) * 4;
          if(v2 < 2) return v2 - 1;
          return 3 - v2;
      };

      var getnotefreq = function (n) {
          // 174.61.. / 44100 = 0.003959503758 (F3)
          return 0.003959503758 * (2 ** ((n - 128) / 12));
      };

      var createNote = function (instr, n, rowLen) {
          var osc1 = mOscillators[instr.i[0]],
              o1vol = instr.i[1],
              o1xenv = instr.i[3]/32,
              osc2 = mOscillators[instr.i[4]],
              o2vol = instr.i[5],
              o2xenv = instr.i[8]/32,
              noiseVol = instr.i[9],
              attack = instr.i[10] * instr.i[10] * 4,
              sustain = instr.i[11] * instr.i[11] * 4,
              release = instr.i[12] * instr.i[12] * 4,
              releaseInv = 1 / release,
              expDecay = -instr.i[13]/16,
              arp = instr.i[14],
              arpInterval = rowLen * (2 **(2 - instr.i[15]));

          var noteBuf = new Int32Array(attack + sustain + release);

          // Re-trig oscillators
          var c1 = 0, c2 = 0;

          // Local variables.
          var j, j2, e, rsample, o1t, o2t;

          // Generate one note (attack + sustain + release)
          for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
              if (j2 >= 0) {
                  // Switch arpeggio note.
                  arp = (arp >> 8) | ((arp & 255) << 4);
                  j2 -= arpInterval;

                  // Calculate note frequencies for the oscillators
                  o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                  o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
              }

              // Envelope
              e = 1;
              if (j < attack) {
                  e = j / attack;
              } else if (j >= attack + sustain) {
                  e = (j - attack - sustain) * releaseInv;
                  e = (1 - e) * (3 ** (expDecay * e));
              }

              // Oscillator 1
              c1 += o1t * e ** o1xenv;
              rsample = osc1(c1) * o1vol;

              // Oscillator 2
              c2 += o2t * e ** o2xenv;
              rsample += osc2(c2) * o2vol;

              // Noise oscillator
              if (noiseVol) {
                  rsample += (2 * Math.random() - 1) * noiseVol;
              }

              // Add to (mono) channel buffer
              noteBuf[j] = (80 * rsample * e) | 0;
          }

          return noteBuf;
      };


      //--------------------------------------------------------------------------
      // Private members
      //--------------------------------------------------------------------------

      // Array of oscillator functions
      var mOscillators = [
          osc_sin,
          osc_square,
          osc_saw,
          osc_tri
      ];

      // Private variables set up by init()
      var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf, mChannelBufs;


      //--------------------------------------------------------------------------
      // Initialization
      //--------------------------------------------------------------------------

      this.init = function (song) {
          // Define the song
          mSong = song;

          // Init iteration state variables
          mLastRow = song.endPattern;
          mCurrentCol = 0;

          // Prepare song info
          mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

          // Create work buffer (initially cleared)
          mMixBuf = new Int32Array(mNumWords);

          mChannelBufs = [];

          for (let i = 0; i < song.numChannels; i++) {
              mChannelBufs.push(new Int32Array(mNumWords));
          }
      };


      //--------------------------------------------------------------------------
      // Public methods
      //--------------------------------------------------------------------------

      // Generate audio data for a single track
      this.generate = function () {
          // Local variables
          var i, j, p, row, col, n, cp,
              k, t, rsample, rowStartSample, f;

          // Put performance critical items in local variables
          var chnBuf = new Int32Array(mNumWords),
              instr = mSong.songData[mCurrentCol],
              rowLen = mSong.rowLen,
              patternLen = mSong.patternLen;

          // Clear effect state
          var low = 0, band = 0, high;
          var lsample, filterActive = false;

          // Clear note cache.
          var noteCache = [];

           // Patterns
           for (p = 0; p <= mLastRow; ++p) {
              cp = instr.p[p];

              // Pattern rows
              for (row = 0; row < patternLen; ++row) {
                  // Execute effect command.
                  var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                  if (cmdNo) {
                      instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                      // Clear the note cache since the instrument has changed.
                      if (cmdNo < 17) {
                          noteCache = [];
                      }
                  }

                  // Put performance critical instrument properties in local variables
                  var oscLFO = mOscillators[instr.i[16]],
                      lfoAmt = instr.i[17] / 512,
                      lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                      fxLFO = instr.i[19],
                      fxFilter = instr.i[20],
                      fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                      q = 1 - instr.i[22] / 255,
                      dist = instr.i[23] * 1e-5,
                      drive = instr.i[24] / 32,
                      panAmt = instr.i[25] / 512,
                      panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                      dlyAmt = instr.i[27] / 255,
                      dly = instr.i[28] * rowLen & -2;  // Must be an even number

                  // Calculate start sample number for this row in the pattern
                  rowStartSample = (p * patternLen + row) * rowLen;

                  // Generate notes for this pattern row
                  for (col = 0; col < 4; ++col) {
                      n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                      if (n) {
                          if (!noteCache[n]) {
                              noteCache[n] = createNote(instr, n, rowLen);
                          }

                          // Copy note from the note cache
                          var noteBuf = noteCache[n];
                          for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                            chnBuf[i] += noteBuf[j];
                          }
                      }
                  }

                  // Perform effects for this pattern row
                  for (j = 0; j < rowLen; j++) {
                      // Dry mono-sample
                      k = (rowStartSample + j) * 2;
                      rsample = chnBuf[k];

                      // We only do effects if we have some sound input
                      if (rsample || filterActive) {
                          // State variable filter
                          f = fxFreq;
                          if (fxLFO) {
                              f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                          }
                          f = 1.5 * Math.sin(f);
                          low += f * band;
                          high = q * (rsample - band) - low;
                          band += f * high;
                          rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                          // Distortion
                          if (dist) {
                              rsample *= dist;
                              rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                              rsample /= dist;
                          }

                          // Drive
                          rsample *= drive;

                          // Is the filter active (i.e. still audiable)?
                          filterActive = rsample * rsample > 1e-5;

                          // Panning
                          t = Math.sin(panFreq * k) * panAmt + 0.5;
                          lsample = rsample * (1 - t);
                          rsample *= t;
                      } else {
                          lsample = 0;
                      }

                      // Delay is always done, since it does not need sound input
                      if (k >= dly) {
                          // Left channel = left + right[-p] * t
                          lsample += chnBuf[k-dly+1] * dlyAmt;

                          // Right channel = right + left[-p] * t
                          rsample += chnBuf[k-dly] * dlyAmt;
                      }

                      // Store in stereo channel buffer (needed for the delay effect)
                      chnBuf[k] = lsample | 0;
                      chnBuf[k+1] = rsample | 0;

                      // ...and add to stereo mix buffer
                      mMixBuf[k] += lsample | 0;
                      mMixBuf[k+1] += rsample | 0;

                      // ...and channel
                      mChannelBufs[mCurrentCol][k] += lsample | 0;
                      mChannelBufs[mCurrentCol][k+1] += rsample | 0;
                  }
              }
          }

          // Next iteration. Return progress (1.0 == done!).
          mCurrentCol++;
          return mCurrentCol / mSong.numChannels;
      };

      // Create a AudioBuffer from the generated audio data
      this.createAudioBuffer = function(context, channelNumber) {
          let source = channelNumber === undefined ? mMixBuf : mChannelBufs[channelNumber];

          var buffer = context.createBuffer(2, mNumWords / 2, 44100);
          for (var i = 0; i < 2; i ++) {
              var data = buffer.getChannelData(i);
              for (var j = i; j < mNumWords; j += 2) {
                  data[j >> 1] = source[j] / 65536;
              }
          }

          return buffer;
      };

      // Create a WAVE formatted Uint8Array from the generated audio data
      this.createWave = function() {
          // Create WAVE header
          var headerLen = 44;
          var l1 = headerLen + mNumWords * 2 - 8;
          var l2 = l1 - 36;
          var wave = new Uint8Array(headerLen + mNumWords * 2);
          wave.set(
              [82,73,70,70,
               l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
               87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
               68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
               l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
          );

          // Append actual wave data
          for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
              // Note: We clamp here
              var y = mMixBuf[i];
              y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
              wave[idx++] = y & 255;
              wave[idx++] = (y >> 8) & 255;
          }

          // Return the WAVE formatted typed array
          return wave;
      };

      // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
      this.getData = function(t, n) {
          var i = 2 * Math.floor(t * 44100);
          var d = new Array(n);
          for (var j = 0; j < 2*n; j += 1) {
              var k = i + j;
              d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
          }
          return d;
      };
  };

  // Song: ThirteenthCenturyVibes
  //
  // You can load this in SoundBox using the binary export, see the ".sbox"
  // file of the same name in src/assets folder.

      // This music has been exported by SoundBox. You can use it with
      // http://sb.bitsnbites.eu/player-small.js in your own product.

      // See http://sb.bitsnbites.eu/demo.html for an example of how to
      // use it in a demo.

      // This music has been exported by SoundBox. You can use it with
      // http://sb.bitsnbites.eu/player-small.js in your own product.

      // See http://sb.bitsnbites.eu/demo.html for an example of how to
      // use it in a demo.

      // Song data
      const song = {
        songData: [
          { // Instrument 0
            i: [
            1, // OSC1_WAVEFORM
            192, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            1, // OSC2_WAVEFORM
            191, // OSC2_VOL
            116, // OSC2_SEMI
            9, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            6, // ENV_ATTACK
            22, // ENV_SUSTAIN
            34, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            69, // LFO_AMT
            3, // LFO_FREQ
            1, // LFO_FX_FREQ
            1, // FX_FILTER
            23, // FX_FREQ
            167, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            77, // FX_PAN_AMT
            6, // FX_PAN_FREQ
            7, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,2,2,2,2,1,1,1,3,1,1,1,3,4,1,4,3,1,1,1,3,1,1,1,5],
            // Columns
            c: [
              {n: [125,137,125,,,,125,,130,,130,,125,,,,125,125,125,,,,125,,130,,130,,125,,,,128,,128,140,,,128,,134,,134,,,128,,,128,,128,128,,,128,,134,,134,,,128,,,132,,132,,134,,132,,125,,125,,,,130,,132,,132,,134,,132,,125,,125,,,135,130,,,,,134,,,,,,,,,,,,132,,,,134,,,,,,142,,144,,,,132],
               f: []},
              {n: [125,,125,,,,125,,130,,130,,125,,,,125,,125,,,,125,,130,,130,,125,,,,128,,128,,,,128,,134,,134,,,,,,128,,128,128,,,128,,134,,134,,,128,,,132,,132,,134,,132,,125,,125,,,,,,132,,132,,134,,132,,125,,125,,,,130,,,,,,,,,,,,,,,,,,,,,,,,,,,,,144],
               f: []},
              {n: [125,137,125,,,,125,,130,,130,,125,,,,144,,144,,142,,142,,140,,140,,137,,137,,128,,128,140,,,128,,134,,134,,,128,,,,132,,132,,130,,130,,128,,128,,125,,125,132,,132,,134,,132,,125,,125,,,,130,,,,,,,,,,,,,,,,,,,,,134,,,,,,,,,,,,132],
               f: []},
              {n: [125,137,125,,,,125,,,,130,,125,,,,125,125,125,,,,125,,130,,130,,132,,,,128,,128,140,,,,123,,,134,,,128,,,128,,128,128,,,128,,134,,134,,,130,,,132,,132,,134,,128,,128,,125,,,,130,,132,,132,,134,,132,,125,,125,,,,128,,,,,134,,,,,,130,,,,,,132,,,,134,,,,123,,125,,127,,,,123],
               f: []},
              {n: [125,,125,,,,125,,130,,,,125,,,,144,,144,,142,,142,,140,,140,,137,,137,,128,,128,140,,,128,,134,,,,,128,,,,132,,,,130,,,,128,,,,125,,,132,,132,,,,132,,125,,,,,,,,,,,,,,,,,,,,,,,,,,,134],
               f: []}
            ]
          },
          { // Instrument 1
            i: [
            3, // OSC1_WAVEFORM
            100, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            3, // OSC2_WAVEFORM
            201, // OSC2_VOL
            128, // OSC2_SEMI
            2, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            0, // ENV_ATTACK
            6, // ENV_SUSTAIN
            49, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            139, // LFO_AMT
            4, // LFO_FREQ
            1, // LFO_FX_FREQ
            3, // FX_FILTER
            30, // FX_FREQ
            184, // FX_RESONANCE
            119, // FX_DIST
            244, // FX_DRIVE
            147, // FX_PAN_AMT
            6, // FX_PAN_FREQ
            24, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [2,3,2,2,2,2,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [113,,113,,113,,113,,118,,118,,118,,118,,113,,113,,113,,113,,118,,118,,118,,118],
               f: []},
              {n: [113,,113,,113,,113,,118,,118,,118,,118,,113,,111,,113,,115,,116,,118,,120,,122],
               f: []}
            ]
          },
          { // Instrument 2
            i: [
            0, // OSC1_WAVEFORM
            0, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            128, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            125, // NOISE_VOL
            0, // ENV_ATTACK
            1, // ENV_SUSTAIN
            59, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            1, // FX_FILTER
            193, // FX_FREQ
            171, // FX_RESONANCE
            0, // FX_DIST
            29, // FX_DRIVE
            39, // FX_PAN_AMT
            3, // FX_PAN_FREQ
            88, // FX_DELAY_AMT
            3 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,,,,,4,4,4,5,4,4,4,5,,,4,5,4,4,4,5,4,4,4],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [113,,,,,,,,113,,,,,,,,113,,,,,,,,113],
               f: []},
              {n: [113,,,,,,,,113,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,113,,,,113,,,,113,,,,113,113,113],
               f: []}
            ]
          },
          { // Instrument 3
            i: [
            0, // OSC1_WAVEFORM
            160, // OSC1_VOL
            128, // OSC1_SEMI
            64, // OSC1_XENV
            0, // OSC2_WAVEFORM
            160, // OSC2_VOL
            128, // OSC2_SEMI
            0, // OSC2_DETUNE
            64, // OSC2_XENV
            210, // NOISE_VOL
            4, // ENV_ATTACK
            7, // ENV_SUSTAIN
            52, // ENV_RELEASE
            85, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            60, // LFO_AMT
            4, // LFO_FREQ
            1, // LFO_FX_FREQ
            2, // FX_FILTER
            255, // FX_FREQ
            0, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            61, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            32, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [4,4,4,5,4,5,4,4,4,5,4,4,4,5,4,4,4,5,4,4,4,5,4,4,4,5],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [,,,,113,,,,,,,,113,,,,,,,,113,,,,,,,,113],
               f: []},
              {n: [,,,,113,,,,,,,,113,,,,113,,,,113,,,,113,,,,113],
               f: []}
            ]
          },
          { // Instrument 4
            i: [
            0, // OSC1_WAVEFORM
            0, // OSC1_VOL
            140, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            140, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            81, // NOISE_VOL
            4, // ENV_ATTACK
            10, // ENV_SUSTAIN
            47, // ENV_RELEASE
            55, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            187, // LFO_AMT
            5, // LFO_FREQ
            0, // LFO_FX_FREQ
            1, // FX_FILTER
            239, // FX_FREQ
            135, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            108, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            16, // FX_DELAY_AMT
            4 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,4,4,5,4,5,4,4,4,5,4,4,4,5,,,4,5,4,4,4,5,4,4,4],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [,113,113,,,113,,,,113,113,,,113,,,,113,113,,,113,,,,113,113,,,113],
               f: []},
              {n: [,113,113,,,113,,,,113,113,,,113,,,113,,113,,113,,113,,113,,113,,113,,113,,,,,,,,,,,,,,,,,,,,,,,,,,,113,,,,113],
               f: []}
            ]
          },
        ],
        rowLen: 5513,   // In sample lengths
        patternLen: 32,  // Rows per pattern
        endPattern: 25,  // End pattern
        numChannels: 5  // Number of channels
      };

  // Audio


  const Audio = {
      init() {
          Audio.contextCreated = false;
          Audio.readyToPlay = false;
          Audio.musicEnabled = true;
          Audio.sfxEnabled = true;
          Audio.musicVolume = 0;
          Audio.sfxVolume = 0;

          Audio.levelStart = [5.02,,7,,,.18,,.37,,25,124,.03,.03,,,,.13,.35,.01]; // Random 807

          Audio.playerJump = [,,315,,.08,.07,,.77,-16,,,,,,,,,.91,.01];
          Audio.playerLand = [1.33,,423,.01,,.06,2,2.64,-3.8,,,,,.1,,.2,,.54,.01]; // Hit 491
          Audio.playerDeath = [1.11,,779,.01,.2,.48,4,4.56,.4,,,,.02,.9,,1,,.34,.13]; // Explosion 566
          Audio.playerSlam = [2.05,,374,.01,.05,.02,2,.59,-8.2,,,,,,,.5,.29,.65,.09]; // Shoot 673

          Audio.littleJump = [1.01,,491,,.01,.05,,1.02,25,,,,,,,.1,,.45,.08]; // Jump 438
          Audio.littleEscape = [,,433,.01,.18,.24,,.51,,,418,,.06,.1,,,,.43,.25,.11]; // Powerup 426

          Audio.enemyDeath = [1.81,,135,.01,.04,.18,1,.11,-6.6,,,,,.2,,.3,.15,.74,.09]; // Hit 569
      },

      initContext() {
          if (Audio.contextCreated) return;

          // In Safari, ensure our target AudioContext is created inside a
          // click or tap event (this ensures we don't interact with it until
          // after user input).
          //
          // Chrome and Firefox are more relaxed, but this approach works for all 3.
          ZZFX.x = Audio.ctx = new AudioContext();
          Audio.gain_ = Audio.ctx.createGain();
          Audio.gain_.connect(Audio.ctx.destination);
          ZZFX.destination = Audio.gain_;

          Audio.contextCreated = true;
      },

      initTracks() {
          // In this game, we ensure the screen that calls this function happens after the
          // user has interacted at least once (and that interaction called initContext above),
          // so we know it's safe to interact with the audio context.
          if (!Audio.musicPlaying) {
              this.player = new CPlayer();
              this.player.init(song);

              for (;;) {
                  if (this.player.generate() === 1) break;
              }

              this.musicGainNodes = [];
              this.songSources = [];

              for (let i = 0; i < song.numChannels; i++) {
                  let buffer = this.player.createAudioBuffer(Audio.ctx, i);
                  this.songSource = Audio.ctx.createBufferSource();

                  let gainNode = Audio.ctx.createGain();
                  gainNode.connect(Audio.gain_);
                  this.musicGainNodes.push(gainNode);

                  /*if (i === TRACK_COMBAT || i === TRACK_WAVE) {
                      gainNode.gain.value = 0;
                  }*/

                  this.songSource.buffer = buffer;
                  this.songSource.loop = true;
                  this.songSource.connect(gainNode);
                  this.songSources.push(this.songSource);
              }

              this.musicStartTime = Audio.ctx.currentTime + 0.1;

              for (let i = 0; i < song.numChannels; i++) {
                  this.songSources[i].start(this.musicStartTime);
                  // comment out music
              }

              Audio.musicPlaying = true;
          }

          Audio.readyToPlay = true;
      },

      update() {
          if (!Audio.readyToPlay) return;

          this.sfxVolume = this.sfxEnabled ? 0.3 : 0;
          this.musicVolume = this.musicEnabled ? 1 : 0;

          ZZFX.volume = this.sfxVolume;

          if (this.sfxEnabled) {
              ZZFX.volume = 0.3;
          } else {
              ZZFX.volume = 0;
          }
      },

      play(sound) {
          if (!Audio.readyToPlay) return;
          ZZFX.play(...sound);
      },

      // It's important we do pausing and unpausing as specific events and not in general update(),
      // because update() is triggered by the animation frame trigger which does not run if the
      // page is not visible. (So, if you want the music to fade in the background, for example,
      // that's not helpful if it won't work because you aren't looking at the page!)

      pause() {
          if (Audio.readyToPlay) {
              Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);
          }
      },

      unpause() {
          if (Audio.readyToPlay) {
              Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);
          }
      }
  };

  // Camera
  //
  // Left here only because it is embedded in other utility classes and
  // it is easier to neutralize it than delete it.

  const Camera = {
      init() {
          this.pos = { x: 0, y: 0 };
      },
      update() { }
  };

  // Constants

  // The game's desired dimensions in pixels - the actual dimensions can be adjusted
  // slightly by the Viewport module.
  const TARGET_GAME_WIDTH = 320;
  const TARGET_GAME_HEIGHT = 180;

  // Shortcuts for marker locations on screen
  const INVENTORY_WOOD_POS = { u: 250, v: 131 };
  const INVENTORY_MEAT_POS = { u: 250, v: 143 };
  const INVENTORY_TORCH_POS = { u: 250, v: 155 };
  const INVENTORY_STONE_POS = { u: 250, v: 167 };
  const SANITY_POS = { u: 284, v: 9 };

  // Number of "facing left" villager frames (doubled for facing right)
  const VILLAGER_FRAMES = 12;

  // Frames per second (locked)
  //
  // Other constants below, like gravity, foot speed, etc., are represented as movement PER FRAME.
  const FPS = 42;

  // Viewport


  /**
   * Viewport
   *
   * Represents the game display (for us, a canvas).
   */
  const Viewport = {
      init() {
          Viewport.canvas = document.getElementById('canvas');
          Viewport.ctx = Viewport.canvas.getContext('2d');
          Viewport.resize(true);
      },

      // Resize the canvas to give us approximately our desired game display size.
      //
      // Rather than attempt to explain it, here's a concrete example:
      //
      //     we start with a desired game dimension:   480x270px
      //          get the actual browser dimensions:  1309x468px
      //          factor in the display's DPR ratio:  2618x936px
      //         now calculate the horizontal scale:       5.45x
      //                     and the vertical scale:       3.46x
      //            our new offical game scaling is:        5.4x
      //       and our official viewport dimensions:   484x173px
      //
      // This approach emphasizes correct aspect ratio and maintains full-window rendering, at
      // the potential cost of limiting visibility of the game itself in either the X or Y axis.
      // If you use this approach, make sure your GUI can "float" (otherwise there may be whole
      // UI elements the player cannot see!).
      resize(force) {
          let dpr = window.devicePixelRatio,
              width = Viewport.canvas.clientWidth,
              height = Viewport.canvas.clientHeight,
              dprWidth = width * dpr,
              dprHeight = height * dpr;

          if (
              force ||
              Viewport.canvas.width !== dprWidth ||
              Viewport.canvas.height !== dprHeight
          ) {
              Viewport.canvas.width = dprWidth;
              Viewport.canvas.height = dprHeight;

              Viewport.scale = ((Math.min(dprWidth / TARGET_GAME_WIDTH, dprHeight / TARGET_GAME_HEIGHT) * 10) | 0) / 10;
              Viewport.width = Math.ceil(dprWidth / Viewport.scale);
              Viewport.height = Math.ceil(dprHeight / Viewport.scale);
              Viewport.center = {
                  u: (Viewport.width / 2) | 0,
                  v: (Viewport.height / 2) | 0
              };
              Viewport.clientWidth = width;
              Viewport.clientHeight = height;

              // Note: smoothing flag gets reset on every resize by some browsers, which is why
              // we do it here.
              Viewport.ctx.imageSmoothingEnabled = false;
          }

          // We do this every frame, not just on resize, due to browser sometimes "forgetting".
          Viewport.canvas.style.cursor = 'none';
      },

      fillViewportRect() {
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
      },

      isOnScreen(uv) {
          return uv.u >= 0 && uv.v >= 0 && uv.u < Viewport.width && uv.v < Viewport.height;
      }
  };

  function angle2vector(r, m) {
      return { x: Math.cos(r), y: Math.sin(r), m: m || 1 };
  }

  function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
  }

  function rgba(r, g, b, a) {
      return `rgba(${r},${g},${b},${a})`;
  }

  function createCanvas(width, height) {
      let canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      let ctx = canvas.getContext('2d');
      return { canvas, ctx };
  }

  // SpriteSheet

  /**
   * This module is generated by `gulp buildAssets`.
   */
  const SpriteSheet =
      /* <generated> */
  { altar: [ [ 0, 0, 19, 29 ], [ 19, 0, 19, 29 ] ],
    bigarrows: [ [ 0, 29, 15, 8 ] ],
    blackcat: [ [ 0, 37, 24, 36 ], [ 24, 37, 24, 36 ] ],
    bridge: [ [ 0, 73, 31, 16 ], [ 31, 73, 31, 16 ] ],
    button: [ [ 0, 89, 9, 9 ], [ 9, 89, 9, 9 ], [ 18, 89, 9, 9 ] ],
    factory: [ [ 0, 98, 20, 14 ], [ 20, 98, 20, 14 ] ],
    font4: [ [ 0, 112, 270, 12 ] ],
    icons: [ [ 0, 124, 8, 8 ], [ 8, 124, 8, 8 ], [ 16, 124, 8, 8 ], [ 24, 124, 8, 8 ] ],
    influencebar: [ [ 0, 132, 93, 10 ], [ 93, 132, 93, 10 ] ],
    jobselect: [ [ 0, 142, 120, 14 ], [ 120, 142, 120, 14 ] ],
    keys: [ [ 0, 156, 18, 9 ], [ 18, 156, 18, 9 ], [ 36, 156, 18, 9 ] ],
    particle:
     [ [ 0, 165, 1, 1 ],
       [ 1, 165, 1, 1 ],
       [ 2, 165, 1, 1 ],
       [ 3, 165, 1, 1 ],
       [ 4, 165, 1, 1 ] ],
    sanitybar: [ [ 0, 166, 18, 82 ], [ 18, 166, 18, 82 ], [ 36, 166, 18, 82 ] ],
    smallarrows: [ [ 0, 248, 3, 5 ], [ 3, 248, 3, 5 ], [ 6, 248, 3, 5 ], [ 9, 248, 3, 5 ] ],
    villager:
     [ [ 0, 253, 22, 30 ],
       [ 22, 253, 22, 30 ],
       [ 44, 253, 22, 30 ],
       [ 66, 253, 22, 30 ],
       [ 88, 253, 22, 30 ],
       [ 110, 253, 22, 30 ],
       [ 132, 253, 22, 30 ],
       [ 154, 253, 22, 30 ],
       [ 176, 253, 22, 30 ],
       [ 198, 253, 22, 30 ],
       [ 220, 253, 22, 30 ],
       [ 242, 253, 22, 30 ] ],
    villagerchunk:
     [ [ 0, 283, 9, 9 ],
       [ 9, 283, 9, 9 ],
       [ 18, 283, 9, 9 ],
       [ 27, 283, 9, 9 ],
       [ 36, 283, 9, 9 ],
       [ 45, 283, 9, 9 ] ],
    villagerdeath: [ [ 0, 292, 13, 22 ] ],
    wink: [ [ 0, 314, 3, 5 ], [ 3, 314, 3, 5 ], [ 6, 314, 3, 5 ], [ 9, 314, 3, 5 ] ],
    'terrain-FG1': [ [ 0, 319, 320, 180 ] ],
    'terrain-FG2': [ [ 0, 499, 320, 180 ] ],
    'terrain-FG3': [ [ 0, 679, 320, 180 ] ],
    base64:
     'data:image/png;base64,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' };
  /* </generated> */

  /**
   * Sprite
   *
   * Encapsulates loading sprite slices from the spritesheet, organizing them, and
   * modifying them or constructing using primitives. To save space, we use some techniques
   * like storing only a small slice of an image in the spritesheet, then using code
   * to duplicate it, add some randomness, etc.
   */
  const Sprite = {
      // This is an exception to the rule, loading the spritesheet is a special action that
      // happens BEFORE everything is initialized.
      loadSpritesheet(cb) {
          let image = new Image();
          image.onload = cb;
          image.src = SpriteSheet.base64;
          Sprite.sheet = image;
      },

      init() {
          const defaultOpts = { anchor: { x: 0, y: 0 } };

          Sprite.blackcat = initBasicSpriteArray(SpriteSheet.blackcat, defaultOpts);
          Sprite.button = initBasicSpriteArray(SpriteSheet.button, defaultOpts);
          Sprite.sanitybar = initBasicSpriteArray(SpriteSheet.sanitybar, defaultOpts);
          Sprite.influencebar = initBasicSpriteArray(SpriteSheet.influencebar, defaultOpts);
          Sprite.smallarrows = initBasicSpriteArray(SpriteSheet.smallarrows, defaultOpts);
          Sprite.jobselect = initBasicSpriteArray(SpriteSheet.jobselect, defaultOpts);
          Sprite.bridge = initBasicSpriteArray(SpriteSheet.bridge, defaultOpts);
          Sprite.bigarrows = initBasicSpriteArray(SpriteSheet.bigarrows, defaultOpts);
          Sprite.icons = initBasicSpriteArray(SpriteSheet.icons, defaultOpts);
          Sprite.factory = initBasicSpriteArray(SpriteSheet.factory, defaultOpts);
          Sprite.altar = initBasicSpriteArray(SpriteSheet.altar, { anchor: { x: 9, y: 28 } });
          Sprite.wink = initBasicSpriteArray(SpriteSheet.wink, defaultOpts);
          Sprite.terrain = [
              initBasicSprite(SpriteSheet['terrain-FG1'][0]),
              initBasicSprite(SpriteSheet['terrain-FG2'][0]),
              initBasicSprite(SpriteSheet['terrain-FG3'][0])
          ];
          Sprite.keys = initBasicSpriteArray(SpriteSheet.keys, defaultOpts);

          //Sprite.terrain[1].img = augmentTerrain(Sprite.terrain[1].img, 30, '#04373b');
          //Sprite.terrain[2].img = augmentTerrain(Sprite.terrain[2].img, 49, '#1a644e');

          // Villager
          Sprite.villager = initBasicSpriteArray(SpriteSheet.villager, { anchor: { x: 16, y: 29 } });
          const villagerFrames = Sprite.villager.length;
          for (let i = 0; i < villagerFrames; i++) {
              Sprite.villager[i + villagerFrames] = initDynamicSprite(flipHorizontal(Sprite.villager[i].img), { anchor: { x: 5, y: 29 } });
          }
          Sprite.villagerdeath = initBasicSpriteArray(SpriteSheet.villagerdeath, { anchor: { x: 6, y: 21 } });
          Sprite.villagerchunk = initBasicSpriteArray(SpriteSheet.villagerchunk, { anchor: { x: 4, y: 4 } });

          Sprite.particle = SpriteSheet.particle.map(initBasicSprite);

          // Base pixel font and icons (see `Text.init` for additional variations)
          Sprite.font = initBasicSprite(SpriteSheet.font4[0]);
      },

      /**
       * A small helper that draws a sprite onto a canvas, respecting the anchor point of
       * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if
       * that's appropriate!
       */
      drawSprite(ctx, sprite, u, v) {
          ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);
      },

      drawViewportSprite(sprite, pos, rotation) {
          let { u, v } = this.viewportSprite2uv(
              sprite,
              pos
          );
          if (rotation) {
              Viewport.ctx.save();
              Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);
              Viewport.ctx.rotate(rotation);
              Viewport.ctx.drawImage(
                  sprite.img,
                  -sprite.anchor.x,
                  -sprite.anchor.y
              );
              Viewport.ctx.restore();
          } else {
              Viewport.ctx.drawImage(sprite.img, u, v);
          }
      },

      drawSmashedSprite(sprite, pos, height) {
          let { u, v } = this.viewportSprite2uv(
              sprite,
              pos
          );

          Viewport.ctx.drawImage(sprite.img, u - 1, v - height + sprite.img.height, sprite.img.width + 2, height);
      },

      viewportSprite2uv(sprite, pos) {
          // HACK TODO
          if (pos.u) {
              return {
                  u: pos.u - sprite.anchor.x,
                  v: pos.v - sprite.anchor.y
              };
          }

          return {
              u: pos.x - sprite.anchor.x - Camera.pos.x + Viewport.center.u,
              v: pos.y - sprite.anchor.y - Camera.pos.y + Viewport.center.v
          };
      }
  };

  // Sprite utility functions

  function initBasicSpriteArray(data, opts) {
      return data.map(element => initBasicSprite(element, opts));
  }

  function initBasicSprite(data, opts) {
      return initDynamicSprite(loadCacheSlice(...data), opts);
  }

  function initDynamicSprite(source, opts) {
      let w = source.width,
          h = source.height;

      if (typeof opts !== 'object') {
          opts = {};
      }

      if (!opts.anchor) {
          opts.anchor = { x: (w / 2) | 0, y: (h / 2) | 0 };
      }

      if (!opts.bb) {
          opts.bb = [-opts.anchor.x, -opts.anchor.y, source.width, source.height];
      }

      return {
          img: source,
          ...opts
      };
  }

  function loadCacheSlice(x, y, w, h) {
      const source = Sprite.sheet;
      const sliceCanvas = createCanvas(w, h);
      sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);
      return sliceCanvas.canvas;
  }

  function flipHorizontal(source) {
      let canvas = createCanvas(source.width, source.height);
      canvas.ctx.translate(source.width, 0);
      canvas.ctx.scale(-1, 1);
      canvas.ctx.drawImage(source, 0, 0);
      return canvas.canvas;
  }

  /*function augmentTerrain(source, lines, color) {
      let w = source.width, h = source.height;
      let canvas = createCanvas(source.width, source.height);
      canvas.ctx.drawImage(source, 0, 0, w, h, 0, 0, w, h);
      canvas.ctx.fillStyle = color;
      canvas.ctx.fillRect(0, h - lines, w, lines);
      return canvas.canvas;
  }
  */

  // Text


  const C_WIDTH = 5;
  const C_HEIGHT = 5;
  const FONT_SHEET_C_WIDTH = 6;
  const FONT_SHEET_WIDTH = 270;
  const DEFAULT_C_SHIFT = 5;

  // Very simple variable-width font implementation. The characters in the font strip
  // are left-aligned in their 5x5 pixel boxes, so in order to have variable width,
  // we just need to note the characters that AREN'T full width. Anything not in
  // this list has full shift (5+1 = 6 pixels).
  const C_SHIFT = {
      10: 0, // LF (\n)
      32: 3, // Space ( )
      33: 3, // Bang (!)
      39: 2, // Apostrophe (')
      40: 3, // Open Paren (
      41: 3, // Close Paren )
      44: 3, // Comma (,)
      46: 3, // Period (.)
      47: 6, // Slash (/)
      73: 2, // I
      77: 6, // M
      84: 6, // T
      86: 6, // V
      87: 6, // W
      88: 6, // X
      89: 6, // Y
      91: 4, // [ (s)
      109: 6, // m (up)
      111: 6, // o (down),
      1108: 10, // left arrow key
      1114: 10, // right arrow key
      1101: 19 // escape key
  };

  const C_ICONS = {
  };

  const Text = {
      init() {
          Text.white = Sprite.font.img;
          Text.black = recolor(Text.white, rgba(0, 0, 0, 1));
          Text.shadow = recolor(Text.white, rgba(44, 27, 46, 1));

          //Text.tan = recolor(Text.white, rgba(209, 180, 140, 1));
          //Text.pig = recolor(Text.white, rgba(227, 66, 98, 1));
          //Text.duotone = recolorDuotone(Text.white, '#f2b63d', '#fff4e0');
          //Text.duotone_red = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3', rgba(255, 0, 0, 0.7));

          Text.palette = [
              recolor(Text.white, '#0a1a2f'),
              recolor(Text.white, '#04373b'),
              recolor(Text.white, '#1a644c'),
              recolor(Text.white, '#40985c'),
              recolor(Text.white, '#d1cb95')
          ];

          C_ICONS[1108] = Sprite.keys[0];
          C_ICONS[1114] = Sprite.keys[1];
          C_ICONS[1101] = Sprite.keys[2];
      },

      drawText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {
          for (let c of this.charactersToDraw(text, scale)) {
              if (C_ICONS[c.c]) {
                  ctx.drawImage(
                      C_ICONS[c.c].img,
                      u + c.u,
                      v + c.v - Math.floor((C_ICONS[c.c].img.height) / 2) + 2
                  );
              } else {
                  let k = (c.c - 32) * FONT_SHEET_C_WIDTH;
                  if (shadow) {
                      ctx.drawImage(
                          shadow,
                          k % FONT_SHEET_WIDTH,
                          (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                          C_WIDTH,
                          C_HEIGHT,
                          u + c.u,
                          v + c.v + 1,
                          C_WIDTH * scale,
                          C_HEIGHT * scale
                      );
                  }
                  ctx.drawImage(
                      font,
                      k % FONT_SHEET_WIDTH,
                      (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                      C_WIDTH,
                      C_HEIGHT,
                      u + c.u,
                      v + c.v,
                      C_WIDTH * scale,
                      C_HEIGHT * scale
                  );
              }
          }
      },

      drawParagraph(ctx, text, u, v, width, scale = 1, font = Text.white, shadow) {
          const lines = this.breakParagraph(text, width, scale);

          for (let i = 0; i < lines.length; i++) {
              this.drawText(ctx, lines[i], u, v + i * (C_HEIGHT + 2) * scale, scale, font, shadow);
          }
      },

      breakParagraph(text, width, scale = 1) {
          const lines = [];
          let line = '';
          const words = text.split(' ');
          while (words.length > 0) {
              const lineWidth = this.measure(line + ' ' + words[0], scale).w;
              if (lineWidth > width) {
                  lines.push(line);
                  line = '';
              }
              line = line + ' ' + words.shift();
          }
          if (line.length > 0) {
              lines.push(line);
          }
          return lines;
      },

      measure(text, scale = 1) {
          let w = 0, h = 0;

          for (let c of this.charactersToDraw(text, scale)) {
              w = Math.max(w, c.u + (C_SHIFT[c.c] || DEFAULT_C_SHIFT) * scale);
              h = c.v + (C_HEIGHT + 2) * scale;
          }

          return { w, h };
      },

      *charactersToDraw(text, scale = 1) {
          let u = 0, v = 0;

          for (let idx = 0; idx < text.length; idx++) {
              let c = text.charCodeAt(idx);

              if (c === 10) {
                  // Newline
                  u = 0;
                  v += (C_HEIGHT + 2) * scale;
                  continue;
              }

              if (c === 92) {
                  // Backslash
                  idx++;
                  c = 1000 + text.charCodeAt(idx);
              }

              yield { c, u, v };

              u += (C_SHIFT[c] || DEFAULT_C_SHIFT) * scale;
          }
      }
  };

  // Text utility functions

  function recolor(font, color) {
      let canvas = createCanvas(font.width, font.height);
      canvas.ctx.fillStyle = color;
      canvas.ctx.fillRect(0, 0, font.width, font.height);
      canvas.ctx.globalCompositeOperation = 'destination-in';
      canvas.ctx.drawImage(font, 0, 0);
      return canvas.canvas;
  }

  // LoadingScene


  class LoadingScene {
      constructor() {
          this.text = [
              'HAROLD',
              'IS',
              'HEAVY'
          ];
          this.t = -12;
      }

      update() {
          this.t++;

          if (this.t === 36) ;

          if (this.t > 15) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = '#2c1b2e';
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          Viewport.ctx.fillStyle = '#457cd6';
          Viewport.ctx.fillRect(Viewport.width / 2 - 65, Viewport.height / 2 - 8, 130, 16);
          Viewport.ctx.fillRect(Viewport.width / 2 - 64, Viewport.height / 2 - 9, 128, 18);

          let total = 10;
          clamp(this.t / 6, 0, 10);

          for (let i = 0; i < total; i++) {
              Math.sin(i * Math.PI * 2 / 9 + (this.t * Math.PI * 2 / 60)) * 3;
              //Viewport.ctx.drawImage(Sprite.littlepig[0][frame].img, i * 12 + (Viewport.width - 120) / 2, Viewport.height / 2 - 3 + y);
          }

          this.drawInstructions();
      }

      drawInstructions() {
          let text = 'LOADING...';
          let width = Text.measure(text, 1).w;

          if (this.t % 30 < 24) {
              Text.drawText(Viewport.ctx, text, (Viewport.width - width) / 2, Viewport.height / 20 + 25, Text.duotone, Text.shadow);
          }
      }
  }

  // KeyboardAdapter


  const KeyboardAdapter = {
      init() {
          KeyboardAdapter.map = {
              KeyW:        Input.Action.UP,
              //KeyA:        Input.Action.LEFT,
              //KeyS:        Input.Action.DOWN,
              KeyD:        Input.Action.RIGHT,
              KeyV:        Input.Action.RECRUIT_VILLAGER,
              KeyB:        Input.Action.BUILD_BRIDGE,
              KeyT:        Input.Action.BUILD_HALL,
              KeyA:        Input.Action.BUILD_ALTAR,
              KeyS:        Input.Action.SACRIFICE,
              KeyH:        Input.Action.HELP,
              Space:       Input.Action.JUMP,
              Enter:       Input.Action.CONTINUE,
              ArrowUp:     Input.Action.UP,
              ArrowLeft:   Input.Action.LEFT,
              ArrowDown:   Input.Action.DOWN,
              ArrowRight:  Input.Action.RIGHT,
              Escape:      Input.Action.MENU
          };

          KeyboardAdapter.held = [];

          window.addEventListener('keydown', event => {
              let k = KeyboardAdapter.map[event.code];
              // Uncomment to debug key presses
              // console.log(event.key, event.keyCode, event.code, k);

              // Hack to ensure we initialize audio after user interacts with game
              Audio.initContext();

              if (k) {
                  KeyboardAdapter.held[k] = true;
              }
          });

          window.addEventListener('keyup', event => {
              let k = KeyboardAdapter.map[event.code];
              if (k) {
                  KeyboardAdapter.held[k] = false;
              }

              if (event.key >= '1' && event.key <= '9') {
                  game.nextLevel = Number(event.key) - 1;
                  game.screens.pop();
              }
          });

          KeyboardAdapter.reset();
      },

      update() {
          // For keyboards, we want to convert the state of the various arrow keys being held down
          // into a directional vector. We use the browser's event to handle the held state of
          // the other action buttons, so we don't need to process them here.
          (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +
              (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +
              (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +
              (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);

          //KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];
      },

      reset() {
          //KeyboardAdapter.direction = 0;
          for (let action of Object.values(Input.Action)) {
              KeyboardAdapter.held[action] = false;
          }
      }
  };

  // Input


  const Input = {
      // Game Inputs
      //
      // Note that moving the player around is actually not considered an action; it's
      // a separate non-action input called "direction". It just so happens that on
      // keyboard, for example, pressing the "down arrow" key is considered both a
      // press of the in-game DOWN action and a directional input. It's up to the input
      // consumer to decide which input is relevant (if any). For example, on a menu,
      // we may consume the DOWN/UP actions to navigate the menu, but ignore directional
      // inputs.
      //
      Action: {
          UP: 11,
          DOWN: 12,
          LEFT: 13,
          RIGHT: 14,
          RECRUIT_VILLAGER: 101,
          BUILD_BRIDGE: 102,
          BUILD_HALL: 103,
          BUILD_ALTAR: 104,
          SACRIFICE: 105,
          HELP: 106,
          JUMP: 22,
          ATTACK: 21,
          RELOAD: 30,
          CONTINUE: 95,
          MENU: 96,
          MUSIC_TOGGLE: 97,
          SFX_TOGGLE: 98,
          RAW_TOUCH: 40,
          DRAG: 41,
          TAP: 42
      },

      init() {
          // A vector representing the direction the user is pressing/facing,
          // separate from pressing and releasing inputs. Treating "direction"
          // separately makes it easier to handle gamepad sticks.
          this.direction = { x: 0, y: 0, m: 0 };

          // "Pressed" means an input was pressed THIS FRAME.
          this.pressed = {};

          // "Released" means an input was released THIS FRAME.
          this.released = {};

          // "Held" means an input is held down. The input was "Pressed" either
          // this frame or in a past frame, and has not been "Released" yet.
          this.held = {};

          // How many frames was this input held down by the player. If [held]
          // is false, it represents how long the input was last held down.
          this.framesHeld = {};

          KeyboardAdapter.init();
      },

      update() {
          // We could have some kind of "input adapter toggle", but it's easier to just treat all inputs
          // as valid -- if you're pressing the "attack" button on either gamepad or keyboard, then you're
          // attacking. For directional input, we instead check whether there's movement on the thumbstick,
          // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.

          KeyboardAdapter.update();

          for (let action of Object.values(Input.Action)) {
              let held = KeyboardAdapter.held[action];
              this.pressed[action] = !this.held[action] && held;
              this.released[action] = this.held[action] && !held;

              if (this.pressed[action]) {
                  this.framesHeld[action] = 1;
              } else if (this.held[action] && held) {
                  this.framesHeld[action]++;
              }

              this.held[action] = held;
          }

          //this.pointer = pointerAdapter.pointer;
          //this.direction = KeyboardAdapter.direction;
          //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;
      },

      onDown(action) {},
      onUp(action) {},
  };

  // IntroScene


  class IntroScene {
      constructor() {
          this.text = [
              'HAROLD',
              'IS',
              'HEAVY'
          ];
          this.pos = [
              { y: -20 },
              { y: -20 },
              { y: -20 }
          ];
          this.vel = [
              { y: 0 },
              { y: 0 },
              { y: 0 }
          ];
          this.screenshakes = [];
          this.t = 0;
          this.fadet = -1;
      }

      update() {
          this.t++;

          if (this.t > 10) {
              game.scenes.pop();
              game.scenes.push(new LoadingScene());
          }
      }

      draw() {
          Viewport.ctx.fillStyle = '#457cd6';
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          let shakeX = 0, shakeY = 0;
          for (let i = 0; i < 3; i++) {
              if (this.screenshakes[i]) {
                  shakeX += this.screenshakes[i].x;
                  shakeY += this.screenshakes[i].y;
              }
          }
          Viewport.ctx.translate(shakeX, shakeY);

          for (let i = this.text.length - 1; i >= 0; i--) {
              let width = Text.measure(this.text[i], 2).w;

              //Viewport.ctx.globalAlpha = 0.3;
              //Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 50 + i * 15 - 4, 2, Text.pig);

              Viewport.ctx.globalAlpha = 1;
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, this.pos[i].y - 1, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, this.pos[i].y + 1, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2 - 1, this.pos[i].y, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2 + 1, this.pos[i].y, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, this.pos[i].y, 2, Text.pig);
          }

          if (this.pos[2].y > 50) {
              this.drawInstructions();
          }

          // Fade to load screen
          if (this.fadet >= 0) {
              let fade = 0;
              if (this.fadet > 8) {
                  fade = (this.fadet - 8) * (Viewport.width / 2 - 40) / 20;
              }

              Viewport.ctx.fillStyle = '#2c1b2e';
              Viewport.ctx.beginPath();
              Viewport.ctx.moveTo(Viewport.width / 2 - 0 - fade, 0);
              Viewport.ctx.lineTo(Viewport.width / 2 + 40 + fade, 0);
              Viewport.ctx.lineTo(Viewport.width / 2 + 0 + fade, Viewport.height);
              Viewport.ctx.lineTo(Viewport.width / 2 - 40 - fade, Viewport.height);
              Viewport.ctx.closePath();
              Viewport.ctx.fill();
          }
      }

      drawInstructions() {
          let text = 'PRESS SPACE OR ENTER TO START';
          let width = Text.measure(text, 1).w;

          if (this.t % 30 < 24) {
              Text.drawText(Viewport.ctx, text, (Viewport.width - width) / 2, Viewport.height - 10, 1, Text.white, Text.shadow);
          }
      }
  }

  // Particle


  class VillagerChunkParticle {
      constructor(pos) {
          this.t = -1;
          this.d = 30;

          this.angle = Math.random() * Math.PI + Math.PI;
          this.vector = angle2vector(this.angle);
          this.m = 50 + Math.random() * 25;
          this.a = Math.random() * Math.PI * 2;
          this.ad = 0.1;

          this.pos = { u: pos.u, v: pos.v - 12 };
          this.pos.u += this.vector.x * 3;
          this.pos.v += this.vector.y * 3;

          this.frame = Math.floor(Math.random() * 6);
      }

      update() {
          if (++this.t === this.d) {
              this.cull = true;
          }

          this.pos.u += (this.m / this.d) * this.vector.x;
          this.pos.v += (this.m / this.d) * this.vector.y;
          this.vector.x *= 0.95;
          this.vector.y *= 0.95;
          this.vector.y += 0.05;

          this.a += this.ad;
      }

      draw() {
          Sprite.drawViewportSprite(Sprite.villagerchunk[this.frame], this.pos, this.a);
      }
  }

  // SacrificeParticle


  class SacrificeParticle {
      constructor(villager) {
          this.t = -1;
          this.d = 30;
          this.winkframe = 3;
          this.villager = villager;
      }

      update() {
          if (++this.t === this.d) {
              game.gameScene.grantSanity(10);
              this.cull = true;
          }

          if (this.t === 2) {
              this.winkframe = 0;
          } else if (this.t === 6) {
              this.winkframe = 1;
          } else if (this.t === 8) {
              this.winkframe = 2;
          } else if (this.t === 10) {
              this.winkframe = 3;
          } else if (this.t === 14) {
              this.winkframe = -1;
          }

          if (this.t >= 24 && this.t <= 27) {
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
          }

          this.villager.pos.v -= 0.2;
      }

      draw() {
          let v = Math.floor(this.villager.pos.v);

          if (this.t >= 0 && this.t < 15) {
              let shake = (this.t % 3) - 1;
              Sprite.drawViewportSprite(Sprite.villager[0], { u: this.villager.pos.u + shake, v: v });
          } else if (this.t >= 15 && this.t <= 25) {
              Sprite.drawViewportSprite(Sprite.villagerdeath[0], { u: this.villager.pos.u, v: v });
          }

          if (this.winkframe >= 0) {
              Viewport.ctx.drawImage(Sprite.wink[this.winkframe].img, 160 + 11 - 1, 73 - 30 + 9 - 2);
          }
      }
  }

  // Button


  class Button {
      constructor(u, v, hotkey, text) {
          this.u = u;
          this.v = v;
          this.hotkey = hotkey;
          this.text = text;
          this.visible = false;
          this.active = false;
      }

      update() {
          if (!this.visible) return;
      }

      draw() {
          if (!this.visible) return;

          const frame = this.active ? 0 : 2;
          const colorIndex = this.active ? 4 : 2;
          const bgColorIndex = this.active ? 0 : 2;
          Viewport.ctx.drawImage(Sprite.button[frame].img, this.u, this.v);
          Text.drawText(Viewport.ctx, this.hotkey, this.u + 2, this.v + 2, 1, Text.palette[bgColorIndex]);
          Text.drawText(Viewport.ctx, this.text.toUpperCase(), this.u + 11, this.v + 2, 1, Text.palette[colorIndex]);
      }
  }

  // TweenChain

  class TweenChain {
      constructor(tweenArray) {
          this.t = -1;
          this.tweenArray = tweenArray;
      }

      update() {
          this.t++;

          if (this.t < this.tweenArray[0].t1) {
              this.value = this.tweenArray[0].v1;
              this.facing = (this.tweenArray[0].v2 - this.tweenArray[0].v1 >= 0 ? 1 : 0);
              return;
          }

          if (this.t >= this.tweenArray[this.tweenArray.length - 1].t2) {
              this.value = this.tweenArray[this.tweenArray.length - 1].v2;
              this.facing = (this.tweenArray[this.tweenArray.length - 1].v2 - this.tweenArray[this.tweenArray.length - 1].v1 >= 0 ? 1 : 0);
              this.finished = true;
              return;
          }

          for (let i = 0; i < this.tweenArray.length; i++) {
              if (this.t >= this.tweenArray[i].t1 && this.t < this.tweenArray[i].t2) {
                  // A tween chain can have an "undefined" start value, which means
                  // just inherit the last value of the previous tween.
                  if (this.tweenArray[i].v1 === undefined) {
                      this.tweenArray[i].v1 = this.tweenArray[i - 1].v2;
                  }

                  // Apply stagger on the fly; this allows for randomization of the DESTINATION
                  // (we assume the start point does not move).
                  if (this.tweenArray[i].stagger) {
                      this.tweenArray[i].v2 += Math.floor(Math.random() * this.tweenArray[i].stagger - this.tweenArray[i].stagger / 2);
                      this.tweenArray[i].stagger = undefined;
                  }

                  this.value = (this.tweenArray[i].v2 - this.tweenArray[i].v1)
                      * (this.t - this.tweenArray[i].t1)
                      / (this.tweenArray[i].t2 - this.tweenArray[i].t1)
                      + this.tweenArray[i].v1;

                  // For every frame, we provide a utility "facing" value: 1 if the current
                  // movement trends RIGHT, 0 if the current movement trends LEFT.
                  this.facing = (this.tweenArray[i].v2 - this.tweenArray[i].v1 >= 0 ? 1 : 0);
                  break;
              }
          }
      }
  }

  // HeightMapData
  //
  // This file is generated by `gulp buildAssets`.

  const HeightMapData =
  /* <generated-data> */
  [ [],
    [],
    [ 126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      127,
      128,
      128,
      129,
      129,
      129,
      130,
      130,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      132,
      132,
      132,
      132,
      132,
      132,
      133,
      133,
      133,
      133,
      133,
      134,
      134,
      135,
      136,
      136,
      137,
      138,
      138,
      139,
      139,
      139,
      140,
      140,
      140,
      140,
      139,
      139,
      139,
      139,
      139,
      139,
      138,
      138,
      138,
      138,
      138,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      139,
      139,
      139,
      139,
      140,
      140,
      141,
      141,
      141,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      145,
      145,
      145,
      145,
      145,
      145,
      145,
      146,
      145,
      145,
      145,
      145,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143 ],
    [ 149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      148,
      148,
      148,
      148,
      148,
      148,
      147,
      147,
      147,
      146,
      146,
      146,
      145,
      145,
      144,
      144,
      144,
      143,
      143,
      142,
      141,
      141,
      141,
      140,
      140,
      140,
      139,
      139,
      139,
      139,
      139,
      138,
      138,
      138,
      138,
      138,
      138,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      136,
      136,
      136,
      135,
      135,
      135,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      135,
      135,
      135,
      136,
      136,
      136,
      137,
      137,
      137,
      137,
      137,
      137,
      138,
      138,
      138,
      138,
      139,
      139,
      139,
      139,
      140,
      140,
      140,
      140,
      141,
      141,
      141,
      141,
      142,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      145,
      145,
      146,
      145,
      145,
      145,
      145,
      145,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      145,
      146,
      146,
      147,
      147,
      148,
      148,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      148,
      148,
      149,
      149,
      149,
      149,
      150,
      150,
      150,
      150,
      151,
      151,
      152,
      152,
      152,
      153,
      153,
      153,
      154,
      154,
      154,
      154,
      154,
      154,
      153,
      153,
      153,
      153,
      152,
      152,
      152,
      152,
      151,
      151,
      151,
      151,
      151,
      151,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149 ] ]
  /* </generated-data> */
  ;

  // Villager


  const IDLE = 0;
  const WOODCUTTER = 1;
  const BUTCHER = 2;
  const TALLOWER = 3;
  const STONECUTTER = 4;
  const FIREKEEPER = 5;
  const SACRIFICE = 7;

  class IdleTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 30, v1: 0, v2: 0 }
          ]);
          this.frame = 0;
      }

      completeTask() { }
  }

  class ButcherTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: -76, stagger: 20 },
              { t1: 120, t2: 180, v1: undefined, v2: -76, stagger: 20 },
              { t1: 180, t2: 300, v1: undefined, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
          this.equipmentframe = (this.t > 60 && this.t < 210) ? 3 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.gatherMeat();
      }
  }

  class WoodcutterTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: 140, stagger: 15 },
              { t1: 120, t2: 180, v1: undefined, v2: 140, stagger: 15 },
              { t1: 180, t2: 300, v1: undefined, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 130 && this.t < 170) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
          this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.gatherWood();
      }
  }

  class TallowerTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: 47 },
              { t1: 120, t2: 180, v1: 47, v2: 47 },
              { t1: 180, t2: 300, v1: 47, v2: 0 }
          ]);
          this.layer = 2;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + 7 + facing * VILLAGER_FRAMES;
          //this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.craftTorch();
      }
  }

  class StonecutterTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: -141 },
              { t1: 120, t2: 180, v1: -141, v2: -141 },
              { t1: 180, t2: 300, v1: -141, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
          this.equipmentframe = (this.t > 60 && this.t < 210) ? 5 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.gatherStone();
      }
  }

  class SacrificeTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 1, v1: 0, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();
      }

      completeTask(villager) {
          game.gameScene.beginSacrifice(villager);
      }
  }

  class Villager {
      static JOB_NAMES = ['', 'WOODCUTTER', 'BUTCHER', 'TALLOWER', 'STONEMASON', 'FIREKEEPER', 'TOTEMCARVER'];

      constructor(job) {
          this.job = job;
          this.t = 0;
          this.pos = { u: 0, v: 0 };
      }

      update() {
          if (!this.task) {
              this.task = this.newTask();
          }

          this.task.update();

          this.pos.u = 160 + this.task.value;
          this.pos.v = HeightMapData[this.task.layer][Math.floor(this.pos.u)] - 32 + 1;
          this.frame = this.task.frame || 0;
          this.equipmentframe = this.task.equipmentframe;

          if (this.task.finished) {
              this.task.completeTask(this);
              this.task = undefined;
          }
      }

      draw() {
          Sprite.drawViewportSprite(Sprite.villager[this.frame], this.pos);

          if (this.equipmentframe > -1) {
              Sprite.drawViewportSprite(Sprite.villager[this.equipmentframe], this.pos);
          }
      }

      newTask() {
          switch (this.job) {
              case BUTCHER:
                  return new ButcherTask();
              case WOODCUTTER:
                  return new WoodcutterTask();
              case TALLOWER:
                  return new TallowerTask();
              case STONECUTTER:
                  return new StonecutterTask();
              case SACRIFICE:
                  return new SacrificeTask();
              default:
                  return new IdleTask();
          }
      }
  }

  // TextFloatParticle


  class TextFloatParticle {
      constructor(pos, text, paletteRange) {
          this.pos = { ...pos };
          this.text = text;
          this.paletteRange = paletteRange;
          this.t = -1;
          this.d = 30;
      }

      update() {
          if (++this.t === this.d) this.cull = true;
          this.pos.v -= 0.2;
          this.paletteColor = Math.round((this.paletteRange[1] - this.paletteRange[0]) * (this.t/this.d) + this.paletteRange[0]);
      }

      draw() {
          Text.drawText(Viewport.ctx, this.text, this.pos.u, this.pos.v, 1, Text.palette[this.paletteColor]);
      }
  }

  // HelpScene


  class HelpScene {
      static pagesUnlocked = 4;
      static help = [
          {
              title: 'SANITY',
              text: 'The sanity of the village is already eroding. If it runs out before you accomplish your mission, you lose.',
              arrow: [278, 38]
          },
          {
              title: 'INFLUENCE',
              text: 'Use your influence to control villagers. The more villagers you have, the longer it takes to gain another.',
              arrow: [100, 3]
          },
          {
              title: 'JOBS',
              text: 'Use the arrow keys to switch jobs and change the number of villagers assigned to a job. As you unlock additional jobs, adjust the number of villagers assigned to accomplish your goals.',
              arrow: [65, 122]
          },
          {
              title: 'RESOURCES',
              text: 'Resources are produced constantly by villagers each turn. Some resources consume other resources to produce, so watch resource levels carefully.',
              arrow: [170, 128]
          }
      ];

      constructor(page) {
          this.page = page || 0;
          this.t = 0;
      }

      update() {
          this.t++;
          this.bounceX = Math.floor(Math.cos(this.t / 8) * 3);

          if (Input.pressed[Input.Action.RIGHT]) {
              this.page = (this.page + 1) % HelpScene.pagesUnlocked;
          }

          if (Input.pressed[Input.Action.LEFT]) {
              this.page = (this.page + HelpScene.pagesUnlocked - 1) % HelpScene.pagesUnlocked;
          }

          if (Input.pressed[Input.Action.MENU]) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = rgba(0, 0, 0, 0.66);
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          const page = HelpScene.help[this.page];

          const titleText = page.title.toUpperCase();
          const titleWidth = Text.measure(titleText, 1).w;
          Text.drawText(Viewport.ctx, titleText, (Viewport.width - titleWidth) / 2, 35, 1, Text.palette[4]);
          Text.drawParagraph(Viewport.ctx, page.text.toUpperCase(), 80, 50, 180, 1, Text.palette[4]);

          if (page.arrow) {
              Viewport.ctx.drawImage(Sprite.bigarrows[0].img, page.arrow[0] + this.bounceX, page.arrow[1]);
          }

          const helpText = `HELP PAGE ${this.page + 1}/${HelpScene.pagesUnlocked}    \\l\\r MORE HELP    \\e BACK`;
          const helpWidth = Text.measure(helpText, 1).w;
          Text.drawText(Viewport.ctx, helpText, (Viewport.width - helpWidth) / 2, 170, 1, Text.palette[4]);
      }
  }

  // DefeatScene


  class DefeatScene {
      constructor(stats) {
          this.stats = stats;

          this.text = [
              'THE LAST SPARK OF SANITY FADES IN ULTHAR, AND WITH IT',
              'ANY HOPE OF DELIVERANCE FOR YOU AND YOUR KIN.',
              '',
              'WOOD GATHERED: ' + this.stats.woodGathered,
              'MEAT BUTCHERED: ' + this.stats.meatGathered,
              'TORCHES CRAFTED: ' + this.stats.torchesCrafted,
              'STONE MINED: ' + this.stats.stoneGathered,
              'SECONDS SURVIVED: ' + this.stats.seconds
          ];
          this.frames = 0;
      }

      update() {
          this.frames++;

          if (Input.pressed[Input.Action.JUMP]) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = '#0a1a2f';
          Viewport.ctx.fillRect(-5, 0, Viewport.width + 5, Viewport.height);

          const gameOverWidth = Text.measure('GAME OVER', 2).w;
          Text.drawText(Viewport.ctx, 'GAME OVER', (Viewport.width - gameOverWidth) / 2, 10, 2, Text.palette[4]);

          //Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 73 - 30);
          Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 61 - 30);

          for (let i = 0; i < this.text.length; i++) {
              let width = Text.measure(this.text[i], 1).w;
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 80 + i * 10, 1, Text.palette[4]);
          }
      }
  }

  // GameScene


  const BUTTON_RECRUIT_VILLAGER = 0;
  const BUTTON_SACRIFICE_VILLAGER = 1;
  const BUTTON_REPAIR_BRIDGE = 2;
  const BUTTON_REPAIR_HALL = 3;
  const BUTTON_REPAIR_ALTAR = 4;
  const BUTTON_HELP = 5;

  class GameScene {
      constructor() {
          game.gameScene = this;
          this.entities = [];
          this.screenshakes = [];

          // Clock
          this.t = 0;
          this.influence = 5;
          this.sanity = 100;

          // Inventory
          this.meat = 0;
          this.wood = 0;
          this.stone = 0;
          this.torches = 0;

          // Playthrough Stats
          this.meatGathered = 0;
          this.woodGathered = 0;
          this.stoneGathered = 0;
          this.villagersRecruited = 0;
          this.torchesCrafted = 0;

          this.buttons = [];
          //this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button((320-80)/2, 15, 'V', 'Recruit Villager');
          //this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button((320-80)/2, 15, 'S', 'Sacrifice Villager');
          this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button(5, 3, 'V', 'Recruit Villager');
          this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button(5, 13, 'S', 'Sacrifice Villager');
          this.buttons[BUTTON_REPAIR_BRIDGE] = new Button(5, 23, 'B', 'REPAIR BRIDGE');
          this.buttons[BUTTON_REPAIR_HALL] = new Button(5, 33, 'T', 'REPAIR TALLOW HALL');
          this.buttons[BUTTON_REPAIR_ALTAR] = new Button(5, 43, 'A', 'BUILD ALTAR');
          this.buttons[BUTTON_HELP] = new Button(285, 168, 'H', 'HELP');
          this.buttons[BUTTON_HELP].visible = true;
          this.buttons[BUTTON_HELP].active = true;

          this.selectedJob = WOODCUTTER;
          this.jobsDisplayed = [WOODCUTTER];

          this.villagers = [];
          this.villagersWithJob = {
              [IDLE]: [],
              [BUTCHER]: [],
              [WOODCUTTER]: [],
              [TALLOWER]: [],
              [STONECUTTER]: [],
              [FIREKEEPER]: []
          };

          this.techBridge = false;
          this.techTorches = false;
          this.techStone = false;
          this.techAltar = false;
      }

      update() {
          // Set up displayed jobs
          if (this.techStone) {
              this.jobsDisplayed = [BUTCHER, WOODCUTTER, TALLOWER, STONECUTTER];
          } else if (this.techTorches) {
              this.jobsDisplayed = [BUTCHER, WOODCUTTER, TALLOWER];
          } else if (this.techBridge) {
              this.jobsDisplayed = [BUTCHER, WOODCUTTER];
          } else {
              this.jobsDisplayed = [WOODCUTTER];
          }

          if (this.torches > 0 && !this.techStone) {
              this.techStone = true;
          }

          // Player input

                  // move
          ///this.pos.x += this.vel.x;
          ///this.pos.y += this.vel.y;

          if (Input.pressed[Input.Action.RECRUIT_VILLAGER]) {
              console.log(this.recruitVillager());
          }

          if (Input.pressed[Input.Action.BUILD_BRIDGE]) {
              console.log(this.buildBridge());
          }

          if (Input.pressed[Input.Action.BUILD_HALL]) {
              console.log(this.buildHall());
          }

          if (Input.pressed[Input.Action.BUILD_ALTAR]) {
              console.log(this.buildAltar());
          }

          if (Input.pressed[Input.Action.DOWN]) {
              this.moveJobSelector(1);
          }

          if (Input.pressed[Input.Action.UP]) {
              this.moveJobSelector(-1);
          }

          if (Input.pressed[Input.Action.RIGHT]) {
              console.log(this.hireVillager(this.selectedJob));
          }

          if (Input.pressed[Input.Action.LEFT]) {
              console.log(this.fireVillager(this.selectedJob));
          }

          if (Input.pressed[Input.Action.SACRIFICE]) {
              console.log(this.sacrificeVillager());
          }

          if (Input.pressed[Input.Action.JUMP]) {
              this.sanity -= 10;
          }

          if (Input.pressed[Input.Action.HELP]) {
              game.scenes.push(new HelpScene());
          }

          // Game ticks

          this.t++;

          if (!this.nextSanityTick) {
              this.nextSanityTick = this.t + 12;
          }

          if (this.t >= this.nextSanityTick) {
              this.sanity -= 0.2;
              this.influence += 0.2;
              this.nextSanityTick = this.t + 12;
          }

          if (this.t === 4) ;

          // Button UI Elements

          this.buttons[BUTTON_RECRUIT_VILLAGER].active = (this.influence >= this.nextWorkerCost());
          this.buttons[BUTTON_RECRUIT_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_RECRUIT_VILLAGER].active);

          this.buttons[BUTTON_SACRIFICE_VILLAGER].active = (true);
          this.buttons[BUTTON_SACRIFICE_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_SACRIFICE_VILLAGER].active);

          this.buttons[BUTTON_REPAIR_BRIDGE].active = (this.wood >= 10);
          this.buttons[BUTTON_REPAIR_BRIDGE].visible = !this.techBridge && this.wood >= 10;

          this.buttons[BUTTON_REPAIR_HALL].active = (this.wood >= 10);
          this.buttons[BUTTON_REPAIR_HALL].visible = this.techBridge && !this.techTorches && this.wood >= 10;

          this.buttons[BUTTON_REPAIR_ALTAR].active = (this.stone >= 10);
          this.buttons[BUTTON_REPAIR_ALTAR].visible = this.techTorches && !this.techAltar && this.stone >= 10;

          let visibleButtonY = 3;
          for (let i = 0; i < 5; i++) {
              if (this.buttons[i].visible) {
                  this.buttons[i].y = visibleButtonY;
                  visibleButtonY += 10;
              }
          }

          // Villagers

          for (const villager of this.villagers) {
              villager.update();
          }

          // Entities

          for (const entity of this.entities) {
              entity.update();
          }
          this.entities = this.entities.filter(entity => !entity.cull);

          // Check

          if (this.sanity < 0) {
              this.playerLost();
          }
      }

      draw() {
          // Terrain

          Viewport.ctx.fillStyle = '#40985e';
          Viewport.ctx.fillRect(-5, 0, Viewport.width + 5, Viewport.height);

          Viewport.ctx.drawImage(Sprite.terrain[2].img, 0, -30);
          Viewport.ctx.drawImage(Sprite.terrain[1].img, 0, -30);
          Viewport.ctx.drawImage(Sprite.terrain[0].img, 0, -30);

          Viewport.ctx.drawImage(Sprite.blackcat[0].img, 160, 73 - 30);

          Viewport.ctx.fillStyle = '#0a1a2f';
          Viewport.ctx.fillRect(-5, Viewport.height - 31, Viewport.width + 5, 31);

          // Bridge

          if (this.techBridge) {
              Viewport.ctx.drawImage(Sprite.bridge[1].img, 112, 133 - 32);
          } else {
              Viewport.ctx.drawImage(Sprite.bridge[0].img, 112, 133 - 32);
          }

          // Tallower Hall

          if (this.techTorches) {
              Viewport.ctx.drawImage(Sprite.factory[1].img, 198, 133 - 32);
          } else {
              Viewport.ctx.drawImage(Sprite.factory[0].img, 198, 133 - 32);
          }

          // Altar

          if (this.techAltar) {
              let altarY = Math.floor(Math.sin(this.t / 25) * 2);
              Viewport.ctx.drawImage(Sprite.altar[0].img, 238, 116 - 30);
              Viewport.ctx.drawImage(Sprite.altar[1].img, 238, 115 - 30 + altarY);
          }

          {
              let crunk = String(Math.floor(this.sanity)) + ',' + String(Math.floor(this.influence)) + ',' + String(this.villagers.length);
              Text.drawText(Viewport.ctx, crunk, 3, 3, 1, Text.palette[1]);
          }

          for (const villager of this.villagers) {
              villager.draw();
          }

          if (game.scene === this) {
              // Hide button prompts if Help Screen is displayed, to avoid confusion
              for (const button of this.buttons) {
                  button.draw();
              }
          }

          this.drawSanityBar();
          this.drawInfluenceBar();
          this.drawJobSelectUI();
          this.drawInventory();

          for (const entity of this.entities) {
              entity.draw();
          }
      }

      drawSanityBar() {
          let k = Math.floor((this.sanity / 100) * 78);
          Viewport.ctx.drawImage(Sprite.sanitybar[0].img, 320-18-5, -3);
          Viewport.ctx.drawImage(Sprite.sanitybar[1].img, 320-18-5, -3);
          Viewport.ctx.drawImage(Sprite.sanitybar[2].img,
              0, 2 + (78 - k),
              18, k,
              320-18-5, -3 + 2 + (78 - k),
              18, k
          );
      }

      drawInfluenceBar() {
          let k = Math.floor(Math.min(this.influence / this.nextWorkerCost(), 1) * 80);
          Viewport.ctx.drawImage(Sprite.influencebar[0].img, (320-80)/2, 3);
          Viewport.ctx.drawImage(Sprite.influencebar[1].img,
              2, 3,
              k, 4,
              (320-80)/2 + 2, 3 + 3,
              k, 4
          );
      }

      drawJobSelectUI() {
          const cornerX = 7;
          const cornerY = 120;
          const verticalMargin = 10;

          let selectedIdx = 0;

          for (let i = 0; i < this.jobsDisplayed.length; i++) {
              if (this.selectedJob === this.jobsDisplayed[i]) {
                  selectedIdx = i;
              }

              const color = this.selectedJob === this.jobsDisplayed[i] ? Text.palette[3] : Text.palette[2];
              const numberText = String(this.villagersWithJob[this.jobsDisplayed[i]].length);
              const width = Text.measure(numberText).w;
              Text.drawText(Viewport.ctx, Villager.JOB_NAMES[this.jobsDisplayed[i]], cornerX + 5, cornerY + 4 + verticalMargin * i, 1, color);
              Text.drawText(Viewport.ctx, numberText, cornerX + 92 - width, cornerY + 4 + verticalMargin * i, 1, color);
          }

          const leftArrow = this.villagersWithJob[this.selectedJob].length > 0 ? 0 : 2;
          const rightArrow = this.villagersWithJob[IDLE].length > 0 ? 1 : 3;

          Viewport.ctx.drawImage(Sprite.jobselect[1].img, cornerX, cornerY + selectedIdx * verticalMargin);
          Viewport.ctx.drawImage(Sprite.smallarrows[leftArrow].img, cornerX + 77, cornerY + 4 + selectedIdx * verticalMargin);
          Viewport.ctx.drawImage(Sprite.smallarrows[rightArrow].img, cornerX + 94, cornerY + 4 + selectedIdx * verticalMargin);
      }

      drawInventory() {
          let woodWidth = Text.measure(String(this.wood), 1).w;
          let meatWidth = Text.measure(String(this.meat), 1).w;
          let stoneWidth = Text.measure(String(this.stone), 1).w;
          let torchWidth = Text.measure(String(this.torches), 1).w;

          Viewport.ctx.drawImage(Sprite.icons[0].img, INVENTORY_WOOD_POS.u - 60, INVENTORY_WOOD_POS.v - 1);
          Text.drawText(Viewport.ctx, 'WOOD', INVENTORY_WOOD_POS.u - 50, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);
          Text.drawText(Viewport.ctx, String(this.wood), INVENTORY_WOOD_POS.u - woodWidth, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);

          if (this.techBridge) {
              Viewport.ctx.drawImage(Sprite.icons[2].img, INVENTORY_MEAT_POS.u - 60, INVENTORY_MEAT_POS.v - 1);
              Text.drawText(Viewport.ctx, 'MEAT', INVENTORY_MEAT_POS.u - 50, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.meat), INVENTORY_MEAT_POS.u - meatWidth, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
          }

          if (this.techTorches) {
              Viewport.ctx.drawImage(Sprite.icons[3].img, INVENTORY_TORCH_POS.u - 60, INVENTORY_TORCH_POS.v - 1);
              Text.drawText(Viewport.ctx, 'TORCHES', INVENTORY_TORCH_POS.u - 50, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.torches), INVENTORY_TORCH_POS.u - torchWidth, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
          }

          if (this.techStone) {
              Viewport.ctx.drawImage(Sprite.icons[1].img, INVENTORY_STONE_POS.u - 60, INVENTORY_STONE_POS.v - 1);
              Text.drawText(Viewport.ctx, 'STONE', INVENTORY_STONE_POS.u - 50, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.stone), INVENTORY_STONE_POS.u - stoneWidth, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
          }

      }

      addEntity(entity) {
          if (!entity.z) {
              entity.z = 1;
          }

          for (let i = 0; i < this.entities.length; i++) {
              if (this.entities[i].z > entity.z) {
                  this.entities.splice(i, 0, entity);
                  return;
              }
          }

          this.entities.push(entity);
      }

      addScreenShake(screenshake) {
          // This screen shake applies to the entire rendered screen, including GUI
          this.screenshakes.push(screenshake);
      }

      moveJobSelector(delta) {
          let idx = this.jobsDisplayed.indexOf(this.selectedJob);
          idx = (idx + delta + this.jobsDisplayed.length) % this.jobsDisplayed.length;
          this.selectedJob = this.jobsDisplayed[idx];
      }

      recruitVillager() {
          const cost = this.nextWorkerCost();
          if (this.influence >= cost) {
              this.influence -= cost;

              const villager = new Villager(this.selectedJob || WOODCUTTER);
              this.villagers.push(villager);
              this.villagersWithJob[villager.job].push(villager);
              this.villagersRecruited++;

              return true;
          }

          return false;
      }

      hireVillager() {
          if (this.villagersWithJob[IDLE].length > 0) {
              // TODO
              const villager = this.villagersWithJob[IDLE].pop();
              villager.job = this.selectedJob;
              this.villagersWithJob[this.selectedJob].push(villager);
              return true;
          }
          return false;
      }

      fireVillager() {
          if (this.villagersWithJob[this.selectedJob].length > 0) {
              // TODO
              const villager = this.villagersWithJob[this.selectedJob].pop();
              villager.job = IDLE;
              this.villagersWithJob[IDLE].push(villager);
              return true;
          }
          return false;
      }

      sacrificeVillager() {
          if (this.villagersWithJob[this.selectedJob].length > 0) {
              // TODO - pick right villager
              const villager = this.villagersWithJob[this.selectedJob].pop();

              this.villagers.splice(this.villagers.indexOf(villager), 1);

              this.entities.push(new SacrificeParticle(villager));

              //villager.job = SACRIFICE;
              //this.villagersWithJob[SACRIFICE].push(villager);
              //this.activeSacrifice = new SacrificeParticle();
              console.log('VILLAGER DEAD');
              return true;
          }
          return false;
      }

      consumeMeat() {
          if (this.meat > 0) {
              this.meat--;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-1', [4, 2]));
          } else {
              this.sanity--;
              this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '-1', [0, 2]));
          }
      }

      grantSanity(value) {
          if (this.sanity < 100) {
              this.sanity = Math.min(100, this.sanity + value);
              this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '+' + value, [0, 2]));
          }
      }

      gatherMeat() {
          this.meat += 5;
          this.meatGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '+5', [4, 2]));
      }

      gatherWood() {
          this.wood += 5;
          this.woodGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '+5', [4, 2]));
      }

      craftTorch() {
          this.torches += 1;
          this.torchesCrafted += 1;
          this.wood -= 2;
          this.meat -= 2;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_TORCH_POS.u + 6, v: INVENTORY_TORCH_POS.v }, '+1', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-2', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-2', [4, 2]));
      }

      gatherStone() {
          this.stone += 5;
          this.stoneGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: 100, v: 100 }, '+5', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '+5', [4, 2]));
      }

      buildBridge() {
          const button = this.buttons[BUTTON_REPAIR_BRIDGE];

          if (button.active && button.visible && this.wood >= 10 && !this.techBridge) {
              this.wood -= 10;
              this.techBridge = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

              // TODO build bridge animation
          }
      }

      buildHall() {
          const button = this.buttons[BUTTON_REPAIR_HALL];

          if (button.active && button.visible && this.wood >= 10 && !this.techTorches) {
              this.wood -= 10;
              this.techTorches = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

              // TODO build hall animation
          }
      }

      buildAltar() {
          const button = this.buttons[BUTTON_REPAIR_ALTAR];

          if (button.active && button.visible && this.stone >= 10 && !this.techAltar) {
              this.stone -= 10;
              this.techAltar = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '-10', [4, 2]));

              // TODO build altar animation
          }
      }

      nextWorkerCost() {
          return Math.floor(1 * Math.pow(1.3, this.villagers.length));
      }

      playerLost() {
          const stats = {
              seconds: Math.floor(this.t / 60),
              woodGathered: this.woodGathered,
              meatGathered: this.meatGathered,
              torchesCrafted: this.torchesCrafted,
              stoneGathered: this.stoneGathered,
          };
          game.scenes.pop();
          game.scenes.push(new DefeatScene(stats));
      }
  }

  // Game


  /**
   * Game state.
   */
  class Game {
      init() {
          Sprite.loadSpritesheet(() => {
              Viewport.init();
              Sprite.init();
              Text.init();
              Input.init();
              Audio.init();

              Camera.init();

              window.addEventListener('blur', () => this.pause());
              window.addEventListener('focus', () => this.unpause());

              this.reset();
              this.start();
          });
      }

      reset() {
          this.scenes = [];
          this.lastFrame = 0;
          this.nextLevel = 0;

          this.scores = [
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 }
          ];

          this.scenes.push(new IntroScene());
      }

      start() {
          this.frame = 0;
          this.framestamps = [0];
          this.update();
          window.requestAnimationFrame((xyz) => this.onFrame(xyz));
      }

      onFrame(currentms) {
          let delta = (currentms - this.lastFrame) - (1000 / FPS);

          if (delta >= 0) {
              this.frame++;
              this.lastFrame = (currentms - delta);

              // The above calculation is right for smoothing out frames, but if
              // we end up far behind the currentms, we can "fast play" for a long time
              // which is not desired. Fast-forward if we fall behind more than 5 frames.
              if (currentms - this.lastFrame > 5 * 1000 / FPS) {
                  this.lastFrame = currentms;
              }

              Viewport.resize();
              this.update();
              this.draw(Viewport.ctx);

              // this.framestamps.push(currentms);
              // if (this.framestamps.length >= 120) {
              //     this.framestamps.shift();
              // }
              // this.fps = 1000 / ((this.framestamps[this.framestamps.length - 1] - this.framestamps[0]) / this.framestamps.length);
          }
          window.requestAnimationFrame((xyz) => this.onFrame(xyz));
      }

      update() {
          // Gather user input
          Input.update();

          // Handle special keys that are screen-independent
          if (Input.pressed[Input.Action.MUSIC_TOGGLE]) {
              Audio.musicEnabled = !Audio.musicEnabled;
          }
          if (Input.pressed[Input.Action.SFX_TOGGLE]) {
              Audio.sfxEnabled = !Audio.sfxEnabled;
          }

          // Hand off control to the current "screen" (for example, game screen or menu)
          if (this.scenes.length === 0) {
              this.scenes.push(new GameScene());
          }
          this.scene = this.scenes[this.scenes.length - 1];
          this.scene.update();

          // Do per-frame audio updates
          Audio.update();
      }

      draw() {
          // Reset canvas transform and scale
          Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);
          Viewport.ctx.scale(Viewport.scale, Viewport.scale);

          for (let i = 0; i < this.scenes.length; i++) {
              this.scenes[i].draw();
          }

          //Text.drawText(Viewport.ctx, String(this.fps), 15, 15, 1, Text.white);
      }

      pause() {
          if (this.paused) return;
          this.paused = true;
          Audio.pause();
      }

      unpause() {
          if (!this.paused) return;
          this.paused = false;
          Audio.unpause();
      }

      restartLevel() {
          this.scenes.pop();
      }

      speedrunScore() {
          let score = 100000;

          for (let i = 0; i < this.scores.length; i++) {
              score -= this.scores[i].time;
              score -= this.scores[i].enemiesAlive * 5 * 60;
          }

          let scoreText = String(score);
          if (scoreText.length > 3) {

              scoreText = scoreText.slice(0, scoreText.length - 3) + ',' + scoreText.slice(scoreText.length - 3);
          }

          return scoreText;
      }
  }

  const game = new Game();

  /**
   * Create and launch game.
   */
  game.init();

})();</script>