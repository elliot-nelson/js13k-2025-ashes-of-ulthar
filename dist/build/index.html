<meta charset="utf8"><style>body,html{width:100vw;height:100vh;margin:0;padding:0;background-color:#2c1b2e}#d1{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}#d2{max-width:100vw;max-height:100vh;aspect-ratio:48/27}#canvas{width:100%;height:100%}</style><div id="d1"><div id="d2"><canvas id="canvas"></canvas></div></div><script>(function () {
  'use strict';

  /*

  ZzFX - Zuper Zmall Zound Zynth v1.1.8
  By Frank Force 2019
  https://github.com/KilledByAPixel/ZzFX

  ZzFX Features

  - Tiny synth engine with 20 controllable parameters.
  - Play sounds via code, no need for sound assed files!
  - Compatible with most modern web browsers.
  - Small code footprint, the micro version is under 1 kilobyte.
  - Can produce a huge variety of sound effect types.
  - Sounds can be played with a short call. zzfx(...[,,,,.1,,,,9])
  - A small bit of randomness appied to sounds when played.
  - Use ZZFX.GetNote to get frequencies on a standard diatonic scale.
  - Sounds can be saved out as wav files for offline playback.
  - No additional libraries or dependencies are required.

  */
  /*

    ZzFX MIT License

    Copyright (c) 2019 - Frank Force

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

  */


  // zzfx object with some extra functionalty
  const ZZFX = {
      // master volume scale
      volume: .3,

      // sample rate for audio
      sampleRate: 44100,

      // create shared audio context
      x: new (window.AudioContext || webkitAudioContext),

      destination: undefined,

      // play a sound from zzfx paramerters
      play: function(...parameters)
      {
          // build samples and start sound
          return this.playSamples(this.buildSamples(...parameters));
      },

      // play an array of samples
      playSamples: function(...samples)
      {
          // create buffer and source
          const buffer = this.x.createBuffer(samples.length, samples[0].length, this.sampleRate),
              source = this.x.createBufferSource();

          samples.map((d,i)=> buffer.getChannelData(i).set(d));
          source.buffer = buffer;
          source.connect(this.destination);
          source.start();
          return source;
      },

      // build an array of samples
      buildSamples: function
      (
          volume = 1,
          randomness = .05,
          frequency = 220,
          attack = 0,
          sustain = 0,
          release = .1,
          shape = 0,
          shapeCurve = 1,
          slide = 0,
          deltaSlide = 0,
          pitchJump = 0,
          pitchJumpTime = 0,
          repeatTime = 0,
          noise = 0,
          modulation = 0,
          bitCrush = 0,
          delay = 0,
          sustainVolume = 1,
          decay = 0,
          tremolo = 0
      )
      {
          // init parameters
          const PI2 = Math.PI*2;
          let sampleRate = this.sampleRate,
          sign = v => v>0?1:-1,
          startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,
          startFrequency = frequency *=
              (1 + randomness*2*Math.random() - randomness) * PI2 / sampleRate,
          b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, f, length;

          // scale by sample rate
          attack = attack * sampleRate + 9; // minimum attack to prevent pop
          decay *= sampleRate;
          sustain *= sampleRate;
          release *= sampleRate;
          delay *= sampleRate;
          deltaSlide *= 500 * PI2 / sampleRate**3;
          modulation *= PI2 / sampleRate;
          pitchJump *= PI2 / sampleRate;
          pitchJumpTime *= sampleRate;
          repeatTime = repeatTime * sampleRate | 0;

          // generate waveform
          for(length = attack + decay + sustain + release + delay | 0;
              i < length; b[i++] = s)
          {
              if (!(++c%(bitCrush*100|0)))                      // bit crush
              {
                  s = shape? shape>1? shape>2? shape>3?         // wave shape
                      Math.sin((t%PI2)**3) :                    // 4 noise
                      Math.max(Math.min(Math.tan(t),1),-1):     // 3 tan
                      1-(2*t/PI2%2+2)%2:                        // 2 saw
                      1-4*Math.abs(Math.round(t/PI2)-t/PI2):    // 1 triangle
                      Math.sin(t);                              // 0 sin

                  s = (repeatTime ?
                          1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo
                          : 1) *
                      sign(s)*(Math.abs(s)**shapeCurve) *       // curve 0=square, 2=pointy
                      volume * this.volume * (                  // envelope
                      i < attack ? i/attack :                   // attack
                      i < attack + decay ?                      // decay
                      1-((i-attack)/decay)*(1-sustainVolume) :  // decay falloff
                      i < attack  + decay + sustain ?           // sustain
                      sustainVolume :                           // sustain volume
                      i < length - delay ?                      // release
                      (length - i - delay)/release *            // release falloff
                      sustainVolume :                           // release volume
                      0);                                       // post release

                  s = delay ? s/2 + (delay > i ? 0 :            // delay
                      (i<length-delay? 1 : (length-i)/delay) *  // release delay
                      b[i-delay|0]/2) : s;                      // sample delay
              }

              f = (frequency += slide += deltaSlide) *          // frequency
                  Math.cos(modulation*tm++);                    // modulation
              t += f - f*noise*(1 - (Math.sin(i)+1)*1e9%2);     // noise

              if (j && ++j > pitchJumpTime)       // pitch jump
              {
                  frequency += pitchJump;         // apply pitch jump
                  startFrequency += pitchJump;    // also apply to start
                  j = 0;                          // stop pitch jump time
              }

              if (repeatTime && !(++r % repeatTime)) // repeat
              {
                  frequency = startFrequency;     // reset frequency
                  slide = startSlide;             // reset slide
                  j = j || 1;                     // reset pitch jump time
              }
          }

          return b;
      },

      // get frequency of a musical note on a diatonic scale
      getNote: function(semitoneOffset=0, rootNoteFrequency=440)
      {
          return rootNoteFrequency * 2**(semitoneOffset/12);
      }

  }; // ZZFX

  /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
  *
  * Copyright (c) 2011-2013 Marcus Geelnard
  *
  * This software is provided 'as-is', without any express or implied
  * warranty. In no event will the authors be held liable for any damages
  * arising from the use of this software.
  *
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  *
  * 1. The origin of this software must not be misrepresented; you must not
  *    claim that you wrote the original software. If you use this software
  *    in a product, an acknowledgment in the product documentation would be
  *    appreciated but is not required.
  *
  * 2. Altered source versions must be plainly marked as such, and must not be
  *    misrepresented as being the original software.
  *
  * 3. This notice may not be removed or altered from any source
  *    distribution.
  *
  */


  // Some general notes and recommendations:
  //  * This code uses modern ECMAScript features, such as ** instead of
  //    Math.pow(). You may have to modify the code to make it work on older
  //    browsers.
  //  * If you're not using all the functionality (e.g. not all oscillator types,
  //    or certain effects), you can reduce the size of the player routine even
  //    further by deleting the code.


  const CPlayer = function() {

      //--------------------------------------------------------------------------
      // Private methods
      //--------------------------------------------------------------------------

      // Oscillators
      var osc_sin = function (value) {
          return Math.sin(value * 6.283184);
      };

      var osc_saw = function (value) {
          return 2 * (value % 1) - 1;
      };

      var osc_square = function (value) {
          return (value % 1) < 0.5 ? 1 : -1;
      };

      var osc_tri = function (value) {
          var v2 = (value % 1) * 4;
          if(v2 < 2) return v2 - 1;
          return 3 - v2;
      };

      var getnotefreq = function (n) {
          // 174.61.. / 44100 = 0.003959503758 (F3)
          return 0.003959503758 * (2 ** ((n - 128) / 12));
      };

      var createNote = function (instr, n, rowLen) {
          var osc1 = mOscillators[instr.i[0]],
              o1vol = instr.i[1],
              o1xenv = instr.i[3]/32,
              osc2 = mOscillators[instr.i[4]],
              o2vol = instr.i[5],
              o2xenv = instr.i[8]/32,
              noiseVol = instr.i[9],
              attack = instr.i[10] * instr.i[10] * 4,
              sustain = instr.i[11] * instr.i[11] * 4,
              release = instr.i[12] * instr.i[12] * 4,
              releaseInv = 1 / release,
              expDecay = -instr.i[13]/16,
              arp = instr.i[14],
              arpInterval = rowLen * (2 **(2 - instr.i[15]));

          var noteBuf = new Int32Array(attack + sustain + release);

          // Re-trig oscillators
          var c1 = 0, c2 = 0;

          // Local variables.
          var j, j2, e, rsample, o1t, o2t;

          // Generate one note (attack + sustain + release)
          for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
              if (j2 >= 0) {
                  // Switch arpeggio note.
                  arp = (arp >> 8) | ((arp & 255) << 4);
                  j2 -= arpInterval;

                  // Calculate note frequencies for the oscillators
                  o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                  o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
              }

              // Envelope
              e = 1;
              if (j < attack) {
                  e = j / attack;
              } else if (j >= attack + sustain) {
                  e = (j - attack - sustain) * releaseInv;
                  e = (1 - e) * (3 ** (expDecay * e));
              }

              // Oscillator 1
              c1 += o1t * e ** o1xenv;
              rsample = osc1(c1) * o1vol;

              // Oscillator 2
              c2 += o2t * e ** o2xenv;
              rsample += osc2(c2) * o2vol;

              // Noise oscillator
              if (noiseVol) {
                  rsample += (2 * Math.random() - 1) * noiseVol;
              }

              // Add to (mono) channel buffer
              noteBuf[j] = (80 * rsample * e) | 0;
          }

          return noteBuf;
      };


      //--------------------------------------------------------------------------
      // Private members
      //--------------------------------------------------------------------------

      // Array of oscillator functions
      var mOscillators = [
          osc_sin,
          osc_square,
          osc_saw,
          osc_tri
      ];

      // Private variables set up by init()
      var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf, mChannelBufs;


      //--------------------------------------------------------------------------
      // Initialization
      //--------------------------------------------------------------------------

      this.init = function (song) {
          // Define the song
          mSong = song;

          // Init iteration state variables
          mLastRow = song.endPattern;
          mCurrentCol = 0;

          // Prepare song info
          mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

          // Create work buffer (initially cleared)
          mMixBuf = new Int32Array(mNumWords);

          mChannelBufs = [];

          for (let i = 0; i < song.numChannels; i++) {
              mChannelBufs.push(new Int32Array(mNumWords));
          }
      };


      //--------------------------------------------------------------------------
      // Public methods
      //--------------------------------------------------------------------------

      // Generate audio data for a single track
      this.generate = function () {
          // Local variables
          var i, j, p, row, col, n, cp,
              k, t, rsample, rowStartSample, f;

          // Put performance critical items in local variables
          var chnBuf = new Int32Array(mNumWords),
              instr = mSong.songData[mCurrentCol],
              rowLen = mSong.rowLen,
              patternLen = mSong.patternLen;

          // Clear effect state
          var low = 0, band = 0, high;
          var lsample, filterActive = false;

          // Clear note cache.
          var noteCache = [];

           // Patterns
           for (p = 0; p <= mLastRow; ++p) {
              cp = instr.p[p];

              // Pattern rows
              for (row = 0; row < patternLen; ++row) {
                  // Execute effect command.
                  var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                  if (cmdNo) {
                      instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                      // Clear the note cache since the instrument has changed.
                      if (cmdNo < 17) {
                          noteCache = [];
                      }
                  }

                  // Put performance critical instrument properties in local variables
                  var oscLFO = mOscillators[instr.i[16]],
                      lfoAmt = instr.i[17] / 512,
                      lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                      fxLFO = instr.i[19],
                      fxFilter = instr.i[20],
                      fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                      q = 1 - instr.i[22] / 255,
                      dist = instr.i[23] * 1e-5,
                      drive = instr.i[24] / 32,
                      panAmt = instr.i[25] / 512,
                      panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                      dlyAmt = instr.i[27] / 255,
                      dly = instr.i[28] * rowLen & -2;  // Must be an even number

                  // Calculate start sample number for this row in the pattern
                  rowStartSample = (p * patternLen + row) * rowLen;

                  // Generate notes for this pattern row
                  for (col = 0; col < 4; ++col) {
                      n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                      if (n) {
                          if (!noteCache[n]) {
                              noteCache[n] = createNote(instr, n, rowLen);
                          }

                          // Copy note from the note cache
                          var noteBuf = noteCache[n];
                          for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                            chnBuf[i] += noteBuf[j];
                          }
                      }
                  }

                  // Perform effects for this pattern row
                  for (j = 0; j < rowLen; j++) {
                      // Dry mono-sample
                      k = (rowStartSample + j) * 2;
                      rsample = chnBuf[k];

                      // We only do effects if we have some sound input
                      if (rsample || filterActive) {
                          // State variable filter
                          f = fxFreq;
                          if (fxLFO) {
                              f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                          }
                          f = 1.5 * Math.sin(f);
                          low += f * band;
                          high = q * (rsample - band) - low;
                          band += f * high;
                          rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                          // Distortion
                          if (dist) {
                              rsample *= dist;
                              rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                              rsample /= dist;
                          }

                          // Drive
                          rsample *= drive;

                          // Is the filter active (i.e. still audiable)?
                          filterActive = rsample * rsample > 1e-5;

                          // Panning
                          t = Math.sin(panFreq * k) * panAmt + 0.5;
                          lsample = rsample * (1 - t);
                          rsample *= t;
                      } else {
                          lsample = 0;
                      }

                      // Delay is always done, since it does not need sound input
                      if (k >= dly) {
                          // Left channel = left + right[-p] * t
                          lsample += chnBuf[k-dly+1] * dlyAmt;

                          // Right channel = right + left[-p] * t
                          rsample += chnBuf[k-dly] * dlyAmt;
                      }

                      // Store in stereo channel buffer (needed for the delay effect)
                      chnBuf[k] = lsample | 0;
                      chnBuf[k+1] = rsample | 0;

                      // ...and add to stereo mix buffer
                      mMixBuf[k] += lsample | 0;
                      mMixBuf[k+1] += rsample | 0;

                      // ...and channel
                      mChannelBufs[mCurrentCol][k] += lsample | 0;
                      mChannelBufs[mCurrentCol][k+1] += rsample | 0;
                  }
              }
          }

          // Next iteration. Return progress (1.0 == done!).
          mCurrentCol++;
          return mCurrentCol / mSong.numChannels;
      };

      // Create a AudioBuffer from the generated audio data
      this.createAudioBuffer = function(context, channelNumber) {
          let source = channelNumber === undefined ? mMixBuf : mChannelBufs[channelNumber];

          var buffer = context.createBuffer(2, mNumWords / 2, 44100);
          for (var i = 0; i < 2; i ++) {
              var data = buffer.getChannelData(i);
              for (var j = i; j < mNumWords; j += 2) {
                  data[j >> 1] = source[j] / 65536;
              }
          }

          return buffer;
      };

      // Create a WAVE formatted Uint8Array from the generated audio data
      this.createWave = function() {
          // Create WAVE header
          var headerLen = 44;
          var l1 = headerLen + mNumWords * 2 - 8;
          var l2 = l1 - 36;
          var wave = new Uint8Array(headerLen + mNumWords * 2);
          wave.set(
              [82,73,70,70,
               l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
               87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
               68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
               l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
          );

          // Append actual wave data
          for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
              // Note: We clamp here
              var y = mMixBuf[i];
              y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
              wave[idx++] = y & 255;
              wave[idx++] = (y >> 8) & 255;
          }

          // Return the WAVE formatted typed array
          return wave;
      };

      // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
      this.getData = function(t, n) {
          var i = 2 * Math.floor(t * 44100);
          var d = new Array(n);
          for (var j = 0; j < 2*n; j += 1) {
              var k = i + j;
              d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
          }
          return d;
      };
  };

  // Song: ThirteenthCenturyVibes
  //
  // You can load this in SoundBox using the binary export, see the ".sbox"
  // file of the same name in src/assets folder.

      // This music has been exported by SoundBox. You can use it with
      // http://sb.bitsnbites.eu/player-small.js in your own product.

      // See http://sb.bitsnbites.eu/demo.html for an example of how to
      // use it in a demo.

      // This music has been exported by SoundBox. You can use it with
      // http://sb.bitsnbites.eu/player-small.js in your own product.

      // See http://sb.bitsnbites.eu/demo.html for an example of how to
      // use it in a demo.

      // Song data
      const song = {
        songData: [
          { // Instrument 0
            i: [
            1, // OSC1_WAVEFORM
            192, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            1, // OSC2_WAVEFORM
            191, // OSC2_VOL
            116, // OSC2_SEMI
            9, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            6, // ENV_ATTACK
            22, // ENV_SUSTAIN
            34, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            69, // LFO_AMT
            3, // LFO_FREQ
            1, // LFO_FX_FREQ
            1, // FX_FILTER
            23, // FX_FREQ
            167, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            77, // FX_PAN_AMT
            6, // FX_PAN_FREQ
            7, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,2,2,2,2,1,1,1,3,1,1,1,3,4,1,4,3,1,1,1,3,1,1,1,5],
            // Columns
            c: [
              {n: [125,137,125,,,,125,,130,,130,,125,,,,125,125,125,,,,125,,130,,130,,125,,,,128,,128,140,,,128,,134,,134,,,128,,,128,,128,128,,,128,,134,,134,,,128,,,132,,132,,134,,132,,125,,125,,,,130,,132,,132,,134,,132,,125,,125,,,135,130,,,,,134,,,,,,,,,,,,132,,,,134,,,,,,142,,144,,,,132],
               f: []},
              {n: [125,,125,,,,125,,130,,130,,125,,,,125,,125,,,,125,,130,,130,,125,,,,128,,128,,,,128,,134,,134,,,,,,128,,128,128,,,128,,134,,134,,,128,,,132,,132,,134,,132,,125,,125,,,,,,132,,132,,134,,132,,125,,125,,,,130,,,,,,,,,,,,,,,,,,,,,,,,,,,,,144],
               f: []},
              {n: [125,137,125,,,,125,,130,,130,,125,,,,144,,144,,142,,142,,140,,140,,137,,137,,128,,128,140,,,128,,134,,134,,,128,,,,132,,132,,130,,130,,128,,128,,125,,125,132,,132,,134,,132,,125,,125,,,,130,,,,,,,,,,,,,,,,,,,,,134,,,,,,,,,,,,132],
               f: []},
              {n: [125,137,125,,,,125,,,,130,,125,,,,125,125,125,,,,125,,130,,130,,132,,,,128,,128,140,,,,123,,,134,,,128,,,128,,128,128,,,128,,134,,134,,,130,,,132,,132,,134,,128,,128,,125,,,,130,,132,,132,,134,,132,,125,,125,,,,128,,,,,134,,,,,,130,,,,,,132,,,,134,,,,123,,125,,127,,,,123],
               f: []},
              {n: [125,,125,,,,125,,130,,,,125,,,,144,,144,,142,,142,,140,,140,,137,,137,,128,,128,140,,,128,,134,,,,,128,,,,132,,,,130,,,,128,,,,125,,,132,,132,,,,132,,125,,,,,,,,,,,,,,,,,,,,,,,,,,,134],
               f: []}
            ]
          },
          { // Instrument 1
            i: [
            3, // OSC1_WAVEFORM
            100, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            3, // OSC2_WAVEFORM
            201, // OSC2_VOL
            128, // OSC2_SEMI
            2, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            0, // ENV_ATTACK
            6, // ENV_SUSTAIN
            49, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            139, // LFO_AMT
            4, // LFO_FREQ
            1, // LFO_FX_FREQ
            3, // FX_FILTER
            30, // FX_FREQ
            184, // FX_RESONANCE
            119, // FX_DIST
            244, // FX_DRIVE
            147, // FX_PAN_AMT
            6, // FX_PAN_FREQ
            24, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [2,3,2,2,2,2,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3,2,2,2,3],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [113,,113,,113,,113,,118,,118,,118,,118,,113,,113,,113,,113,,118,,118,,118,,118],
               f: []},
              {n: [113,,113,,113,,113,,118,,118,,118,,118,,113,,111,,113,,115,,116,,118,,120,,122],
               f: []}
            ]
          },
          { // Instrument 2
            i: [
            0, // OSC1_WAVEFORM
            0, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            128, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            125, // NOISE_VOL
            0, // ENV_ATTACK
            1, // ENV_SUSTAIN
            59, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            1, // FX_FILTER
            193, // FX_FREQ
            171, // FX_RESONANCE
            0, // FX_DIST
            29, // FX_DRIVE
            39, // FX_PAN_AMT
            3, // FX_PAN_FREQ
            88, // FX_DELAY_AMT
            3 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,,,,,4,4,4,5,4,4,4,5,,,4,5,4,4,4,5,4,4,4],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [113,,,,,,,,113,,,,,,,,113,,,,,,,,113],
               f: []},
              {n: [113,,,,,,,,113,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,113,,,,113,,,,113,,,,113,113,113],
               f: []}
            ]
          },
          { // Instrument 3
            i: [
            0, // OSC1_WAVEFORM
            160, // OSC1_VOL
            128, // OSC1_SEMI
            64, // OSC1_XENV
            0, // OSC2_WAVEFORM
            160, // OSC2_VOL
            128, // OSC2_SEMI
            0, // OSC2_DETUNE
            64, // OSC2_XENV
            210, // NOISE_VOL
            4, // ENV_ATTACK
            7, // ENV_SUSTAIN
            52, // ENV_RELEASE
            85, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            60, // LFO_AMT
            4, // LFO_FREQ
            1, // LFO_FX_FREQ
            2, // FX_FILTER
            255, // FX_FREQ
            0, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            61, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            32, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [4,4,4,5,4,5,4,4,4,5,4,4,4,5,4,4,4,5,4,4,4,5,4,4,4,5],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [,,,,113,,,,,,,,113,,,,,,,,113,,,,,,,,113],
               f: []},
              {n: [,,,,113,,,,,,,,113,,,,113,,,,113,,,,113,,,,113],
               f: []}
            ]
          },
          { // Instrument 4
            i: [
            0, // OSC1_WAVEFORM
            0, // OSC1_VOL
            140, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            140, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            81, // NOISE_VOL
            4, // ENV_ATTACK
            10, // ENV_SUSTAIN
            47, // ENV_RELEASE
            55, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            187, // LFO_AMT
            5, // LFO_FREQ
            0, // LFO_FX_FREQ
            1, // FX_FILTER
            239, // FX_FREQ
            135, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            108, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            16, // FX_DELAY_AMT
            4 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,4,4,5,4,5,4,4,4,5,4,4,4,5,,,4,5,4,4,4,5,4,4,4],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [],
               f: []},
              {n: [,113,113,,,113,,,,113,113,,,113,,,,113,113,,,113,,,,113,113,,,113],
               f: []},
              {n: [,113,113,,,113,,,,113,113,,,113,,,113,,113,,113,,113,,113,,113,,113,,113,,,,,,,,,,,,,,,,,,,,,,,,,,,113,,,,113],
               f: []}
            ]
          },
        ],
        rowLen: 5513,   // In sample lengths
        patternLen: 32,  // Rows per pattern
        endPattern: 25,  // End pattern
        numChannels: 5  // Number of channels
      };

  // Audio


  const Audio = {
      init() {
          Audio.contextCreated = false;
          Audio.readyToPlay = false;
          Audio.musicEnabled = true;
          Audio.sfxEnabled = true;
          Audio.musicVolume = 0;
          Audio.sfxVolume = 0;

          Audio.levelStart = [5.02,,7,,,.18,,.37,,25,124,.03,.03,,,,.13,.35,.01]; // Random 807

          Audio.playerJump = [,,315,,.08,.07,,.77,-16,,,,,,,,,.91,.01];
          Audio.playerLand = [1.33,,423,.01,,.06,2,2.64,-3.8,,,,,.1,,.2,,.54,.01]; // Hit 491
          Audio.playerDeath = [1.11,,779,.01,.2,.48,4,4.56,.4,,,,.02,.9,,1,,.34,.13]; // Explosion 566
          Audio.playerSlam = [2.05,,374,.01,.05,.02,2,.59,-8.2,,,,,,,.5,.29,.65,.09]; // Shoot 673

          Audio.littleJump = [1.01,,491,,.01,.05,,1.02,25,,,,,,,.1,,.45,.08]; // Jump 438
          Audio.littleEscape = [,,433,.01,.18,.24,,.51,,,418,,.06,.1,,,,.43,.25,.11]; // Powerup 426

          Audio.enemyDeath = [1.81,,135,.01,.04,.18,1,.11,-6.6,,,,,.2,,.3,.15,.74,.09]; // Hit 569
      },

      initContext() {
          if (Audio.contextCreated) return;

          // In Safari, ensure our target AudioContext is created inside a
          // click or tap event (this ensures we don't interact with it until
          // after user input).
          //
          // Chrome and Firefox are more relaxed, but this approach works for all 3.
          ZZFX.x = Audio.ctx = new AudioContext();
          Audio.gain_ = Audio.ctx.createGain();
          Audio.gain_.connect(Audio.ctx.destination);
          ZZFX.destination = Audio.gain_;

          Audio.contextCreated = true;
      },

      initTracks() {
          // In this game, we ensure the screen that calls this function happens after the
          // user has interacted at least once (and that interaction called initContext above),
          // so we know it's safe to interact with the audio context.
          if (!Audio.musicPlaying) {
              this.player = new CPlayer();
              this.player.init(song);

              for (;;) {
                  if (this.player.generate() === 1) break;
              }

              this.musicGainNodes = [];
              this.songSources = [];

              for (let i = 0; i < song.numChannels; i++) {
                  let buffer = this.player.createAudioBuffer(Audio.ctx, i);
                  this.songSource = Audio.ctx.createBufferSource();

                  let gainNode = Audio.ctx.createGain();
                  gainNode.connect(Audio.gain_);
                  this.musicGainNodes.push(gainNode);

                  /*if (i === TRACK_COMBAT || i === TRACK_WAVE) {
                      gainNode.gain.value = 0;
                  }*/

                  this.songSource.buffer = buffer;
                  this.songSource.loop = true;
                  this.songSource.connect(gainNode);
                  this.songSources.push(this.songSource);
              }

              this.musicStartTime = Audio.ctx.currentTime + 0.1;

              for (let i = 0; i < song.numChannels; i++) {
                  this.songSources[i].start(this.musicStartTime);
                  // comment out music
              }

              Audio.musicPlaying = true;
          }

          Audio.readyToPlay = true;
      },

      update() {
          if (!Audio.readyToPlay) return;

          this.sfxVolume = this.sfxEnabled ? 0.3 : 0;
          this.musicVolume = this.musicEnabled ? 1 : 0;

          ZZFX.volume = this.sfxVolume;

          if (this.sfxEnabled) {
              ZZFX.volume = 0.3;
          } else {
              ZZFX.volume = 0;
          }
      },

      play(sound) {
          if (!Audio.readyToPlay) return;
          ZZFX.play(...sound);
      },

      // It's important we do pausing and unpausing as specific events and not in general update(),
      // because update() is triggered by the animation frame trigger which does not run if the
      // page is not visible. (So, if you want the music to fade in the background, for example,
      // that's not helpful if it won't work because you aren't looking at the page!)

      pause() {
          if (Audio.readyToPlay) {
              Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);
          }
      },

      unpause() {
          if (Audio.readyToPlay) {
              Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);
          }
      }
  };

  // Constants


  // The game's desired dimensions in pixels - the actual dimensions can be adjusted
  // slightly by the Viewport module.
  const TARGET_GAME_WIDTH = 320;
  const TARGET_GAME_HEIGHT = 180;

  const INVENTORY_WOOD_POS = { u: 250, v: 131 };
  const INVENTORY_MEAT_POS = { u: 250, v: 143 };
  const INVENTORY_TORCH_POS = { u: 250, v: 155 };
  const INVENTORY_STONE_POS = { u: 250, v: 167 };
  const SANITY_POS = { u: 288, v: 9 };

  // Size in pixels of each map tile
  const TILE_SIZE = 8;

  // Some pre-calculated radian values
  const R0          =   0;
  const R45         =  45 * Math.PI / 180;
  const R90         =  90 * Math.PI / 180;

  // Frames per second (locked)
  //
  // Other constants below, like gravity, foot speed, etc., are represented as movement PER FRAME.
  const FPS = 42;

  // Player movement constants
  const PLAYER_FOOT_SPEED = 1.3;
  const JUMP_HEIGHT = 3.5 * TILE_SIZE;
  const JUMP_HEIGHT_DISTANCE = 2 * TILE_SIZE;

  // Gravity
  const GRAVITY = 2 * JUMP_HEIGHT * PLAYER_FOOT_SPEED * PLAYER_FOOT_SPEED / (JUMP_HEIGHT_DISTANCE * JUMP_HEIGHT_DISTANCE);
  const TERMINAL_VELOCITY = 5;

  // KeyboardAdapter


  const KeyboardAdapter = {
      init() {
          KeyboardAdapter.map = {
              KeyW:        Input.Action.UP,
              KeyA:        Input.Action.LEFT,
              KeyS:        Input.Action.DOWN,
              KeyD:        Input.Action.RIGHT,
              KeyV:        Input.Action.RECRUIT_VILLAGER,
              KeyB:        Input.Action.BUILD_BRIDGE,
              KeyT:        Input.Action.BUILD_HALL,
              Space:       Input.Action.JUMP,
              Enter:       Input.Action.CONTINUE,
              ArrowUp:     Input.Action.UP,
              ArrowLeft:   Input.Action.LEFT,
              ArrowDown:   Input.Action.DOWN,
              ArrowRight:  Input.Action.RIGHT,
              Escape:      Input.Action.MENU
          };

          // For keyboard, we support 8-point movement (S, E, SE, etc.)
          KeyboardAdapter.arrowDirections = [
              { x:   R0, y:   R0, m: 0 },
              { x:   R0, y: -R90, m: 1 },
              { x:   R0, y:  R90, m: 1 },
              { x:   R0, y:   R0, m: 0 },
              { x: -R90, y:   R0, m: 1 },
              { x: -R45, y: -R45, m: 1 },
              { x: -R45, y:  R45, m: 1 },
              { x: -R90, y:   R0, m: 1 },
              { x:  R90, y:   R0, m: 1 },
              { x:  R45, y: -R45, m: 1 },
              { x:  R45, y:  R45, m: 1 },
              { x:  R90, y:   R0, m: 1 },
              { x:   R0, y:   R0, m: 0 },
              { x:   R0, y: -R90, m: 1 },
              { x:   R0, y:  R90, m: 1 },
              { x:   R0, y:   R0, m: 0 }
          ];

          KeyboardAdapter.held = [];

          window.addEventListener('keydown', event => {
              let k = KeyboardAdapter.map[event.code];
              // Uncomment to debug key presses
              // console.log(event.key, event.keyCode, event.code, k);

              // Hack to ensure we initialize audio after user interacts with game
              Audio.initContext();

              if (k) {
                  KeyboardAdapter.held[k] = true;
              }
          });

          window.addEventListener('keyup', event => {
              let k = KeyboardAdapter.map[event.code];
              if (k) {
                  KeyboardAdapter.held[k] = false;
              }

              if (event.key >= '1' && event.key <= '9') {
                  game.nextLevel = Number(event.key) - 1;
                  game.screens.pop();
              }
          });

          KeyboardAdapter.reset();
      },

      update() {
          // For keyboards, we want to convert the state of the various arrow keys being held down
          // into a directional vector. We use the browser's event to handle the held state of
          // the other action buttons, so we don't need to process them here.
          let state =
              (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +
              (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +
              (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +
              (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);

          KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];
      },

      reset() {
          KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[0];
          for (let action of Object.values(Input.Action)) {
              KeyboardAdapter.held[action] = false;
          }
      }
  };

  // Input


  const Input = {
      // Game Inputs
      //
      // Note that moving the player around is actually not considered an action; it's
      // a separate non-action input called "direction". It just so happens that on
      // keyboard, for example, pressing the "down arrow" key is considered both a
      // press of the in-game DOWN action and a directional input. It's up to the input
      // consumer to decide which input is relevant (if any). For example, on a menu,
      // we may consume the DOWN/UP actions to navigate the menu, but ignore directional
      // inputs.
      //
      Action: {
          UP: 11,
          DOWN: 12,
          LEFT: 13,
          RIGHT: 14,
          RECRUIT_VILLAGER: 101,
          BUILD_BRIDGE: 102,
          BUILD_HALL: 103,
          JUMP: 22,
          ATTACK: 21,
          RELOAD: 30,
          CONTINUE: 95,
          MENU: 96,
          MUSIC_TOGGLE: 97,
          SFX_TOGGLE: 98,
          RAW_TOUCH: 40,
          DRAG: 41,
          TAP: 42
      },

      init() {
          // A vector representing the direction the user is pressing/facing,
          // separate from pressing and releasing inputs. Treating "direction"
          // separately makes it easier to handle gamepad sticks.
          this.direction = { x: 0, y: 0, m: 0 };

          // "Pressed" means an input was pressed THIS FRAME.
          this.pressed = {};

          // "Released" means an input was released THIS FRAME.
          this.released = {};

          // "Held" means an input is held down. The input was "Pressed" either
          // this frame or in a past frame, and has not been "Released" yet.
          this.held = {};

          // How many frames was this input held down by the player. If [held]
          // is false, it represents how long the input was last held down.
          this.framesHeld = {};

          KeyboardAdapter.init();
      },

      update() {
          // We could have some kind of "input adapter toggle", but it's easier to just treat all inputs
          // as valid -- if you're pressing the "attack" button on either gamepad or keyboard, then you're
          // attacking. For directional input, we instead check whether there's movement on the thumbstick,
          // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.

          KeyboardAdapter.update();

          for (let action of Object.values(Input.Action)) {
              let held = KeyboardAdapter.held[action];
              this.pressed[action] = !this.held[action] && held;
              this.released[action] = this.held[action] && !held;

              if (this.pressed[action]) {
                  this.framesHeld[action] = 1;
              } else if (this.held[action] && held) {
                  this.framesHeld[action]++;
              }

              this.held[action] = held;
          }

          //this.pointer = pointerAdapter.pointer;
          this.direction = KeyboardAdapter.direction;
          //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;
      },

      onDown(action) {},
      onUp(action) {},
  };

  // Viewport


  /**
   * Viewport
   *
   * Represents the game display (for us, a canvas).
   */
  const Viewport = {
      init() {
          Viewport.canvas = document.getElementById('canvas');
          Viewport.ctx = Viewport.canvas.getContext('2d');
          Viewport.resize(true);
      },

      // Resize the canvas to give us approximately our desired game display size.
      //
      // Rather than attempt to explain it, here's a concrete example:
      //
      //     we start with a desired game dimension:   480x270px
      //          get the actual browser dimensions:  1309x468px
      //          factor in the display's DPR ratio:  2618x936px
      //         now calculate the horizontal scale:       5.45x
      //                     and the vertical scale:       3.46x
      //            our new offical game scaling is:        5.4x
      //       and our official viewport dimensions:   484x173px
      //
      // This approach emphasizes correct aspect ratio and maintains full-window rendering, at
      // the potential cost of limiting visibility of the game itself in either the X or Y axis.
      // If you use this approach, make sure your GUI can "float" (otherwise there may be whole
      // UI elements the player cannot see!).
      resize(force) {
          let dpr = window.devicePixelRatio,
              width = Viewport.canvas.clientWidth,
              height = Viewport.canvas.clientHeight,
              dprWidth = width * dpr,
              dprHeight = height * dpr;

          if (
              force ||
              Viewport.canvas.width !== dprWidth ||
              Viewport.canvas.height !== dprHeight
          ) {
              Viewport.canvas.width = dprWidth;
              Viewport.canvas.height = dprHeight;

              Viewport.scale = ((Math.min(dprWidth / TARGET_GAME_WIDTH, dprHeight / TARGET_GAME_HEIGHT) * 10) | 0) / 10;
              Viewport.width = Math.ceil(dprWidth / Viewport.scale);
              Viewport.height = Math.ceil(dprHeight / Viewport.scale);
              Viewport.center = {
                  u: (Viewport.width / 2) | 0,
                  v: (Viewport.height / 2) | 0
              };
              Viewport.clientWidth = width;
              Viewport.clientHeight = height;

              // Note: smoothing flag gets reset on every resize by some browsers, which is why
              // we do it here.
              Viewport.ctx.imageSmoothingEnabled = false;
          }

          // We do this every frame, not just on resize, due to browser sometimes "forgetting".
          Viewport.canvas.style.cursor = 'none';
      },

      fillViewportRect() {
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
      },

      isOnScreen(uv) {
          return uv.u >= 0 && uv.v >= 0 && uv.u < Viewport.width && uv.v < Viewport.height;
      }
  };

  function angle2vector(r, m) {
      return { x: Math.cos(r), y: Math.sin(r), m: m };
  }

  function vector2point(v) {
      return { x: v.x * (v.m), y: v.y * (v.m) };
  }

  function xy2qr(pos) {
      return { q: (pos.x / TILE_SIZE) | 0, r: (pos.y / TILE_SIZE) | 0 };
  }

  function clamp(value, min, max) {
      return value < min ? min : value > max ? max : value;
  }

  function rgba(r, g, b, a) {
      return `rgba(${r},${g},${b},${a})`;
  }

  function createCanvas(width, height) {
      let canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      let ctx = canvas.getContext('2d');
      return { canvas, ctx };
  }

  // Camera
  //
  // For now this is a very simple placeholder. Even if the camera never does
  // anything but follow the player, distinguishing between "where the player is"
  // and "what the map camera is looking at" is useful in other files.


  const Camera = {
      init() {
          this.pos = { x: 0, y: 0 };
          this.forceTarget = undefined;
          this.vel = { x: 0, y: 0 };
      },

      update() {
          if (this.forceTarget) {
              this.pos = this.forceTarget;

              /*
              let dist = vectorBetween(this.pos, this.forceTarget);

              if (dist.m < 1) {
                  this.forceTarget = undefined;
                  return;
              }

              dist.m = clamp(dist.m, 0, 2);

              let newVelocity = vector2point(dist);
              this.vel = {
                  x: (this.vel.x * 2 + newVelocity.x) / 3,
                  y: (this.vel.y * 2 + newVelocity.y) / 3
              };

              this.pos.x += this.vel.x;
              this.pos.y += this.vel.y;

              */
          }

          if (Input.pressed[Input.Action.RAW_TOUCH]) {
              this.dragStart = { ...this.pos };
          }

          if (Input.dragging) {
              this.pos = {
                  x: this.dragStart.x - Input.dragVector.x,
                  y: this.dragStart.y - Input.dragVector.y
              };
          }

          //this.pos = Game.player.pos;
          //this.pos = { x: 0, y: 0, z: 0 };
      }
  };

  // SpriteSheet

  /**
   * This module is generated by `gulp buildAssets`.
   */
  const SpriteSheet =
      /* <generated> */
  { bigarrow: [ [ 0, 0, 7, 13 ] ],
    bigarrows: [ [ 0, 13, 15, 8 ] ],
    bigpig:
     [ [ 0, 21, 15, 10 ],
       [ 15, 21, 15, 10 ],
       [ 30, 21, 15, 10 ],
       [ 45, 21, 15, 10 ],
       [ 60, 21, 15, 10 ],
       [ 75, 21, 15, 10 ] ],
    bleed:
     [ [ 0, 31, 9, 7 ],
       [ 9, 31, 9, 7 ],
       [ 18, 31, 9, 7 ],
       [ 27, 31, 9, 7 ],
       [ 36, 31, 9, 7 ],
       [ 45, 31, 9, 7 ],
       [ 54, 31, 9, 7 ],
       [ 63, 31, 9, 7 ] ],
    bridge: [ [ 0, 38, 31, 16 ], [ 31, 38, 31, 16 ] ],
    button: [ [ 0, 54, 9, 9 ], [ 9, 54, 9, 9 ], [ 18, 54, 9, 9 ] ],
    clouds: [ [ 0, 63, 28, 8 ], [ 28, 63, 28, 8 ], [ 56, 63, 28, 8 ], [ 84, 63, 28, 8 ] ],
    defeat:
     [ [ 0, 71, 320, 180 ],
       [ 320, 71, 320, 180 ],
       [ 640, 71, 320, 180 ],
       [ 960, 71, 320, 180 ],
       [ 1280, 71, 320, 180 ],
       [ 1600, 71, 320, 180 ],
       [ 1920, 71, 320, 180 ],
       [ 2240, 71, 320, 180 ],
       [ 2560, 71, 320, 180 ],
       [ 2880, 71, 320, 180 ],
       [ 3200, 71, 320, 180 ],
       [ 3520, 71, 320, 180 ],
       [ 3840, 71, 320, 180 ] ],
    dirt: [ [ 0, 251, 1, 1 ], [ 1, 251, 1, 1 ] ],
    explosiona: [ [ 0, 252, 13, 13 ], [ 13, 252, 13, 13 ], [ 26, 252, 13, 13 ] ],
    explosionb:
     [ [ 0, 265, 21, 33 ],
       [ 21, 265, 21, 33 ],
       [ 42, 265, 21, 33 ],
       [ 63, 265, 21, 33 ],
       [ 84, 265, 21, 33 ] ],
    factory: [ [ 0, 298, 20, 14 ], [ 20, 298, 20, 14 ] ],
    font4: [ [ 0, 312, 270, 12 ] ],
    hedgehog: [ [ 0, 324, 12, 8 ], [ 12, 324, 12, 8 ], [ 24, 324, 12, 8 ] ],
    helpscroll: [ [ 0, 332, 154, 37 ] ],
    icons: [ [ 0, 369, 8, 8 ], [ 8, 369, 8, 8 ], [ 16, 369, 8, 8 ], [ 24, 369, 8, 8 ] ],
    influencebar: [ [ 0, 377, 93, 10 ], [ 93, 377, 93, 10 ] ],
    jobselect: [ [ 0, 387, 120, 14 ], [ 120, 387, 120, 14 ] ],
    knight: [ [ 0, 401, 7, 11 ], [ 7, 401, 7, 11 ], [ 14, 401, 7, 11 ] ],
    littlepig:
     [ [ 0, 412, 10, 7 ], [ 10, 412, 10, 7 ], [ 20, 412, 10, 7 ], [ 30, 412, 10, 7 ] ],
    littlepigbox:
     [ [ 0, 419, 15, 11 ], [ 15, 419, 15, 11 ], [ 30, 419, 15, 11 ], [ 45, 419, 15, 11 ] ],
    particle: [ [ 0, 430, 1, 1 ], [ 1, 430, 1, 1 ], [ 2, 430, 1, 1 ] ],
    sanitybar: [ [ 0, 431, 18, 82 ], [ 18, 431, 18, 82 ], [ 36, 431, 18, 82 ] ],
    sign: [ [ 0, 513, 10, 9 ] ],
    smallarrows: [ [ 0, 522, 3, 5 ], [ 3, 522, 3, 5 ], [ 6, 522, 3, 5 ], [ 9, 522, 3, 5 ] ],
    star2: [ [ 0, 527, 7, 6 ] ],
    tilebg: [ [ 0, 533, 10, 10 ], [ 10, 533, 10, 10 ], [ 20, 533, 10, 10 ] ],
    tiles:
     [ [ 0, 543, 8, 8 ],
       [ 8, 543, 8, 8 ],
       [ 16, 543, 8, 8 ],
       [ 24, 543, 8, 8 ],
       [ 32, 543, 8, 8 ],
       [ 40, 543, 8, 8 ],
       [ 48, 543, 8, 8 ],
       [ 56, 543, 8, 8 ],
       [ 64, 543, 8, 8 ],
       [ 72, 543, 8, 8 ] ],
    villager: [ [ 0, 551, 15, 22 ] ],
    wip:
     [ [ 0, 573, 320, 180 ],
       [ 320, 573, 320, 180 ],
       [ 640, 573, 320, 180 ],
       [ 960, 573, 320, 180 ],
       [ 1280, 573, 320, 180 ],
       [ 1600, 573, 320, 180 ],
       [ 1920, 573, 320, 180 ],
       [ 2240, 573, 320, 180 ],
       [ 2560, 573, 320, 180 ],
       [ 2880, 573, 320, 180 ],
       [ 3200, 573, 320, 180 ],
       [ 3520, 573, 320, 180 ] ],
    base64:
     'data:image/png;base64,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' };
  /* </generated> */

  /**
   * Sprite
   *
   * Encapsulates loading sprite slices from the spritesheet, organizing them, and
   * modifying them or constructing using primitives. To save space, we use some techniques
   * like storing only a small slice of an image in the spritesheet, then using code
   * to duplicate it, add some randomness, etc.
   */
  const Sprite = {
      // This is an exception to the rule, loading the spritesheet is a special action that
      // happens BEFORE everything is initialized.
      loadSpritesheet(cb) {
          let image = new Image();
          image.onload = cb;
          image.src = SpriteSheet.base64;
          Sprite.sheet = image;
      },

      init() {
          Sprite.bigpig = [SpriteSheet.bigpig.map(initBasicSprite, { x: 7, y: 4 })];
          Sprite.bigpig.push(Sprite.bigpig[0].map(sprite => initDynamicSprite(flipHorizontal(sprite.img), sprite.anchor)));

          Sprite.littlepig = [SpriteSheet.littlepig.map(initBasicSprite)];
          Sprite.littlepig.push(Sprite.littlepig[0].map(sprite => initDynamicSprite(flipHorizontal(sprite.img), sprite.anchor)));

          Sprite.littlepigbox = SpriteSheet.littlepigbox.map(initBasicSprite, { x: 7, y: 5 });

          Sprite.wip = SpriteSheet.wip.map(initBasicSprite, { x: 0, y: 0 });

          Sprite.villager = SpriteSheet.villager.map(initBasicSprite, { x: 7, y: 21 });
          Sprite.button = SpriteSheet.button.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.sanitybar = SpriteSheet.sanitybar.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.influencebar = SpriteSheet.influencebar.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.smallarrows = SpriteSheet.smallarrows.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.jobselect = SpriteSheet.jobselect.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.bridge = SpriteSheet.bridge.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.helpscroll = SpriteSheet.helpscroll.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.bigarrows = SpriteSheet.bigarrows.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.icons = SpriteSheet.icons.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.factory = SpriteSheet.factory.map(initBasicSprite, { x: 0, y: 0 });
          Sprite.defeat = SpriteSheet.defeat.map(initBasicSprite, { x: 0, y: 0 });

          Sprite.explosiona = SpriteSheet.explosiona.map(initBasicSprite);
          Sprite.explosionb = SpriteSheet.explosionb.map(initBasicSprite);

          Sprite.particle = SpriteSheet.particle.map(initBasicSprite);

          Sprite.star2 = SpriteSheet.star2.map(initBasicSprite);

          Sprite.bleed = SpriteSheet.bleed.map(initBasicSprite, { x: 4, y: 0 });

          Sprite.knight = [SpriteSheet.knight.map(initBasicSprite, { x: 3, y: 6 })];
          Sprite.knight.push(Sprite.knight[0].map(sprite => initDynamicSprite(flipHorizontal(sprite.img), sprite.anchor)));
          Sprite.hedgehog = [SpriteSheet.hedgehog.map(initBasicSprite, { x: 5, y: 4 })];
          Sprite.hedgehog .push(Sprite.hedgehog[0].map(sprite => initDynamicSprite(flipHorizontal(sprite.img), sprite.anchor)));

          Sprite.bigarrow = SpriteSheet.bigarrow.map(initBasicSprite);
          Sprite.dirt = SpriteSheet.dirt.map(initBasicSprite);

          Sprite.sign = SpriteSheet.sign.map(initBasicSprite);

          // Base pixel font and icons (see `Text.init` for additional variations)
          Sprite.font = initBasicSprite(SpriteSheet.font4[0]);
          //Sprite.icon_mouse_lmb = initBasicSprite(SpriteSheet.icon_mouse[0]);
          //Sprite.icon_mouse_rmb = initBasicSprite(SpriteSheet.icon_mouse[1]);

          Sprite.clouds = SpriteSheet.clouds.map(initBasicSprite);

          // Enemies

          // Tiles
          Sprite.tiles = SpriteSheet.tiles.map(initBasicSprite);
          Sprite.tilebg = SpriteSheet.tilebg.map(initBasicSprite);
      },

      /**
       * A small helper that draws a sprite onto a canvas, respecting the anchor point of
       * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if
       * that's appropriate!
       */
      drawSprite(ctx, sprite, u, v) {
          ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);
      },

      drawViewportSprite(sprite, pos, rotation) {
          let { u, v } = this.viewportSprite2uv(
              sprite,
              pos
          );
          if (rotation) {
              Viewport.ctx.save();
              Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);
              Viewport.ctx.rotate(rotation);
              Viewport.ctx.drawImage(
                  sprite.img,
                  -sprite.anchor.x,
                  -sprite.anchor.y
              );
              Viewport.ctx.restore();
          } else {
              Viewport.ctx.drawImage(sprite.img, u, v);
          }
      },

      drawSmashedSprite(sprite, pos, height) {
          let { u, v } = this.viewportSprite2uv(
              sprite,
              pos
          );

          Viewport.ctx.drawImage(sprite.img, u - 1, v - height + sprite.img.height, sprite.img.width + 2, height);
      },

      viewportSprite2uv(sprite, pos) {
          return {
              u: pos.x - sprite.anchor.x - Camera.pos.x + Viewport.center.u,
              v: pos.y - sprite.anchor.y - Camera.pos.y + Viewport.center.v
          };
      }
  };

  // Sprite utility functions

  function initBasicSprite(data, opts) {
      return initDynamicSprite(loadCacheSlice(...data), opts);
  }

  function initDynamicSprite(source, opts) {
      let w = source.width,
          h = source.height;

      if (typeof opts !== 'object') {
          opts = {};
      }

      if (!opts.anchor) {
          opts.anchor = { x: (w / 2) | 0, y: (h / 2) | 0 };
      }

      if (!opts.bb) {
          opts.bb = [-opts.anchor.x, -opts.anchor.y, source.width, source.height];
      }

      return {
          img: source,
          ...opts
      };
  }

  function loadCacheSlice(x, y, w, h) {
      const source = Sprite.sheet;
      const sliceCanvas = createCanvas(w, h);
      sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);
      return sliceCanvas.canvas;
  }

  function flipHorizontal(source) {
      let canvas = createCanvas(source.width, source.height);
      canvas.ctx.translate(source.width, 0);
      canvas.ctx.scale(-1, 1);
      canvas.ctx.drawImage(source, 0, 0);
      return canvas.canvas;
  }

  // Text


  const C_WIDTH = 5;
  const C_HEIGHT = 5;
  const FONT_SHEET_C_WIDTH = 6;
  const FONT_SHEET_WIDTH = 270;
  const DEFAULT_C_SHIFT = 5;

  // Very simple variable-width font implementation. The characters in the font strip
  // are left-aligned in their 5x5 pixel boxes, so in order to have variable width,
  // we just need to note the characters that AREN'T full width. Anything not in
  // this list has full shift (5+1 = 6 pixels).
  const C_SHIFT = {
      10: 0, // LF (\n)
      32: 3, // Space ( )
      33: 3, // Bang (!)
      39: 2, // Apostrophe (')
      44: 3, // Comma (,)
      46: 3, // Period (.)
      47: 6, // Slash (/)
      73: 2, // I
      77: 6, // M
      84: 6, // T
      86: 6, // V
      87: 6, // W
      88: 6, // X
      89: 6, // Y
      109: 6, // m (up)
      111: 6, // o (down)
  };

  const C_ICONS = {};

  const Text = {
      init() {
          Text.white = Sprite.font.img;
          Text.black = recolor(Text.white, rgba(0, 0, 0, 1));
          Text.shadow = recolor(Text.white, rgba(44, 27, 46, 1));
          Text.tan = recolor(Text.white, rgba(209, 180, 140, 1));
          Text.pig = recolor(Text.white, rgba(227, 66, 98, 1));
          Text.duotone = recolorDuotone(Text.white, '#f2b63d', '#fff4e0');
          Text.duotone_red = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3', rgba(255, 0, 0, 0.7));
          Text.palette = [
              recolor(Text.white, '#0a1a2f'),
              recolor(Text.white, '#04373b'),
              recolor(Text.white, '#1a644c'),
              recolor(Text.white, '#40985c'),
              recolor(Text.white, '#d1cb95')
          ];
      },

      drawText(ctx, text, u, v, scale = 1, font = Text.duotone, shadow) {
          for (let c of this.charactersToDraw(text, scale)) {
              if (C_ICONS[c.c]) {
                  ctx.drawImage(
                      C_ICONS[c.c].img,
                      u + c.u,
                      v + c.v - (C_ICONS[c.c].img.height + 4) / 2
                  );
              } else {
                  let k = (c.c - 32) * FONT_SHEET_C_WIDTH;
                  if (shadow) {
                      ctx.drawImage(
                          shadow,
                          k % FONT_SHEET_WIDTH,
                          (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                          C_WIDTH,
                          C_HEIGHT,
                          u + c.u,
                          v + c.v + 1,
                          C_WIDTH * scale,
                          C_HEIGHT * scale
                      );
                  }
                  ctx.drawImage(
                      font,
                      k % FONT_SHEET_WIDTH,
                      (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                      C_WIDTH,
                      C_HEIGHT,
                      u + c.u,
                      v + c.v,
                      C_WIDTH * scale,
                      C_HEIGHT * scale
                  );
              }
          }
      },

      drawParagraph(ctx, text, u, v, width, scale = 1, font = Text.duotone, shadow) {
          const lines = this.breakParagraph(text, width, scale);

          for (let i = 0; i < lines.length; i++) {
              this.drawText(ctx, lines[i], u, v + i * (C_HEIGHT + 2) * scale, scale, font, shadow);
          }
      },

      breakParagraph(text, width, scale = 1) {
          const lines = [];
          let line = '';
          const words = text.split(' ');
          while (words.length > 0) {
              const lineWidth = this.measure(line + ' ' + words[0], scale).w;
              if (lineWidth > width) {
                  lines.push(line);
                  line = '';
              }
              line = line + ' ' + words.shift();
          }
          if (line.length > 0) {
              lines.push(line);
          }
          return lines;
      },

      measure(text, scale = 1) {
          let w = 0, h = 0;

          for (let c of this.charactersToDraw(text, scale)) {
              w = Math.max(w, c.u + (C_SHIFT[c.c] || DEFAULT_C_SHIFT) * scale);
              h = c.v + (C_HEIGHT + 2) * scale;
          }

          return { w, h };
      },

      *charactersToDraw(text, scale = 1) {
          let u = 0, v = 0;

          for (let idx = 0; idx < text.length; idx++) {
              let c = text.charCodeAt(idx);

              if (c === 10) {
                  u = 0;
                  v += (C_HEIGHT + 2) * scale;
                  continue;
              }

              yield { c, u, v };

              u += (C_SHIFT[c] || DEFAULT_C_SHIFT) * scale;
          }
      }
  };

  // Text utility functions

  function recolor(font, color) {
      let canvas = createCanvas(font.width, font.height);
      canvas.ctx.fillStyle = color;
      canvas.ctx.fillRect(0, 0, font.width, font.height);
      canvas.ctx.globalCompositeOperation = 'destination-in';
      canvas.ctx.drawImage(font, 0, 0);
      return canvas.canvas;
  }

  function recolorDuotone(font, topColor, bottomColor, tint) {
      // Note: shortcut assumes that the font image is exactly 2 rows of characters.
      let canvas = createCanvas(font.width, font.height);
      canvas.ctx.fillStyle = bottomColor;
      canvas.ctx.fillRect(0, 0, font.width, font.height);
      canvas.ctx.fillStyle = topColor;
      canvas.ctx.fillRect(0, 0, font.width, 1);
      canvas.ctx.fillRect(0, C_HEIGHT + 1, font.width, 1);
      if (tint) {
          canvas.ctx.fillStyle = tint;
          canvas.ctx.fillRect(0, 0, font.width, font.height);
      }
      canvas.ctx.globalCompositeOperation = 'destination-in';
      canvas.ctx.drawImage(font, 0, 0);
      return canvas.canvas;
  }

  // LoadingScene


  class LoadingScene {
      constructor() {
          this.text = [
              'HAROLD',
              'IS',
              'HEAVY'
          ];
          this.t = -12;
      }

      update() {
          this.t++;

          if (this.t === 36) ;

          if (this.t > 15) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = '#2c1b2e';
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          Viewport.ctx.fillStyle = '#457cd6';
          Viewport.ctx.fillRect(Viewport.width / 2 - 65, Viewport.height / 2 - 8, 130, 16);
          Viewport.ctx.fillRect(Viewport.width / 2 - 64, Viewport.height / 2 - 9, 128, 18);

          let total = 10;
          let loaded = clamp(this.t / 6, 0, 10);

          for (let i = 0; i < total; i++) {
              let frame = (loaded > i) ? 0 : 3;
              let y = Math.sin(i * Math.PI * 2 / 9 + (this.t * Math.PI * 2 / 60)) * 3;
              Viewport.ctx.drawImage(Sprite.littlepig[0][frame].img, i * 12 + (Viewport.width - 120) / 2, Viewport.height / 2 - 3 + y);
          }

          this.drawInstructions();
      }

      drawInstructions() {
          let text = 'LOADING...';
          let width = Text.measure(text, 1).w;

          if (this.t % 30 < 24) {
              Text.drawText(Viewport.ctx, text, (Viewport.width - width) / 2, Viewport.height / 20 + 25, Text.duotone, Text.shadow);
          }
      }
  }

  // IntroScene


  class IntroScene {
      constructor() {
          this.text = [
              'HAROLD',
              'IS',
              'HEAVY'
          ];
          this.pos = [
              { y: -20 },
              { y: -20 },
              { y: -20 }
          ];
          this.vel = [
              { y: 0 },
              { y: 0 },
              { y: 0 }
          ];
          this.screenshakes = [];
          this.t = 0;
          this.fadet = -1;
      }

      update() {
          this.t++;

          if (this.t > 10) {
              game.scenes.pop();
              game.scenes.push(new LoadingScene());
          }

          /*
          this.vel[0].y = clamp(this.vel[0].y + GRAVITY, 0, TERMINAL_VELOCITY);
          if (this.pos[0].y > 15) {
              this.vel[1].y = clamp(this.vel[1].y + GRAVITY, 0, TERMINAL_VELOCITY);
          }
          if (this.pos[1].y > 15) {
              this.vel[2].y = clamp(this.vel[2].y + GRAVITY, 0, TERMINAL_VELOCITY);
          }

          if (this.pos[0].y < 45) {
              this.pos[0].y += this.vel[0].y;
          } else if (!this.screenshakes[0]) {
              this.screenshakes[0] = new ScreenShake(12, 0, 3);
          }
          if (this.pos[1].y < 60) {
              this.pos[1].y += this.vel[1].y;
          } else if (!this.screenshakes[1]) {
              this.screenshakes[1] = new ScreenShake(12, 0, 3);
          }
          if (this.pos[2].y < 75) {
              this.pos[2].y += this.vel[2].y;
          } else if (!this.screenshakes[2]) {
              this.screenshakes[2] = new ScreenShake(12, 0, 3);
          }
              */

          /*
          if (this.fadet >= 0) this.fadet++;

          if (this.fadet > 30) {
              game.screens.pop();
              game.screens.push(new LoadingScreen());
          }

          if (Input.pressed[Input.Action.JUMP] || Input.pressed[Input.Action.CONTINUE]) {
              this.fadet = 0;
          }

          for (let i = 0; i < 3; i++) {
              if (this.screenshakes[i]) {
                  this.screenshakes[i].update();
              }
          }*/
      }

      draw() {
          Viewport.ctx.fillStyle = '#457cd6';
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          let shakeX = 0, shakeY = 0;
          for (let i = 0; i < 3; i++) {
              if (this.screenshakes[i]) {
                  shakeX += this.screenshakes[i].x;
                  shakeY += this.screenshakes[i].y;
              }
          }
          Viewport.ctx.translate(shakeX, shakeY);

          for (let i = this.text.length - 1; i >= 0; i--) {
              let width = Text.measure(this.text[i], 2).w;

              //Viewport.ctx.globalAlpha = 0.3;
              //Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 50 + i * 15 - 4, 2, Text.pig);

              Viewport.ctx.globalAlpha = 1;
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, this.pos[i].y - 1, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, this.pos[i].y + 1, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2 - 1, this.pos[i].y, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2 + 1, this.pos[i].y, 2, Text.shadow);
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, this.pos[i].y, 2, Text.pig);
          }

          if (this.pos[2].y > 50) {
              this.drawInstructions();
          }

          // Fade to load screen
          if (this.fadet >= 0) {
              let fade = 0;
              if (this.fadet > 8) {
                  fade = (this.fadet - 8) * (Viewport.width / 2 - 40) / 20;
              }

              Viewport.ctx.fillStyle = '#2c1b2e';
              Viewport.ctx.beginPath();
              Viewport.ctx.moveTo(Viewport.width / 2 - 0 - fade, 0);
              Viewport.ctx.lineTo(Viewport.width / 2 + 40 + fade, 0);
              Viewport.ctx.lineTo(Viewport.width / 2 + 0 + fade, Viewport.height);
              Viewport.ctx.lineTo(Viewport.width / 2 - 40 - fade, Viewport.height);
              Viewport.ctx.closePath();
              Viewport.ctx.fill();
          }
      }

      drawInstructions() {
          let text = 'PRESS SPACE OR ENTER TO START';
          let width = Text.measure(text, 1).w;

          if (this.t % 30 < 24) {
              Text.drawText(Viewport.ctx, text, (Viewport.width - width) / 2, Viewport.height - 10, 1, Text.white, Text.shadow);
          }
      }
  }

  // BigArrowParticle


  class BigArrowParticle {
      constructor(pos) {
          this.frame = 0;
          this.pos = { ...pos };
          this.t = 0;
          this.d = 15;
          this.z = 5;

          // TEMPORARY
          this.noClipEntity = true;
          this.noClipWall = true;
      }

      update() {
          if (++this.t === this.d) this.cull = true;
          this.pos.y += 1;
      }

      draw() {
          Viewport.ctx.globalAlpha = 0.6;
          Sprite.drawViewportSprite(Sprite.bigarrow[this.frame], this.pos);
          Viewport.ctx.globalAlpha = 1;
      }
  }

  // CloudParticle
  //
  // Cloud particles slowly move across the top of the screen. They are drawn
  // a bit different because their coordinate system is the screen, not the map.


  class CloudParticle {
      constructor(middle) {
          let velDice = Math.floor(Math.random() * 3);
          let velX = [0.1, 0.2, 0.3];

          this.frame = Math.floor(Math.random() * 4);
          this.pos = {
              x: middle ? Viewport.width / 2 + Math.random() * 40 : Viewport.width + 1,
              y: Math.floor(Math.random() * 30 + 2)
          };
          this.vel = {
              x: 0 - velX[velDice],
              y: 0
          };
          this.z = -1;

          // TEMPORARY
          this.noClipWall = true;
          this.noClipEntity = true;
      }

      update() {
          if (this.pos.x < -30) this.cull = true;
      }

      draw() {
          // Our "x,y" is ACTUALLY a "u,v", which is a bit confusing... clouds don't move with
          // the tileset in this game.
          Viewport.ctx.drawImage(Sprite.clouds[this.frame].img, this.pos.x, this.pos.y);
      }
  }

  // FallingDirtParticle
  //
  // A falling dirt particle is spawned only beneath tiles that are super-slammable
  // (can be pushed down by the player), whenever the player lands.


  class FallingDirtParticle {
      constructor(pos) {
          this.frame = Math.floor(Math.random() * 2);
          this.pos = { ...pos };
          this.t = 0;
          this.d = 15;
          this.z = 4;

          // TEMPORARY
          this.noClipEntity = true;
          this.noClipWall = true;
      }

      update() {
          if (++this.t === this.d) this.cull = true;
          this.pos.y += 0.5;
      }

      draw() {
          Viewport.ctx.globalAlpha = 1;
          Sprite.drawViewportSprite(Sprite.dirt[this.frame], this.pos);
      }
  }

  // LandingParticle


  class LandingParticle {
      constructor(pos) {
          this.pos = { ...pos };
          this.angle = (Math.random() * Math.PI * 0.8) + Math.PI * 1.1;
          this.vel = vector2point(angle2vector(this.angle, 1.5));
          this.pos.x += this.vel.x * 3;
          this.pos.y += 5;
          this.vel.x /= 10;
          this.z = 12;

          this.radius = 1;
          this.r = 0;
          this.t = -1;
          this.d = 12;

          // TEMPORARY
          this.noClipWall = true;
          this.noClipEntity = true;
      }

      update() {
          if (++this.t === this.d) this.cull = true;
          this.vel.x *= 0.99;
          this.vel.y = clamp(this.vel.y + GRAVITY / 2, -TERMINAL_VELOCITY, TERMINAL_VELOCITY);
          //this.a *= 0.99;
          //this.r += this.a;
      }

      draw() {
          Sprite.drawViewportSprite(Sprite.particle[0], this.pos, this.r);
      }
  }

  // Button


  class Button {
      constructor(u, v, hotkey, text) {
          this.u = u;
          this.v = v;
          this.hotkey = hotkey;
          this.text = text;
          this.visible = false;
          this.active = false;
      }

      update() {
          if (!this.visible) return;
      }

      draw() {
          if (!this.visible) return;

          const frame = this.active ? 0 : 2;
          const colorIndex = this.active ? 4 : 2;
          const bgColorIndex = this.active ? 0 : 2;
          Viewport.ctx.drawImage(Sprite.button[frame].img, this.u, this.v);
          Text.drawText(Viewport.ctx, this.hotkey, this.u + 2, this.v + 2, 1, Text.palette[bgColorIndex]);
          Text.drawText(Viewport.ctx, this.text.toUpperCase(), this.u + 11, this.v + 2, 1, Text.palette[colorIndex]);
      }
  }

  // TweenChain

  class TweenChain {
      constructor(tweenArray) {
          this.t = -1;
          this.tweenArray = tweenArray;
      }

      update() {
          this.t++;

          if (this.t < this.tweenArray[0].t1) {
              this.value = this.tweenArray[0].v1;
              return;
          }

          if (this.t >= this.tweenArray[this.tweenArray.length - 1].t2) {
              this.value = this.tweenArray[this.tweenArray.length - 1].v2;
              this.finished = true;
              console.log('finishing');
              return;
          }

          for (let i = 0; i < this.tweenArray.length; i++) {
              if (this.t >= this.tweenArray[i].t1 && this.t < this.tweenArray[i].t2) {
                  this.value = (this.tweenArray[i].v2 - this.tweenArray[i].v1)
                      * (this.t - this.tweenArray[i].t1)
                      / (this.tweenArray[i].t2 - this.tweenArray[i].t1)
                      + this.tweenArray[i].v1;
                  break;
              }
          }
      }
  }

  // HeightMapData
  //
  // This file is generated by `gulp buildAssets`.

  const HeightMapData =
  /* <generated-data> */
  [ [ 0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0 ],
    [ 122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      122,
      121,
      120,
      120,
      120,
      120,
      120,
      120,
      119,
      119,
      119,
      119,
      118,
      118,
      117,
      117,
      117,
      117,
      117,
      116,
      116,
      116,
      116,
      116,
      116,
      115,
      115,
      115,
      115,
      115,
      115,
      115,
      114,
      114,
      114,
      114,
      114,
      113,
      113,
      113,
      113,
      113,
      113,
      113,
      113,
      112,
      112,
      112,
      112,
      112,
      112,
      111,
      111,
      110,
      110,
      110,
      110,
      110,
      109,
      109,
      108,
      108,
      108,
      107,
      107,
      107,
      107,
      107,
      107,
      107,
      107,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      106,
      107,
      107,
      108,
      108,
      109,
      109,
      110,
      110,
      110,
      110,
      110,
      111,
      112,
      114,
      115,
      116,
      117,
      117,
      118,
      118,
      118,
      119,
      119,
      119,
      119,
      119,
      119,
      119,
      119,
      119,
      119,
      119,
      120,
      121,
      122,
      123,
      124,
      125,
      126,
      127,
      128,
      128,
      128,
      128,
      128,
      128,
      128,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      129,
      128,
      128,
      128,
      128,
      127,
      126,
      124,
      126,
      125,
      125,
      123,
      123,
      124,
      125,
      126,
      126,
      125,
      124,
      124,
      125,
      124,
      124,
      122,
      120,
      118,
      118,
      120,
      121,
      123,
      124,
      123,
      122,
      120,
      120,
      121,
      123,
      116,
      109,
      101,
      101,
      100,
      100,
      99,
      99,
      99,
      99,
      98,
      98,
      98,
      98,
      98,
      97,
      97,
      97,
      96,
      96,
      95,
      95,
      94,
      89,
      83,
      77,
      76,
      75,
      74,
      73,
      73,
      72,
      71,
      71,
      70,
      63,
      56,
      48,
      47,
      45,
      44,
      42,
      40,
      39,
      38,
      37,
      37,
      38,
      39,
      41,
      42,
      44,
      45,
      46,
      47,
      49,
      50,
      51,
      58,
      65,
      71,
      72,
      72,
      73,
      73,
      74,
      74,
      75,
      76,
      77,
      78,
      78,
      79,
      79,
      80,
      81,
      81,
      82,
      83,
      83,
      87,
      91,
      95,
      95,
      95,
      96,
      96,
      96,
      97,
      97,
      98,
      98,
      99,
      100,
      101,
      102,
      103,
      104,
      108,
      115,
      116 ],
    [ 126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      127,
      128,
      128,
      129,
      129,
      129,
      130,
      130,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      132,
      132,
      132,
      132,
      132,
      132,
      133,
      133,
      133,
      133,
      133,
      134,
      134,
      135,
      136,
      136,
      137,
      138,
      138,
      139,
      139,
      139,
      140,
      140,
      140,
      140,
      139,
      139,
      139,
      139,
      139,
      139,
      138,
      138,
      138,
      138,
      138,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      139,
      139,
      139,
      139,
      140,
      140,
      141,
      141,
      141,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      145,
      145,
      145,
      145,
      145,
      145,
      145,
      146,
      145,
      145,
      145,
      145,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143 ],
    [ 149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      148,
      148,
      148,
      148,
      148,
      148,
      147,
      147,
      147,
      146,
      146,
      146,
      145,
      145,
      144,
      144,
      144,
      143,
      143,
      142,
      141,
      141,
      141,
      140,
      140,
      140,
      139,
      139,
      139,
      139,
      139,
      138,
      138,
      138,
      138,
      138,
      138,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      136,
      136,
      136,
      135,
      135,
      135,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      135,
      135,
      135,
      136,
      136,
      136,
      137,
      137,
      137,
      137,
      137,
      137,
      138,
      138,
      138,
      138,
      139,
      139,
      139,
      139,
      140,
      140,
      140,
      140,
      141,
      141,
      141,
      141,
      142,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      145,
      145,
      146,
      145,
      145,
      145,
      145,
      145,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      145,
      146,
      146,
      147,
      147,
      148,
      148,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      148,
      148,
      149,
      149,
      149,
      149,
      150,
      150,
      150,
      150,
      151,
      151,
      152,
      152,
      152,
      153,
      153,
      153,
      154,
      154,
      154,
      154,
      154,
      154,
      153,
      153,
      153,
      153,
      152,
      152,
      152,
      152,
      151,
      151,
      151,
      151,
      151,
      151,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149 ] ]
  /* </generated-data> */
  ;

  // Villager


  const IDLE = 0;
  const WOODCUTTER = 1;
  const BUTCHER = 2;
  const TALLOWER = 3;
  const STONECUTTER = 4;
  const FIREKEEPER = 5;
  const TOTEMCARVER = 6;

  class IdleTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 30, v1: 0, v2: 0 }
          ]);
      }

      completeTask() { }
  }

  class ButcherTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: -90 },
              { t1: 120, t2: 180, v1: -90, v2: -90 },
              { t1: 180, t2: 300, v1: -90, v2: 0 }
          ]);
      }

      completeTask() {
          game.gameScene.gatherMeat();
      }
  }

  class WoodcutterTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: 130 },
              { t1: 120, t2: 180, v1: 130, v2: 130 },
              { t1: 180, t2: 300, v1: 130, v2: 0 }
          ]);
      }

      completeTask() {
          game.gameScene.gatherWood();
      }
  }

  class TallowerTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: 47 },
              { t1: 120, t2: 180, v1: 47, v2: 47 },
              { t1: 180, t2: 300, v1: 47, v2: 0 }
          ]);
      }

      completeTask() {
          game.gameScene.craftTorch();
      }
  }

  class StonecutterTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: -141 },
              { t1: 120, t2: 180, v1: -141, v2: -141 },
              { t1: 180, t2: 300, v1: -141, v2: 0 }
          ]);
      }

      completeTask() {
          game.gameScene.gatherStone();
      }
  }

  class Villager {
      static JOB_NAMES = ['', 'WOODCUTTER', 'BUTCHER', 'TALLOWER', 'STONEMASON', 'FIREKEEPER', 'TOTEMCARVER'];

      constructor(job) {
          this.job = job;
          this.t = 0;
      }

      update() {
          if (!this.task) {
              this.task = this.newTask();
          }

          this.task.update();

          this.pos = { u: 160 + this.task.value, v: 100 };

          if (this.task.finished) {
              this.task.completeTask();
              this.task = undefined;
          }
      }

      draw() {
          let v = HeightMapData[3][Math.floor(this.pos.u)] - 32 - 16;
          Viewport.ctx.drawImage(Sprite.villager[0].img, this.pos.u, v);
      }

      newTask() {
          switch (this.job) {
              case BUTCHER:
                  return new ButcherTask();
              case WOODCUTTER:
                  return new WoodcutterTask();
              case TALLOWER:
                  return new TallowerTask();
              case STONECUTTER:
                  return new StonecutterTask();
              default:
                  return new IdleTask();
          }
      }
  }

  // TextFloatParticle


  class TextFloatParticle {
      constructor(pos, text, paletteRange) {
          this.pos = { ...pos };
          this.text = text;
          this.paletteRange = paletteRange;
          this.t = -1;
          this.d = 30;
      }

      update() {
          if (++this.t === this.d) this.cull = true;
          this.pos.v -= 0.2;
          this.paletteColor = Math.round((this.paletteRange[1] - this.paletteRange[0]) * (this.t/this.d) + this.paletteRange[0]);
      }

      draw() {
          Text.drawText(Viewport.ctx, this.text, this.pos.u, this.pos.v, 1, Text.palette[this.paletteColor]);
      }
  }

  // HelpScene


  class HelpScene {
      static HELP_SANITY = 0;

      static Scenes = {
          [HelpScene.HELP_SANITY]:{
          text: 'The villagers are frail, and their sanity is fragile. Free the village before it runs out.'.toUpperCase(),
          uScroll: 120,
          vScroll: 30,
          uArrow: 278,
          vArrow: 38
      }
      };

      constructor(helpStep) {
          this.helpStep = helpStep;
          this.scene = HelpScene.Scenes[helpStep];
      }

      update() {
          if (Input.pressed[Input.Action.JUMP] || Input.pressed[Input.Action.CONTINUE]) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = rgba(0, 0, 0, 0.66);
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          Viewport.ctx.drawImage(Sprite.helpscroll[0].img, this.scene.uScroll, this.scene.vScroll);
          Text.drawParagraph(Viewport.ctx, 'The villagers are frail, and their sanity is fragile. Free the village before it runs out.'.toUpperCase(), this.scene.uScroll + 4, this.scene.vScroll + 3, 140, 1, Text.palette[4]);

          Viewport.ctx.drawImage(Sprite.bigarrows[0].img, this.scene.uArrow, this.scene.vArrow);

          if (this.helpStep === HelpScene.HELP_SANITY) {
              game.gameScene.drawSanityBar();
          }

          return;
      }
  }

  // DefeatScene


  class DefeatScene {
      constructor(stats) {
          this.stats = stats;

          this.text = [
              'THE LAST SPARK OF SANITY FADES IN ULTHAR, AND WITH IT',
              'ANY HOPE OF DELIVERANCE FOR YOU AND YOUR KIN.',
              '',
              'WOOD GATHERED: ' + this.stats.woodGathered,
              'MEAT BUTCHERED: ' + this.stats.meatGathered,
              'TORCHES CRAFTED: ' + this.stats.torchesCrafted,
              'STONE MINED: ' + this.stats.stoneGathered,
              'SECONDS SURVIVED: ' + this.stats.seconds
          ];
          this.frames = 0;
      }

      update() {
          this.frames++;

          if (Input.pressed[Input.Action.JUMP]) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.drawImage(Sprite.defeat[12].img, 0, 0);

          for (let i = 0; i < this.text.length; i++) {
              let width = Text.measure(this.text[i], 1).w;
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 30 + i * 10, 1, Text.white, Text.shadow);
          }
      }
  }

  // GameScene


  const BUTTON_RECRUIT_VILLAGER = 0;
  const BUTTON_REPAIR_BRIDGE = 1;
  const BUTTON_REPAIR_HALL = 2;

  class GameScene {
      constructor() {
          game.gameScene = this;
          this.entities = [];
          this.screenshakes = [];

          // Clock
          this.t = 0;
          this.influence = 5;
          this.sanity = 100;

          // Inventory
          this.meat = 0;
          this.wood = 0;
          this.stone = 0;
          this.torches = 0;

          // Playthrough Stats
          this.meatGathered = 0;
          this.woodGathered = 0;
          this.stoneGathered = 0;
          this.villagersRecruited = 0;
          this.torchesCrafted = 0;

          this.buttons = [];
          //this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button(20, 140, 'V', 'Recruit Villager');
          this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button((320-80)/2, 15, 'V', 'Recruit Villager');
          this.buttons[BUTTON_REPAIR_BRIDGE] = new Button(240, 100, 'B', 'REPAIR BRIDGE');
          this.buttons[BUTTON_REPAIR_HALL] = new Button(240, 100, 'T', 'REPAIR TALLOW HALL');

          this.selectedJob = WOODCUTTER;
          this.jobsDisplayed = [WOODCUTTER];

          this.villagers = [];
          this.villagersWithJob = [];
          this.villagersWithJob[IDLE] = [];
          this.villagersWithJob[BUTCHER] = [];
          this.villagersWithJob[WOODCUTTER] = [];
          this.villagersWithJob[TALLOWER] = [];
          this.villagersWithJob[STONECUTTER] = [];
          this.villagersWithJob[FIREKEEPER] = [];
          this.villagersWithJob[TOTEMCARVER] = [];

          this.techBridge = false;
          this.techTorches = false;
          this.techStone = false;
      }

      update() {
          // Set up displayed jobs
          if (this.techStone) {
              this.jobsDisplayed = [BUTCHER, WOODCUTTER, TALLOWER, STONECUTTER];
          } else if (this.techTorches) {
              this.jobsDisplayed = [BUTCHER, WOODCUTTER, TALLOWER];
          } else if (this.techBridge) {
              this.jobsDisplayed = [BUTCHER, WOODCUTTER];
          } else {
              this.jobsDisplayed = [WOODCUTTER];
          }

          if (this.torches > 0 && !this.techStone) {
              this.techStone = true;
          }

          // Player input

                  // move
          ///this.pos.x += this.vel.x;
          ///this.pos.y += this.vel.y;

          if (Input.pressed[Input.Action.RECRUIT_VILLAGER]) {
              console.log(this.recruitVillager());
          }

          if (Input.pressed[Input.Action.BUILD_BRIDGE]) {
              console.log(this.buildBridge());
          }

          if (Input.pressed[Input.Action.BUILD_HALL]) {
              console.log(this.buildHall());
          }

          if (Input.pressed[Input.Action.DOWN]) {
              this.moveJobSelector(1);
          }

          if (Input.pressed[Input.Action.UP]) {
              this.moveJobSelector(-1);
          }

          if (Input.pressed[Input.Action.RIGHT]) {
              console.log(this.hireVillager(this.selectedJob));
          }

          if (Input.pressed[Input.Action.LEFT]) {
              console.log(this.fireVillager(this.selectedJob));
          }

          if (Input.pressed[Input.Action.JUMP]) {
              this.sanity -= 10;
          }

          // Game ticks

          this.t++;

          if (!this.nextSanityTick) {
              this.nextSanityTick = this.t + 12;
          }

          if (this.t >= this.nextSanityTick) {
              this.sanity -= 0.2;
              this.influence += 0.2;
              this.nextSanityTick = this.t + 12;
          }

          if (this.t === 4) ;

          // Button UI Elements

          this.buttons[BUTTON_RECRUIT_VILLAGER].active = (this.influence >= this.nextWorkerCost());
          this.buttons[BUTTON_RECRUIT_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_RECRUIT_VILLAGER].active);

          this.buttons[BUTTON_REPAIR_BRIDGE].active = (this.wood >= 10);
          this.buttons[BUTTON_REPAIR_BRIDGE].visible = !this.techBridge && this.wood >= 10;

          this.buttons[BUTTON_REPAIR_HALL].active = (this.wood >= 10);
          this.buttons[BUTTON_REPAIR_HALL].visible = this.techBridge && !this.techTorches && this.wood >= 10;

          // Villagers

          for (const villager of this.villagers) {
              villager.update();
          }

          // Entities

          for (const entity of this.entities) {
              entity.update();
          }

          this.entities = this.entities.filter(entity => !entity.cull);

          if (this.sanity < 0) {
              this.playerLost();
          }

          return;
      }

      draw() {
          Viewport.ctx.fillStyle = '#0a1a2f';
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          Viewport.ctx.drawImage(Sprite.wip[11].img, 0, -30);

          if (this.techBridge) {
              Viewport.ctx.drawImage(Sprite.bridge[1].img, 112, 133 - 32);
          } else {
              Viewport.ctx.drawImage(Sprite.bridge[0].img, 112, 133 - 32);
          }

          if (this.techTorches) {
              Viewport.ctx.drawImage(Sprite.factory[1].img, 198, 133 - 32);
          } else {
              Viewport.ctx.drawImage(Sprite.factory[0].img, 198, 133 - 32);
          }

          {
              let crunk = String(Math.floor(this.sanity)) + ',' + String(Math.floor(this.influence)) + ',' + String(this.villagers.length);
              Text.drawText(Viewport.ctx, crunk, 3, 3, 1, Text.palette[1]);
          }

          for (const villager of this.villagers) {
              villager.draw();
          }

          for (const button of this.buttons) {
              button.draw();
          }

          this.drawSanityBar();
          this.drawInfluenceBar();
          this.drawJobSelectUI();
          this.drawInventory();

          for (const entity of this.entities) {
              entity.draw();
          }

          // Preview walking path
          /*for (let x = 0; x < 320; x++) {
              Viewport.ctx.drawImage(Sprite.icons[1].img, x, HeightMapData[3][x]);
          }*/

          return;
      }


      drawSanityBar() {
          let k = Math.floor((this.sanity / 100) * 78);
          Viewport.ctx.drawImage(Sprite.sanitybar[0].img, 320-18-5, -3);
          Viewport.ctx.drawImage(Sprite.sanitybar[1].img, 320-18-5, -3);
          Viewport.ctx.drawImage(Sprite.sanitybar[2].img,
              0, 2 + (78 - k),
              18, k,
              320-18-5, -3 + 2 + (78 - k),
              18, k
          );
      }

      drawInfluenceBar() {
          let k = Math.floor(Math.min(this.influence / this.nextWorkerCost(), 1) * 80);
          Viewport.ctx.drawImage(Sprite.influencebar[0].img, (320-80)/2, 3);
          Viewport.ctx.drawImage(Sprite.influencebar[1].img,
              2, 3,
              k, 4,
              (320-80)/2 + 2, 3 + 3,
              k, 4
          );
      }

      drawJobSelectUI() {
          const cornerX = 7;
          const cornerY = 120;
          const verticalMargin = 10;

          let selectedIdx = 0;

          for (let i = 0; i < this.jobsDisplayed.length; i++) {
              if (this.selectedJob === this.jobsDisplayed[i]) {
                  selectedIdx = i;
              }

              const color = this.selectedJob === this.jobsDisplayed[i] ? Text.palette[3] : Text.palette[2];
              const numberText = String(this.villagersWithJob[this.jobsDisplayed[i]].length);
              const width = Text.measure(numberText).w;
              Text.drawText(Viewport.ctx, Villager.JOB_NAMES[this.jobsDisplayed[i]], cornerX + 5, cornerY + 4 + verticalMargin * i, 1, color);
              Text.drawText(Viewport.ctx, numberText, cornerX + 92 - width, cornerY + 4 + verticalMargin * i, 1, color);
          }

          const leftArrow = this.villagersWithJob[this.selectedJob].length > 0 ? 0 : 2;
          const rightArrow = this.villagersWithJob[IDLE].length > 0 ? 1 : 3;

          Viewport.ctx.drawImage(Sprite.jobselect[1].img, cornerX, cornerY + selectedIdx * verticalMargin);
          Viewport.ctx.drawImage(Sprite.smallarrows[leftArrow].img, cornerX + 77, cornerY + 4 + selectedIdx * verticalMargin);
          Viewport.ctx.drawImage(Sprite.smallarrows[rightArrow].img, cornerX + 94, cornerY + 4 + selectedIdx * verticalMargin);
      }

      drawInventory() {
          let woodWidth = Text.measure(String(this.wood), 1).w;
          let meatWidth = Text.measure(String(this.meat), 1).w;
          let stoneWidth = Text.measure(String(this.stone), 1).w;
          let torchWidth = Text.measure(String(this.torches), 1).w;

          Viewport.ctx.drawImage(Sprite.icons[0].img, INVENTORY_WOOD_POS.u - 60, INVENTORY_WOOD_POS.v - 1);
          Text.drawText(Viewport.ctx, 'WOOD', INVENTORY_WOOD_POS.u - 50, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);
          Text.drawText(Viewport.ctx, String(this.wood), INVENTORY_WOOD_POS.u - woodWidth, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);

          if (this.techBridge) {
              Viewport.ctx.drawImage(Sprite.icons[2].img, INVENTORY_MEAT_POS.u - 60, INVENTORY_MEAT_POS.v - 1);
              Text.drawText(Viewport.ctx, 'MEAT', INVENTORY_MEAT_POS.u - 50, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.meat), INVENTORY_MEAT_POS.u - meatWidth, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
          }

          if (this.techTorches) {
              Viewport.ctx.drawImage(Sprite.icons[3].img, INVENTORY_TORCH_POS.u - 60, INVENTORY_TORCH_POS.v - 1);
              Text.drawText(Viewport.ctx, 'TORCHES', INVENTORY_TORCH_POS.u - 50, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.torches), INVENTORY_TORCH_POS.u - torchWidth, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
          }

          if (this.techStone) {
              Viewport.ctx.drawImage(Sprite.icons[1].img, INVENTORY_STONE_POS.u - 60, INVENTORY_STONE_POS.v - 1);
              Text.drawText(Viewport.ctx, 'STONE', INVENTORY_STONE_POS.u - 50, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.stone), INVENTORY_STONE_POS.u - stoneWidth, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
          }

      }

      drawTiles() {
          return;
      }

      drawTileShakemap() {
          for (let r = 0; r < this.tileshakemap.length; r++) {
              for (let q = 0; q < this.tileshakemap[0].length; q++) {
                  this.tileshakemap[r][q].x = 0;
                  this.tileshakemap[r][q].y = 0;
              }
          }

          for (let i = 0; i < this.tileshakes.length; i++) {
              let tileshake = this.tileshakes[i];
              for (let tile of tileshake.tiles) {
                  //this.tileshakemap[tile.r][tile.q].x += tileshake.screenshake.x;
                  let k = 0;
                  if (tileshake.s < 9) k++;
                  if (tileshake.s < 6) k++;
                  if (tileshake.s < 4) k++;
                  if (tileshake.s < 2) k++;
                  this.tileshakemap[tile.r][tile.q].y += k;
              }
          }
      }

      tileIsPassable(q, r) {
          return true;
      }

      entityIsOnSolidGround(entity) {
          let qr = xy2qr({ x: entity.pos.x, y: entity.pos.y + entity.bb[1].y });

          return !this.tileIsPassable(qr.q, qr.r);
      }

      landedOnTile(tile, superslamFlag) {
          if (superslamFlag) {
              for (let i = 0; i < this.superslamTiles.length; i++) {
                  let slam = this.superslamTiles[i];
                  if (tile.r === slam.r && tile.q >= slam.q1 && tile.q <= slam.q2) {
                      for (let q = slam.q1; q <= slam.q2; q++) {
                          this.tiles[slam.r + 1][q] = this.tiles[slam.r][q];
                          this.tiles[slam.r][q] = this.tiles[slam.r + 1][q] === 5 ? 6 : 0;

                          let xy = this.player.pos;
                          this.addEntity(new BigArrowParticle({ x: xy.x, y: xy.y }));
                      }
                  }
              }
          }

          for (let entity of this.entities) {
              if (entity.landedOnTile) entity.landedOnTile(tile);
          }

          this.addEntity(new LandingParticle(this.player.pos));
          this.addEntity(new LandingParticle(this.player.pos));
          this.addEntity(new LandingParticle(this.player.pos));
          this.addEntity(new LandingParticle(this.player.pos));

          this.lightUpSlamTiles = 12;

          this.fallingDirtCounter = 4;
      }

      spawnFallingDirt() {
          for (let i = 0; i < this.superslamTiles.length; i++) {
              let slam = this.superslamTiles[i];
              if (!this.tileIsPassable(slam.q1, slam.r)) {
                  let x = (slam.q1 + Math.random() * (slam.q2 + 1 - slam.q1)) * TILE_SIZE;
                  let y = slam.r * TILE_SIZE + TILE_SIZE + 1;
                  this.addEntity(new FallingDirtParticle({ x: x, y: y }));
              }
          }
      }

      rescueLittlePig() {
          this.littlePigsRescued++;

          if (this.littlePigsRescued === this.littlePigs) {
              if (game.levelScreen.player.recording) {
                  game.lastReplay = game.levelScreen.player.recording;
              }
              game.nextLevel++;
              game.screens.pop();
              game.scores[this.levelNumber].time = this.t;
              game.scores[this.levelNumber].enemiesAlive = this.enemiesAlive;
          }
      }

      addEntity(entity) {
          if (!entity.z) {
              entity.z = 1;
          }

          for (let i = 0; i < this.entities.length; i++) {
              if (this.entities[i].z > entity.z) {
                  this.entities.splice(i, 0, entity);
                  return;
              }
          }

          this.entities.push(entity);
      }

      addScreenShake(screenshake) {
          // This screen shake applies to the entire rendered screen, including GUI
          this.screenshakes.push(screenshake);
      }

      addTileShake(screenshake, originQR) {
          let tiles = [];

          for (let q = originQR.q; q >= 0; q--) {
              if (this.tileIsPassable(q, originQR.r - 1) && !this.tileIsPassable(q, originQR.r)) {
                  tiles.push({ q: q, r: originQR.r });
              } else {
                  break;
              }
          }
          for (let q = originQR.q + 1; q < this.tiles[0].length; q++) {
              if (this.tileIsPassable(q, originQR.r - 1) && !this.tileIsPassable(q, originQR.r)) {
                  tiles.push({ q: q, r: originQR.r });
              } else {
                  break;
              }
          }

          this.tileshakes.push({
              screenshake: screenshake,
              tiles: tiles,
              s: 0
          });
      }

      extractSuperslamTiles(originQR) {
          let r = originQR.r;
          let q1 = originQR.q;
          let q2 = originQR.q;

          for (let q = originQR.q; q >= 0; q--) {
              if (this.tileIsPassable(q, originQR.r + 1) && !this.tileIsPassable(q, originQR.r)) {
                  q1 = q;
              } else {
                  break;
              }
          }
          for (let q = originQR.q + 1; q < this.tiles[0].length; q++) {
              if (this.tileIsPassable(q, originQR.r + 1) && !this.tileIsPassable(q, originQR.r)) {
                  q2 = q;
              } else {
                  break;
              }
          }

          return {
              r: r,
              q1: q1,
              q2: q2
          };
      }

      spawnClouds() {
          let clouds = this.entities.filter(entity => entity instanceof CloudParticle).length;
          if (clouds < 1) {
              this.addEntity(new CloudParticle());
              this.lastCloud = this.t;
          }

          if (this.t - this.lastCloud > 60 * 5 && Math.random() < 0.01) {
              this.addEntity(new CloudParticle());
              this.lastCloud = this.t;
          }
      }

      moveJobSelector(delta) {
          let idx = this.jobsDisplayed.indexOf(this.selectedJob);
          idx = (idx + delta + this.jobsDisplayed.length) % this.jobsDisplayed.length;
          this.selectedJob = this.jobsDisplayed[idx];
      }

      recruitVillager() {
          const cost = this.nextWorkerCost();
          if (this.influence >= cost) {
              this.influence -= cost;

              const villager = new Villager(this.selectedJob || WOODCUTTER);
              this.villagers.push(villager);
              this.villagersWithJob[villager.job].push(villager);
              this.villagersRecruited++;

              return true;
          }

          return false;
      }

      hireVillager() {
          if (this.villagersWithJob[IDLE].length > 0) {
              // TODO
              const villager = this.villagersWithJob[IDLE].pop();
              villager.job = this.selectedJob;
              this.villagersWithJob[this.selectedJob].push(villager);
              return true;
          }
          return false;
      }

      fireVillager() {
          if (this.villagersWithJob[this.selectedJob].length > 0) {
              // TODO
              const villager = this.villagersWithJob[this.selectedJob].pop();
              villager.job = IDLE;
              this.villagersWithJob[IDLE].push(villager);
              return true;
          }
          return false;
      }

      consumeMeat() {
          if (this.meat > 0) {
              this.meat--;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-1', [4, 2]));
          } else {
              this.sanity--;
              this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '-1', [0, 2]));
          }
      }

      gatherMeat() {
          this.meat += 5;
          this.meatGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '+5', [4, 2]));
      }

      gatherWood() {
          this.wood += 5;
          this.woodGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '+5', [4, 2]));
      }

      craftTorch() {
          this.torches += 1;
          this.torchesCrafted += 1;
          this.wood -= 2;
          this.meat -= 2;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_TORCH_POS.u + 6, v: INVENTORY_TORCH_POS.v }, '+1', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-2', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-2', [4, 2]));
      }

      gatherStone() {
          this.stone += 5;
          this.stoneGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: 100, v: 100 }, '+5', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '+5', [4, 2]));
      }

      buildBridge() {
          const button = this.buttons[BUTTON_REPAIR_BRIDGE];

          if (button.active && button.visible && this.wood >= 10 && !this.techBridge) {
              this.wood -= 10;
              this.techBridge = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

              // TODO build bridge animation
          }
      }

      buildHall() {
          const button = this.buttons[BUTTON_REPAIR_HALL];

          if (button.active && button.visible && this.wood >= 10 && !this.techTorches) {
              this.wood -= 10;
              this.techTorches = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

              // TODO build hall animation
          }
      }

      nextWorkerCost() {
          return Math.floor(1 * Math.pow(1.3, this.villagers.length));
      }

      playerLost() {
          const stats = {
              seconds: Math.floor(this.t / 60),
              woodGathered: this.woodGathered,
              meatGathered: this.meatGathered,
              torchesCrafted: this.torchesCrafted,
              stoneGathered: this.stoneGathered,
          };
          game.scenes.pop();
          game.scenes.push(new DefeatScene(stats));
      }
  }

  // Game


  /**
   * Game state.
   */
  class Game {
      init() {
          Sprite.loadSpritesheet(() => {
              Viewport.init();
              Sprite.init();
              Text.init();
              Input.init();
              Audio.init();

              Camera.init();

              window.addEventListener('blur', () => this.pause());
              window.addEventListener('focus', () => this.unpause());

              this.reset();
              this.start();
          });
      }

      reset() {
          this.scenes = [];
          this.lastFrame = 0;
          this.nextLevel = 0;

          this.scores = [
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 }
          ];

          this.scenes.push(new IntroScene());
      }

      start() {
          this.frame = 0;
          this.framestamps = [0];
          this.update();
          window.requestAnimationFrame((xyz) => this.onFrame(xyz));
      }

      onFrame(currentms) {
          let delta = (currentms - this.lastFrame) - (1000 / FPS);

          if (delta >= 0) {
              this.frame++;
              this.lastFrame = (currentms - delta);

              // The above calculation is right for smoothing out frames, but if
              // we end up far behind the currentms, we can "fast play" for a long time
              // which is not desired. Fast-forward if we fall behind more than 5 frames.
              if (currentms - this.lastFrame > 5 * 1000 / FPS) {
                  this.lastFrame = currentms;
              }

              Viewport.resize();
              this.update();
              this.draw(Viewport.ctx);

              // this.framestamps.push(currentms);
              // if (this.framestamps.length >= 120) {
              //     this.framestamps.shift();
              // }
              // this.fps = 1000 / ((this.framestamps[this.framestamps.length - 1] - this.framestamps[0]) / this.framestamps.length);
          }
          window.requestAnimationFrame((xyz) => this.onFrame(xyz));
      }

      update() {
          // Gather user input
          Input.update();

          // Handle special keys that are screen-independent
          if (Input.pressed[Input.Action.MUSIC_TOGGLE]) {
              Audio.musicEnabled = !Audio.musicEnabled;
          }
          if (Input.pressed[Input.Action.SFX_TOGGLE]) {
              Audio.sfxEnabled = !Audio.sfxEnabled;
          }

          // Hand off control to the current "screen" (for example, game screen or menu)
          if (this.scenes.length === 0) {
              this.scenes.push(new GameScene());
          }
          this.scene = this.scenes[this.scenes.length - 1];
          this.scene.update();

          // Do per-frame audio updates
          Audio.update();
      }

      draw() {
          // Reset canvas transform and scale
          Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);
          Viewport.ctx.scale(Viewport.scale, Viewport.scale);

          for (let i = 0; i < this.scenes.length; i++) {
              this.scenes[i].draw();
          }

          //Text.drawText(Viewport.ctx, String(this.fps), 15, 15, 1, Text.white);
      }

      pause() {
          if (this.paused) return;
          this.paused = true;
          Audio.pause();
      }

      unpause() {
          if (!this.paused) return;
          this.paused = false;
          Audio.unpause();
      }

      restartLevel() {
          this.scenes.pop();
      }

      speedrunScore() {
          let score = 100000;

          for (let i = 0; i < this.scores.length; i++) {
              score -= this.scores[i].time;
              score -= this.scores[i].enemiesAlive * 5 * 60;
          }

          let scoreText = String(score);
          if (scoreText.length > 3) {

              scoreText = scoreText.slice(0, scoreText.length - 3) + ',' + scoreText.slice(scoreText.length - 3);
          }

          return scoreText;
      }
  }

  const game = new Game();

  /**
   * Create and launch game.
   */
  game.init();

})();</script>