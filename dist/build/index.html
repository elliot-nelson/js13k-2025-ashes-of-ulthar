<meta charset="utf8"><style>body,html{width:100vw;height:100vh;margin:0;padding:0;background-color:#2c1b2e}#d1{width:100vw;height:100vh;display:flex;align-items:center;justify-content:center}#d2{max-width:100vw;max-height:100vh;aspect-ratio:48/27}#canvas{width:100%;height:100%}</style><div id="d1"><div id="d2"><canvas id="canvas"></canvas></div></div><script>(function () {
  'use strict';

  /*

  ZzFX - Zuper Zmall Zound Zynth v1.1.8
  By Frank Force 2019
  https://github.com/KilledByAPixel/ZzFX

  ZzFX Features

  - Tiny synth engine with 20 controllable parameters.
  - Play sounds via code, no need for sound assed files!
  - Compatible with most modern web browsers.
  - Small code footprint, the micro version is under 1 kilobyte.
  - Can produce a huge variety of sound effect types.
  - Sounds can be played with a short call. zzfx(...[,,,,.1,,,,9])
  - A small bit of randomness appied to sounds when played.
  - Use ZZFX.GetNote to get frequencies on a standard diatonic scale.
  - Sounds can be saved out as wav files for offline playback.
  - No additional libraries or dependencies are required.

  */
  /*

    ZzFX MIT License

    Copyright (c) 2019 - Frank Force

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.

  */


  // zzfx object with some extra functionalty
  const ZZFX = {
      // master volume scale
      volume: .3,

      // sample rate for audio
      sampleRate: 44100,

      // create shared audio context
      x: new (window.AudioContext || webkitAudioContext),

      destination: undefined,

      // play a sound from zzfx paramerters
      play: function(...parameters)
      {
          // build samples and start sound
          return this.playSamples(this.buildSamples(...parameters));
      },

      // play an array of samples
      playSamples: function(...samples)
      {
          // create buffer and source
          const buffer = this.x.createBuffer(samples.length, samples[0].length, this.sampleRate),
              source = this.x.createBufferSource();

          samples.map((d,i)=> buffer.getChannelData(i).set(d));
          source.buffer = buffer;
          source.connect(this.destination);
          source.start();
          return source;
      },

      // build an array of samples
      buildSamples: function
      (
          volume = 1,
          randomness = .05,
          frequency = 220,
          attack = 0,
          sustain = 0,
          release = .1,
          shape = 0,
          shapeCurve = 1,
          slide = 0,
          deltaSlide = 0,
          pitchJump = 0,
          pitchJumpTime = 0,
          repeatTime = 0,
          noise = 0,
          modulation = 0,
          bitCrush = 0,
          delay = 0,
          sustainVolume = 1,
          decay = 0,
          tremolo = 0
      )
      {
          // init parameters
          const PI2 = Math.PI*2;
          let sampleRate = this.sampleRate,
          sign = v => v>0?1:-1,
          startSlide = slide *= 500 * PI2 / sampleRate / sampleRate,
          startFrequency = frequency *=
              (1 + randomness*2*Math.random() - randomness) * PI2 / sampleRate,
          b=[], t=0, tm=0, i=0, j=1, r=0, c=0, s=0, f, length;

          // scale by sample rate
          attack = attack * sampleRate + 9; // minimum attack to prevent pop
          decay *= sampleRate;
          sustain *= sampleRate;
          release *= sampleRate;
          delay *= sampleRate;
          deltaSlide *= 500 * PI2 / sampleRate**3;
          modulation *= PI2 / sampleRate;
          pitchJump *= PI2 / sampleRate;
          pitchJumpTime *= sampleRate;
          repeatTime = repeatTime * sampleRate | 0;

          // generate waveform
          for(length = attack + decay + sustain + release + delay | 0;
              i < length; b[i++] = s)
          {
              if (!(++c%(bitCrush*100|0)))                      // bit crush
              {
                  s = shape? shape>1? shape>2? shape>3?         // wave shape
                      Math.sin((t%PI2)**3) :                    // 4 noise
                      Math.max(Math.min(Math.tan(t),1),-1):     // 3 tan
                      1-(2*t/PI2%2+2)%2:                        // 2 saw
                      1-4*Math.abs(Math.round(t/PI2)-t/PI2):    // 1 triangle
                      Math.sin(t);                              // 0 sin

                  s = (repeatTime ?
                          1 - tremolo + tremolo*Math.sin(PI2*i/repeatTime) // tremolo
                          : 1) *
                      sign(s)*(Math.abs(s)**shapeCurve) *       // curve 0=square, 2=pointy
                      volume * this.volume * (                  // envelope
                      i < attack ? i/attack :                   // attack
                      i < attack + decay ?                      // decay
                      1-((i-attack)/decay)*(1-sustainVolume) :  // decay falloff
                      i < attack  + decay + sustain ?           // sustain
                      sustainVolume :                           // sustain volume
                      i < length - delay ?                      // release
                      (length - i - delay)/release *            // release falloff
                      sustainVolume :                           // release volume
                      0);                                       // post release

                  s = delay ? s/2 + (delay > i ? 0 :            // delay
                      (i<length-delay? 1 : (length-i)/delay) *  // release delay
                      b[i-delay|0]/2) : s;                      // sample delay
              }

              f = (frequency += slide += deltaSlide) *          // frequency
                  Math.cos(modulation*tm++);                    // modulation
              t += f - f*noise*(1 - (Math.sin(i)+1)*1e9%2);     // noise

              if (j && ++j > pitchJumpTime)       // pitch jump
              {
                  frequency += pitchJump;         // apply pitch jump
                  startFrequency += pitchJump;    // also apply to start
                  j = 0;                          // stop pitch jump time
              }

              if (repeatTime && !(++r % repeatTime)) // repeat
              {
                  frequency = startFrequency;     // reset frequency
                  slide = startSlide;             // reset slide
                  j = j || 1;                     // reset pitch jump time
              }
          }

          return b;
      },

      // get frequency of a musical note on a diatonic scale
      getNote: function(semitoneOffset=0, rootNoteFrequency=440)
      {
          return rootNoteFrequency * 2**(semitoneOffset/12);
      }

  }; // ZZFX

  /* -*- mode: javascript; tab-width: 4; indent-tabs-mode: nil; -*-
  *
  * Copyright (c) 2011-2013 Marcus Geelnard
  *
  * This software is provided 'as-is', without any express or implied
  * warranty. In no event will the authors be held liable for any damages
  * arising from the use of this software.
  *
  * Permission is granted to anyone to use this software for any purpose,
  * including commercial applications, and to alter it and redistribute it
  * freely, subject to the following restrictions:
  *
  * 1. The origin of this software must not be misrepresented; you must not
  *    claim that you wrote the original software. If you use this software
  *    in a product, an acknowledgment in the product documentation would be
  *    appreciated but is not required.
  *
  * 2. Altered source versions must be plainly marked as such, and must not be
  *    misrepresented as being the original software.
  *
  * 3. This notice may not be removed or altered from any source
  *    distribution.
  *
  */


  // Some general notes and recommendations:
  //  * This code uses modern ECMAScript features, such as ** instead of
  //    Math.pow(). You may have to modify the code to make it work on older
  //    browsers.
  //  * If you're not using all the functionality (e.g. not all oscillator types,
  //    or certain effects), you can reduce the size of the player routine even
  //    further by deleting the code.


  const CPlayer = function() {

      //--------------------------------------------------------------------------
      // Private methods
      //--------------------------------------------------------------------------

      // Oscillators
      var osc_sin = function (value) {
          return Math.sin(value * 6.283184);
      };

      var osc_saw = function (value) {
          return 2 * (value % 1) - 1;
      };

      var osc_square = function (value) {
          return (value % 1) < 0.5 ? 1 : -1;
      };

      var osc_tri = function (value) {
          var v2 = (value % 1) * 4;
          if(v2 < 2) return v2 - 1;
          return 3 - v2;
      };

      var getnotefreq = function (n) {
          // 174.61.. / 44100 = 0.003959503758 (F3)
          return 0.003959503758 * (2 ** ((n - 128) / 12));
      };

      var createNote = function (instr, n, rowLen) {
          var osc1 = mOscillators[instr.i[0]],
              o1vol = instr.i[1],
              o1xenv = instr.i[3]/32,
              osc2 = mOscillators[instr.i[4]],
              o2vol = instr.i[5],
              o2xenv = instr.i[8]/32,
              noiseVol = instr.i[9],
              attack = instr.i[10] * instr.i[10] * 4,
              sustain = instr.i[11] * instr.i[11] * 4,
              release = instr.i[12] * instr.i[12] * 4,
              releaseInv = 1 / release,
              expDecay = -instr.i[13]/16,
              arp = instr.i[14],
              arpInterval = rowLen * (2 **(2 - instr.i[15]));

          var noteBuf = new Int32Array(attack + sustain + release);

          // Re-trig oscillators
          var c1 = 0, c2 = 0;

          // Local variables.
          var j, j2, e, rsample, o1t, o2t;

          // Generate one note (attack + sustain + release)
          for (j = 0, j2 = 0; j < attack + sustain + release; j++, j2++) {
              if (j2 >= 0) {
                  // Switch arpeggio note.
                  arp = (arp >> 8) | ((arp & 255) << 4);
                  j2 -= arpInterval;

                  // Calculate note frequencies for the oscillators
                  o1t = getnotefreq(n + (arp & 15) + instr.i[2] - 128);
                  o2t = getnotefreq(n + (arp & 15) + instr.i[6] - 128) * (1 + 0.0008 * instr.i[7]);
              }

              // Envelope
              e = 1;
              if (j < attack) {
                  e = j / attack;
              } else if (j >= attack + sustain) {
                  e = (j - attack - sustain) * releaseInv;
                  e = (1 - e) * (3 ** (expDecay * e));
              }

              // Oscillator 1
              c1 += o1t * e ** o1xenv;
              rsample = osc1(c1) * o1vol;

              // Oscillator 2
              c2 += o2t * e ** o2xenv;
              rsample += osc2(c2) * o2vol;

              // Noise oscillator
              if (noiseVol) {
                  rsample += (2 * Math.random() - 1) * noiseVol;
              }

              // Add to (mono) channel buffer
              noteBuf[j] = (80 * rsample * e) | 0;
          }

          return noteBuf;
      };


      //--------------------------------------------------------------------------
      // Private members
      //--------------------------------------------------------------------------

      // Array of oscillator functions
      var mOscillators = [
          osc_sin,
          osc_square,
          osc_saw,
          osc_tri
      ];

      // Private variables set up by init()
      var mSong, mLastRow, mCurrentCol, mNumWords, mMixBuf;


      //--------------------------------------------------------------------------
      // Initialization
      //--------------------------------------------------------------------------

      this.init = function (song) {
          // Define the song
          mSong = song;

          // Init iteration state variables
          mLastRow = song.endPattern;
          mCurrentCol = 0;

          // Prepare song info
          mNumWords =  song.rowLen * song.patternLen * (mLastRow + 1) * 2;

          // Create work buffer (initially cleared)
          mMixBuf = new Int32Array(mNumWords);
      };


      //--------------------------------------------------------------------------
      // Public methods
      //--------------------------------------------------------------------------

      // Generate audio data for a single track
      this.generate = function () {
          // Local variables
          var i, j, p, row, col, n, cp,
              k, t, rsample, rowStartSample, f;

          // Put performance critical items in local variables
          var chnBuf = new Int32Array(mNumWords),
              instr = mSong.songData[mCurrentCol],
              rowLen = mSong.rowLen,
              patternLen = mSong.patternLen;

          // Clear effect state
          var low = 0, band = 0, high;
          var lsample, filterActive = false;

          // Clear note cache.
          var noteCache = [];

           // Patterns
           for (p = 0; p <= mLastRow; ++p) {
              cp = instr.p[p];

              // Pattern rows
              for (row = 0; row < patternLen; ++row) {
                  // Execute effect command.
                  var cmdNo = cp ? instr.c[cp - 1].f[row] : 0;
                  if (cmdNo) {
                      instr.i[cmdNo - 1] = instr.c[cp - 1].f[row + patternLen] || 0;

                      // Clear the note cache since the instrument has changed.
                      if (cmdNo < 17) {
                          noteCache = [];
                      }
                  }

                  // Put performance critical instrument properties in local variables
                  var oscLFO = mOscillators[instr.i[16]],
                      lfoAmt = instr.i[17] / 512,
                      lfoFreq = (2 ** (instr.i[18] - 9)) / rowLen,
                      fxLFO = instr.i[19],
                      fxFilter = instr.i[20],
                      fxFreq = instr.i[21] * 43.23529 * 3.141592 / 44100,
                      q = 1 - instr.i[22] / 255,
                      dist = instr.i[23] * 1e-5,
                      drive = instr.i[24] / 32,
                      panAmt = instr.i[25] / 512,
                      panFreq = 6.283184 * (2 ** (instr.i[26] - 9)) / rowLen,
                      dlyAmt = instr.i[27] / 255,
                      dly = instr.i[28] * rowLen & -2;  // Must be an even number

                  // Calculate start sample number for this row in the pattern
                  rowStartSample = (p * patternLen + row) * rowLen;

                  // Generate notes for this pattern row
                  for (col = 0; col < 4; ++col) {
                      n = cp ? instr.c[cp - 1].n[row + col * patternLen] : 0;
                      if (n) {
                          if (!noteCache[n]) {
                              noteCache[n] = createNote(instr, n, rowLen);
                          }

                          // Copy note from the note cache
                          var noteBuf = noteCache[n];
                          for (j = 0, i = rowStartSample * 2; j < noteBuf.length; j++, i += 2) {
                            chnBuf[i] += noteBuf[j];
                          }
                      }
                  }

                  // Perform effects for this pattern row
                  for (j = 0; j < rowLen; j++) {
                      // Dry mono-sample
                      k = (rowStartSample + j) * 2;
                      rsample = chnBuf[k];

                      // We only do effects if we have some sound input
                      if (rsample || filterActive) {
                          // State variable filter
                          f = fxFreq;
                          if (fxLFO) {
                              f *= oscLFO(lfoFreq * k) * lfoAmt + 0.5;
                          }
                          f = 1.5 * Math.sin(f);
                          low += f * band;
                          high = q * (rsample - band) - low;
                          band += f * high;
                          rsample = fxFilter == 3 ? band : fxFilter == 1 ? high : low;

                          // Distortion
                          if (dist) {
                              rsample *= dist;
                              rsample = rsample < 1 ? rsample > -1 ? osc_sin(rsample*.25) : -1 : 1;
                              rsample /= dist;
                          }

                          // Drive
                          rsample *= drive;

                          // Is the filter active (i.e. still audiable)?
                          filterActive = rsample * rsample > 1e-5;

                          // Panning
                          t = Math.sin(panFreq * k) * panAmt + 0.5;
                          lsample = rsample * (1 - t);
                          rsample *= t;
                      } else {
                          lsample = 0;
                      }

                      // Delay is always done, since it does not need sound input
                      if (k >= dly) {
                          // Left channel = left + right[-p] * t
                          lsample += chnBuf[k-dly+1] * dlyAmt;

                          // Right channel = right + left[-p] * t
                          rsample += chnBuf[k-dly] * dlyAmt;
                      }

                      // Store in stereo channel buffer (needed for the delay effect)
                      chnBuf[k] = lsample | 0;
                      chnBuf[k+1] = rsample | 0;

                      // ...and add to stereo mix buffer
                      mMixBuf[k] += lsample | 0;
                      mMixBuf[k+1] += rsample | 0;
                  }
              }
          }

          // Next iteration. Return progress (1.0 == done!).
          mCurrentCol++;
          return mCurrentCol / mSong.numChannels;
      };

      // Create a AudioBuffer from the generated audio data
      this.createAudioBuffer = function(context) {
          var buffer = context.createBuffer(2, mNumWords / 2, 44100);
          for (var i = 0; i < 2; i ++) {
              var data = buffer.getChannelData(i);
              for (var j = i; j < mNumWords; j += 2) {
                  data[j >> 1] = mMixBuf[j] / 65536;
              }
          }
          return buffer;
      };

      // Create a WAVE formatted Uint8Array from the generated audio data
      this.createWave = function() {
          // Create WAVE header
          var headerLen = 44;
          var l1 = headerLen + mNumWords * 2 - 8;
          var l2 = l1 - 36;
          var wave = new Uint8Array(headerLen + mNumWords * 2);
          wave.set(
              [82,73,70,70,
               l1 & 255,(l1 >> 8) & 255,(l1 >> 16) & 255,(l1 >> 24) & 255,
               87,65,86,69,102,109,116,32,16,0,0,0,1,0,2,0,
               68,172,0,0,16,177,2,0,4,0,16,0,100,97,116,97,
               l2 & 255,(l2 >> 8) & 255,(l2 >> 16) & 255,(l2 >> 24) & 255]
          );

          // Append actual wave data
          for (var i = 0, idx = headerLen; i < mNumWords; ++i) {
              // Note: We clamp here
              var y = mMixBuf[i];
              y = y < -32767 ? -32767 : (y > 32767 ? 32767 : y);
              wave[idx++] = y & 255;
              wave[idx++] = (y >> 8) & 255;
          }

          // Return the WAVE formatted typed array
          return wave;
      };

      // Get n samples of wave data at time t [s]. Wave data in range [-2,2].
      this.getData = function(t, n) {
          var i = 2 * Math.floor(t * 44100);
          var d = new Array(n);
          for (var j = 0; j < 2*n; j += 1) {
              var k = i + j;
              d[j] = t > 0 && k < mMixBuf.length ? mMixBuf[k] / 32768 : 0;
          }
          return d;
      };
  };

  // This music has been exported by SoundBox. You can use it with
      // http://sb.bitsnbites.eu/player-small.js in your own product.

      // See http://sb.bitsnbites.eu/demo.html for an example of how to
      // use it in a demo.

      // Song data
      const song = {
        songData: [
          { // Instrument 3
            i: [
            0, // OSC1_WAVEFORM
            255, // OSC1_VOL
            116, // OSC1_SEMI
            79, // OSC1_XENV
            0, // OSC2_WAVEFORM
            255, // OSC2_VOL
            116, // OSC2_SEMI
            0, // OSC2_DETUNE
            83, // OSC2_XENV
            0, // NOISE_VOL
            4, // ENV_ATTACK
            6, // ENV_SUSTAIN
            69, // ENV_RELEASE
            52, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            2, // FX_FILTER
            14, // FX_FREQ
            0, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            0, // FX_PAN_AMT
            0, // FX_PAN_FREQ
            0, // FX_DELAY_AMT
            0 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,127,127,,,,,,127,127,,,,,,127,127,,,,,,127,127],
               f: []}
            ]
          },
          { // Instrument 4
            i: [
            0, // OSC1_WAVEFORM
            255, // OSC1_VOL
            116, // OSC1_SEMI
            85, // OSC1_XENV
            0, // OSC2_WAVEFORM
            255, // OSC2_VOL
            116, // OSC2_SEMI
            0, // OSC2_DETUNE
            37, // OSC2_XENV
            14, // NOISE_VOL
            4, // ENV_ATTACK
            6, // ENV_SUSTAIN
            73, // ENV_RELEASE
            99, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            2, // FX_FILTER
            136, // FX_FREQ
            15, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            0, // FX_PAN_AMT
            0, // FX_PAN_FREQ
            66, // FX_DELAY_AMT
            6 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [,,,,,139,,,,,,,139,,,,,,,139,,,,,,,139],
               f: []}
            ]
          },
          { // Instrument 5
            i: [
            0, // OSC1_WAVEFORM
            91, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            0, // OSC2_WAVEFORM
            95, // OSC2_VOL
            128, // OSC2_SEMI
            12, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            12, // ENV_ATTACK
            0, // ENV_SUSTAIN
            72, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            2, // FX_FILTER
            255, // FX_FREQ
            0, // FX_RESONANCE
            0, // FX_DIST
            32, // FX_DRIVE
            83, // FX_PAN_AMT
            3, // FX_PAN_FREQ
            93, // FX_DELAY_AMT
            4 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,3,3,3,3,3,2,3,2,6,3,2,3,6,3,2,3,6,3,2,3,6,3,5,7],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [132,,132,,132,,,132,,,,,,,127,,139,,127,,,127,,,127,,,,135,,135,,135,,,135,,131,,127,,,130,,130,,130,,,130,,,130,,,,139,,139,,139,,,139,,135,,131,,,134,,134,,134,,,134,,,134,,,,,,,,,,,140,,,,135,,129,,,,,,,,135,,,138,,135],
               f: []},
              {n: [127,,127,,127,,,127,,,,,,,127,,139,,127,,,127,,,127,,,,130,,130,,130,,,130,,,,,,,130,,130,,130,,,130,,,130,,,,134,,134,,134,,,134,,,,,,,134,,134,,134,,,134,,,134,,,,,,,,,,,135,,,,,,,,,,,,,,135,,,138,,135],
               f: []},
              {n: [127,,127,,127,,,127,,,,139,127,,127,,139,,127,,,127,,,133,,133,,130,,130,,130,,,130,,,,,130,,130,,130,,130,,,130,,139,136,,136,,134,,134,,134,,,134,,,,,134,,134,,134,,134,,,134,,,140,,140,,,,,,,,,135,,,,,137,,,,,,,,,135,,,141,,,137],
               f: []},
              {n: [127,,127,,127,,,133,,133,,130,,,127,,,,127,,,,,,,,,,130,,132,,130,,,136,,136,,133,,,130,,130,,,,,,,,,,,,134,,134,,134,,139,,,140,,137,,,134,,134,,,,,,,,,,,,,,,,,,,141,,,,,,135,,,,,,,,135,,,138],
               f: []},
              {n: [127,,127,,127,,,133,,133,,130,,,127,,139,,127,,,127,,,127,,,,130,,132,,130,,,136,,136,,133,,,130,,130,,130,,,130,,,130,,,,134,,134,,134,,139,,,140,,137,,,134,,134,,134,,,134,,,134,,,,,,,,,,,141,,,,,,135,,,,,,,,135,,,138,,135],
               f: []},
              {n: [127,,127,,127,,,127,,127,,127,,,,,,,,,,,,,,,,,130,,134,,130,,,130,,130,,130,,,,,,,,,,,,,,,,,,,,,,,,,,135,,138],
               f: []}
            ]
          },
          { // Instrument 6
            i: [
            2, // OSC1_WAVEFORM
            40, // OSC1_VOL
            140, // OSC1_SEMI
            64, // OSC1_XENV
            0, // OSC2_WAVEFORM
            0, // OSC2_VOL
            140, // OSC2_SEMI
            0, // OSC2_DETUNE
            0, // OSC2_XENV
            192, // NOISE_VOL
            7, // ENV_ATTACK
            21, // ENV_SUSTAIN
            0, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            0, // LFO_AMT
            0, // LFO_FREQ
            0, // LFO_FX_FREQ
            3, // FX_FILTER
            161, // FX_FREQ
            192, // FX_RESONANCE
            5, // FX_DIST
            27, // FX_DRIVE
            0, // FX_PAN_AMT
            7, // FX_PAN_FREQ
            25, // FX_DELAY_AMT
            1 // FX_DELAY_TIME
            ],
            // Patterns
            p: [,,,,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [127,,127,,127,,,127,,127,,127,,,127,,127,,127,,,127,,127,,127],
               f: []}
            ]
          },
          { // Instrument 7
            i: [
            2, // OSC1_WAVEFORM
            192, // OSC1_VOL
            128, // OSC1_SEMI
            0, // OSC1_XENV
            2, // OSC2_WAVEFORM
            192, // OSC2_VOL
            140, // OSC2_SEMI
            18, // OSC2_DETUNE
            0, // OSC2_XENV
            0, // NOISE_VOL
            27, // ENV_ATTACK
            115, // ENV_SUSTAIN
            138, // ENV_RELEASE
            0, // ENV_EXP_DECAY
            0, // ARP_CHORD
            0, // ARP_SPEED
            0, // LFO_WAVEFORM
            91, // LFO_AMT
            6, // LFO_FREQ
            1, // LFO_FX_FREQ
            2, // FX_FILTER
            8, // FX_FREQ
            92, // FX_RESONANCE
            21, // FX_DIST
            32, // FX_DRIVE
            148, // FX_PAN_AMT
            5, // FX_PAN_FREQ
            85, // FX_DELAY_AMT
            8 // FX_DELAY_TIME
            ],
            // Patterns
            p: [2,3,2,3,,,,,,,,,,,,2,3,2,3,2,3,2,3,2,3,2,3],
            // Columns
            c: [
              {n: [],
               f: []},
              {n: [,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,135],
               f: []},
              {n: [,,,,,,,127,,,,,,,,,,,,,,,,,,,,,,,,,,,,130],
               f: []}
            ]
          },
        ],
        rowLen: 10023,   // In sample lengths
        patternLen: 28,  // Rows per pattern
        endPattern: 26,  // End pattern
        numChannels: 5  // Number of channels
      };

  // Audio


  const Audio = {
      init() {
          Audio.contextCreated = false;
          Audio.readyToPlay = false;
          Audio.musicEnabled = true;
          Audio.sfxEnabled = true;
          Audio.musicVolume = 0;
          Audio.sfxVolume = 0;

          Audio.levelStart = [5.02,,7,,,.18,,.37,,25,124,.03,.03,,,,.13,.35,.01]; // Random 807

          Audio.playerJump = [,,315,,.08,.07,,.77,-16,,,,,,,,,.91,.01];
          Audio.playerLand = [1.33,,423,.01,,.06,2,2.64,-3.8,,,,,.1,,.2,,.54,.01]; // Hit 491
          Audio.playerDeath = [1.11,,779,.01,.2,.48,4,4.56,.4,,,,.02,.9,,1,,.34,.13]; // Explosion 566
          Audio.playerSlam = [2.05,,374,.01,.05,.02,2,.59,-8.2,,,,,,,.5,.29,.65,.09]; // Shoot 673

          Audio.littleJump = [1.01,,491,,.01,.05,,1.02,25,,,,,,,.1,,.45,.08]; // Jump 438
          Audio.littleEscape = [,,433,.01,.18,.24,,.51,,,418,,.06,.1,,,,.43,.25,.11]; // Powerup 426

          Audio.enemyDeath = [1.81,,135,.01,.04,.18,1,.11,-6.6,,,,,.2,,.3,.15,.74,.09]; // Hit 569
      },

      initContext() {
          console.log('initContext()');
          if (Audio.contextCreated) return;

          // In Safari, ensure our target AudioContext is created inside a
          // click or tap event (this ensures we don't interact with it until
          // after user input).
          //
          // Chrome and Firefox are more relaxed, but this approach works for all 3.
          ZZFX.x = Audio.ctx = new AudioContext();
          Audio.gain_ = Audio.ctx.createGain();
          Audio.gain_.connect(Audio.ctx.destination);
          ZZFX.destination = Audio.gain_;
          console.log(Audio.ctx);

          Audio.contextCreated = true;
      },

      initTracks() {
          // In this game, we ensure the screen that calls this function happens after the
          // user has interacted at least once (and that interaction called initContext above),
          // so we know it's safe to interact with the audio context.
          if (!Audio.musicPlaying) {
              console.log('starting music');
              this.player = new CPlayer();
              this.player.init(song);
              console.log('music started');

              for (;;) {
                  if (this.player.generate() === 1) break;
                  console.log('generating');
              }

              this.musicGainNode = Audio.ctx.createGain();
              this.musicGainNode.connect(Audio.gain_);
              this.songSource = Audio.ctx.createBufferSource();
              this.songSource.buffer = this.player.createAudioBuffer(Audio.ctx);
              this.songSource.loop = true;
              this.songSource.connect(this.musicGainNode);

              this.musicStartTime = Audio.ctx.currentTime + 0.1;
              this.songSource.start(this.musicStartTime);

              Audio.musicPlaying = true;
          }

          Audio.readyToPlay = true;
      },

      update() {
          if (!Audio.readyToPlay) return;

          this.sfxVolume = this.sfxEnabled ? 0.3 : 0;
          this.musicVolume = this.musicEnabled ? 1 : 0;

          ZZFX.volume = this.sfxVolume;

          if (this.sfxEnabled) {
              ZZFX.volume = 0.3;
          } else {
              ZZFX.volume = 0;
          }
      },

      play(sound) {
          if (!Audio.readyToPlay) return;
          ZZFX.play(...sound);
      },

      // It's important we do pausing and unpausing as specific events and not in general update(),
      // because update() is triggered by the animation frame trigger which does not run if the
      // page is not visible. (So, if you want the music to fade in the background, for example,
      // that's not helpful if it won't work because you aren't looking at the page!)

      pause() {
          if (Audio.readyToPlay) {
              Audio.gain_.gain.linearRampToValueAtTime(0, Audio.ctx.currentTime + 1);
          }
      },

      unpause() {
          if (Audio.readyToPlay) {
              Audio.gain_.gain.linearRampToValueAtTime(1, Audio.ctx.currentTime + 1);
          }
      }
  };

  // Constants

  // The game's desired dimensions in pixels - the actual dimensions can be adjusted
  // slightly by the Viewport module.
  const TARGET_GAME_WIDTH = 320;
  const TARGET_GAME_HEIGHT = 180;

  // Shortcuts for marker locations on screen
  const INVENTORY_WOOD_POS = { u: 250, v: 131 };
  const INVENTORY_MEAT_POS = { u: 250, v: 143 };
  const INVENTORY_TORCH_POS = { u: 250, v: 155 };
  const INVENTORY_STONE_POS = { u: 250, v: 167 };
  const SANITY_POS = { u: 284, v: 9 };

  // Number of "facing left" villager frames (doubled for facing right)
  const VILLAGER_FRAMES = 12;

  // Frames per second (locked)
  //
  // Other constants below, like gravity, foot speed, etc., are represented as movement PER FRAME.
  const FPS = 42;

  const PALETTE = [
    '#0a1a2f',
    '#04373b',
    '#1a644c',
    '#40985c',
    '#d1cb95'
  ];

  function angle2vector(r, m) {
      return { x: Math.cos(r), y: Math.sin(r), m: m || 1 };
  }

  function rgba(r, g, b, a) {
      return `rgba(${r},${g},${b},${a})`;
  }

  function createCanvas(width, height) {
      let canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      let ctx = canvas.getContext('2d');
      return { canvas, ctx };
  }

  // SpriteSheet

  /**
   * This module is generated by `gulp buildAssets`.
   */
  const SpriteSheet =
      /* <generated> */
  { altar: [ [ 0, 0, 19, 29 ], [ 19, 0, 19, 29 ] ],
    bigarrows: [ [ 0, 29, 15, 8 ] ],
    blackcat: [ [ 0, 37, 24, 36 ], [ 24, 37, 24, 36 ] ],
    bridge: [ [ 0, 73, 31, 16 ], [ 31, 73, 31, 16 ] ],
    button: [ [ 0, 89, 9, 9 ], [ 9, 89, 9, 9 ], [ 18, 89, 9, 9 ] ],
    factory: [ [ 0, 98, 20, 14 ], [ 20, 98, 20, 14 ] ],
    font4: [ [ 0, 112, 270, 12 ] ],
    icons: [ [ 0, 124, 8, 8 ], [ 8, 124, 8, 8 ], [ 16, 124, 8, 8 ], [ 24, 124, 8, 8 ] ],
    influencebar: [ [ 0, 132, 93, 10 ], [ 93, 132, 93, 10 ] ],
    jobselect: [ [ 0, 142, 101, 14 ] ],
    keys: [ [ 0, 156, 18, 9 ], [ 18, 156, 18, 9 ], [ 36, 156, 18, 9 ] ],
    particle:
     [ [ 0, 165, 1, 1 ],
       [ 1, 165, 1, 1 ],
       [ 2, 165, 1, 1 ],
       [ 3, 165, 1, 1 ],
       [ 4, 165, 1, 1 ] ],
    sanitybar: [ [ 0, 166, 18, 82 ], [ 18, 166, 18, 82 ] ],
    smallarrows: [ [ 0, 248, 3, 5 ], [ 3, 248, 3, 5 ], [ 6, 248, 3, 5 ], [ 9, 248, 3, 5 ] ],
    villager:
     [ [ 0, 253, 22, 30 ],
       [ 22, 253, 22, 30 ],
       [ 44, 253, 22, 30 ],
       [ 66, 253, 22, 30 ],
       [ 88, 253, 22, 30 ],
       [ 110, 253, 22, 30 ],
       [ 132, 253, 22, 30 ],
       [ 154, 253, 22, 30 ],
       [ 176, 253, 22, 30 ],
       [ 198, 253, 22, 30 ],
       [ 220, 253, 22, 30 ],
       [ 242, 253, 22, 30 ] ],
    villagerchunk:
     [ [ 0, 283, 9, 9 ],
       [ 9, 283, 9, 9 ],
       [ 18, 283, 9, 9 ],
       [ 27, 283, 9, 9 ],
       [ 36, 283, 9, 9 ],
       [ 45, 283, 9, 9 ] ],
    villagerdeath: [ [ 0, 292, 13, 22 ] ],
    wink: [ [ 0, 314, 3, 5 ], [ 3, 314, 3, 5 ], [ 6, 314, 3, 5 ], [ 9, 314, 3, 5 ] ],
    terrain_FG1: [ [ 0, 319, 320, 150 ] ],
    terrain_FG2: [ [ 0, 469, 320, 150 ] ],
    terrain_FG3: [ [ 0, 619, 320, 150 ] ],
    base64:
     'data:image/png;base64,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' };
  /* </generated> */

  // Viewport


  /**
   * Viewport
   *
   * Represents the game display (for us, a canvas).
   */
  const Viewport = {
      init() {
          Viewport.canvas = document.getElementById('canvas');
          Viewport.ctx = Viewport.canvas.getContext('2d');
          Viewport.resize(true);
      },

      // Resize the canvas to give us approximately our desired game display size.
      //
      // Rather than attempt to explain it, here's a concrete example:
      //
      //     we start with a desired game dimension:   480x270px
      //          get the actual browser dimensions:  1309x468px
      //          factor in the display's DPR ratio:  2618x936px
      //         now calculate the horizontal scale:       5.45x
      //                     and the vertical scale:       3.46x
      //            our new offical game scaling is:        5.4x
      //       and our official viewport dimensions:   484x173px
      //
      // This approach emphasizes correct aspect ratio and maintains full-window rendering, at
      // the potential cost of limiting visibility of the game itself in either the X or Y axis.
      // If you use this approach, make sure your GUI can "float" (otherwise there may be whole
      // UI elements the player cannot see!).
      resize(force) {
          let dpr = window.devicePixelRatio,
              width = Viewport.canvas.clientWidth,
              height = Viewport.canvas.clientHeight,
              dprWidth = width * dpr,
              dprHeight = height * dpr;

          if (
              force ||
              Viewport.canvas.width !== dprWidth ||
              Viewport.canvas.height !== dprHeight
          ) {
              Viewport.canvas.width = dprWidth;
              Viewport.canvas.height = dprHeight;

              Viewport.scale = ((Math.min(dprWidth / TARGET_GAME_WIDTH, dprHeight / TARGET_GAME_HEIGHT) * 10) | 0) / 10;
              Viewport.width = Math.ceil(dprWidth / Viewport.scale);
              Viewport.height = Math.ceil(dprHeight / Viewport.scale);
              Viewport.center = {
                  u: (Viewport.width / 2) | 0,
                  v: (Viewport.height / 2) | 0
              };
              Viewport.clientWidth = width;
              Viewport.clientHeight = height;

              // Note: smoothing flag gets reset on every resize by some browsers, which is why
              // we do it here.
              Viewport.ctx.imageSmoothingEnabled = false;
          }

          // We do this every frame, not just on resize, due to browser sometimes "forgetting".
          Viewport.canvas.style.cursor = 'none';
      },

      fillViewportRect() {
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
      },

      isOnScreen(uv) {
          return uv.u >= 0 && uv.v >= 0 && uv.u < Viewport.width && uv.v < Viewport.height;
      }
  };

  /**
   * Sprite
   *
   * Encapsulates loading sprite slices from the spritesheet, organizing them, and
   * modifying them or constructing using primitives. To save space, we use some techniques
   * like storing only a small slice of an image in the spritesheet, then using code
   * to duplicate it, add some randomness, etc.
   */
  const Sprite = {
      // This is an exception to the rule, loading the spritesheet is a special action that
      // happens BEFORE everything is initialized.
      loadSpritesheet(cb) {
          let image = new Image();
          image.onload = cb;
          image.src = SpriteSheet.base64;
          Sprite.sheet = image;
      },

      init() {
          // Standard (no special ops) sprites
          const defaultOpts = { anchor: { x: 0, y: 0 } };
          Sprite.font = initBasicSprite(SpriteSheet.font4[0]);
          Sprite.particle = SpriteSheet.particle.map(initBasicSprite);
          Sprite.blackcat = initBasicSpriteArray(SpriteSheet.blackcat, defaultOpts);
          Sprite.button = initBasicSpriteArray(SpriteSheet.button, defaultOpts);
          Sprite.influencebar = initBasicSpriteArray(SpriteSheet.influencebar, defaultOpts);
          Sprite.smallarrows = initBasicSpriteArray(SpriteSheet.smallarrows, defaultOpts);
          Sprite.jobselect = initBasicSpriteArray(SpriteSheet.jobselect, defaultOpts);
          Sprite.bridge = initBasicSpriteArray(SpriteSheet.bridge, defaultOpts);
          Sprite.bigarrows = initBasicSpriteArray(SpriteSheet.bigarrows, defaultOpts);
          Sprite.icons = initBasicSpriteArray(SpriteSheet.icons, defaultOpts);
          Sprite.factory = initBasicSpriteArray(SpriteSheet.factory, defaultOpts);
          Sprite.wink = initBasicSpriteArray(SpriteSheet.wink, defaultOpts);
          Sprite.keys = initBasicSpriteArray(SpriteSheet.keys, defaultOpts);

          // Custom anchors
          Sprite.altar = initBasicSpriteArray(SpriteSheet.altar, { anchor: { x: 9, y: 28 } });
          Sprite.villagerdeath = initBasicSpriteArray(SpriteSheet.villagerdeath, { anchor: { x: 6, y: 21 } });
          Sprite.villagerchunk = initBasicSpriteArray(SpriteSheet.villagerchunk, { anchor: { x: 4, y: 4 } });

          // Sanity bar handling
          Sprite.sanitybar = initBasicSpriteArray(SpriteSheet.sanitybar, defaultOpts);
          Sprite.sanitybar[2] = initDynamicSprite(recolor(Sprite.sanitybar[1].img, '#0a1a2f'), defaultOpts);

          // Terrain handling
          Sprite.terrain = [
              initBasicSprite(SpriteSheet.terrain_FG1[0]),
              initBasicSprite(SpriteSheet.terrain_FG2[0]),
              initBasicSprite(SpriteSheet.terrain_FG3[0])
          ];
          for (let i = 0; i < 3; i++) {
              Sprite.terrain[i].img = augmentTerrain(Sprite.terrain[i].img, 30, PALETTE[i]);
          }

          // Villager
          Sprite.villager = initBasicSpriteArray(SpriteSheet.villager, { anchor: { x: 16, y: 29 } });
          const villagerFrames = Sprite.villager.length;
          for (let i = 0; i < villagerFrames; i++) {
              Sprite.villager[i + villagerFrames] = initDynamicSprite(flipHorizontal(Sprite.villager[i].img), { anchor: { x: 5, y: 29 } });
          }
      },

      /**
       * A small helper that draws a sprite onto a canvas, respecting the anchor point of
       * the sprite. Note that the canvas should be PRE-TRANSLATED and PRE-ROTATED, if
       * that's appropriate!
       */
      drawSprite(ctx, sprite, u, v) {
          ctx.drawImage(sprite.img, u - sprite.anchor.x, v - sprite.anchor.y);
      },

      drawViewportSprite(sprite, pos, rotation) {
          let { u, v } = this.viewportSprite2uv(
              sprite,
              pos
          );
          if (rotation) {
              Viewport.ctx.save();
              Viewport.ctx.translate(u + sprite.anchor.x, v + sprite.anchor.y);
              Viewport.ctx.rotate(rotation);
              Viewport.ctx.drawImage(
                  sprite.img,
                  -sprite.anchor.x,
                  -sprite.anchor.y
              );
              Viewport.ctx.restore();
          } else {
              Viewport.ctx.drawImage(sprite.img, u, v);
          }
      },

      drawSmashedSprite(sprite, pos, height) {
          let { u, v } = this.viewportSprite2uv(
              sprite,
              pos
          );

          Viewport.ctx.drawImage(sprite.img, u - 1, v - height + sprite.img.height, sprite.img.width + 2, height);
      },

      viewportSprite2uv(sprite, pos) {
          // HACK TODO
          if (pos.u) {
              return {
                  u: pos.u - sprite.anchor.x,
                  v: pos.v - sprite.anchor.y
              };
          }

          return {
              u: pos.x - sprite.anchor.x - (0) /*Camera.pos.x*/ + Viewport.center.u,
              v: pos.y - sprite.anchor.y - (0) /*Camera.pos.y*/ + Viewport.center.v
          };
      }
  };

  // Sprite utility functions

  function initBasicSpriteArray(data, opts) {
      return data.map(element => initBasicSprite(element, opts));
  }

  function initBasicSprite(data, opts) {
      return initDynamicSprite(loadCacheSlice(...data), opts);
  }

  function initDynamicSprite(source, opts) {
      let w = source.width,
          h = source.height;

      if (typeof opts !== 'object') {
          opts = {};
      }

      if (!opts.anchor) {
          opts.anchor = { x: (w / 2) | 0, y: (h / 2) | 0 };
      }

      if (!opts.bb) {
          opts.bb = [-opts.anchor.x, -opts.anchor.y, source.width, source.height];
      }

      return {
          img: source,
          ...opts
      };
  }

  function loadCacheSlice(x, y, w, h) {
      const source = Sprite.sheet;
      const sliceCanvas = createCanvas(w, h);
      sliceCanvas.ctx.drawImage(source, x, y, w, h, 0, 0, w, h);
      return sliceCanvas.canvas;
  }

  function flipHorizontal(source) {
      let canvas = createCanvas(source.width, source.height);
      canvas.ctx.translate(source.width, 0);
      canvas.ctx.scale(-1, 1);
      canvas.ctx.drawImage(source, 0, 0);
      return canvas.canvas;
  }

  function augmentTerrain(source, lines, color) {
      let canvas = createCanvas(320, 180);
      canvas.ctx.drawImage(source, 0, 0);
      canvas.ctx.fillStyle = color;
      canvas.ctx.fillRect(0, 180 - lines, 320, lines);
      return canvas.canvas;
  }

  function recolor(source, color) {
      let canvas = createCanvas(source.width, source.height);
      canvas.ctx.fillStyle = color;
      canvas.ctx.fillRect(0, 0, source.width, source.height);
      canvas.ctx.globalCompositeOperation = 'destination-in';
      canvas.ctx.drawImage(source, 0, 0);
      return canvas.canvas;
  }

  // Text


  const C_WIDTH = 5;
  const C_HEIGHT = 5;
  const FONT_SHEET_C_WIDTH = 6;
  const FONT_SHEET_WIDTH = 270;
  const DEFAULT_C_SHIFT = 5;

  // Very simple variable-width font implementation. The characters in the font strip
  // are left-aligned in their 5x5 pixel boxes, so in order to have variable width,
  // we just need to note the characters that AREN'T full width. Anything not in
  // this list has full shift (5+1 = 6 pixels).
  const C_SHIFT = {
      10: 0, // LF (\n)
      32: 3, // Space ( )
      33: 3, // Bang (!)
      39: 2, // Apostrophe (')
      40: 3, // Open Paren (
      41: 3, // Close Paren )
      44: 3, // Comma (,)
      46: 3, // Period (.)
      47: 6, // Slash (/)
      73: 2, // I
      77: 6, // M
      84: 6, // T
      86: 6, // V
      87: 6, // W
      88: 6, // X
      89: 6, // Y
      91: 4, // [ (s)
      109: 6, // m (up)
      111: 6, // o (down),
      1108: 10, // left arrow key
      1114: 10, // right arrow key
      1101: 19 // escape key
  };

  const C_ICONS = {
  };

  const Text = {
      init() {
          Text.white = Sprite.font.img;
          Text.black = recolor(Text.white, rgba(0, 0, 0, 1));
          Text.shadow = recolor(Text.white, rgba(44, 27, 46, 1));

          //Text.tan = recolor(Text.white, rgba(209, 180, 140, 1));
          //Text.pig = recolor(Text.white, rgba(227, 66, 98, 1));
          //Text.duotone = recolorDuotone(Text.white, '#f2b63d', '#fff4e0');
          //Text.duotone_red = recolorDuotone(Text.white, '#ffaa5e', '#ffd4a3', rgba(255, 0, 0, 0.7));

          Text.palette = PALETTE.map(color => recolor(Text.white, color));

          C_ICONS[1108] = Sprite.keys[0];
          C_ICONS[1114] = Sprite.keys[1];
          C_ICONS[1101] = Sprite.keys[2];
      },

      drawText(ctx, text, u, v, scale = 1, font = Text.white, shadow) {
          for (let c of this.charactersToDraw(text, scale)) {
              if (C_ICONS[c.c]) {
                  ctx.drawImage(
                      C_ICONS[c.c].img,
                      u + c.u,
                      v + c.v - Math.floor((C_ICONS[c.c].img.height) / 2) + 2
                  );
              } else {
                  let k = (c.c - 32) * FONT_SHEET_C_WIDTH;
                  if (shadow) {
                      ctx.drawImage(
                          shadow,
                          k % FONT_SHEET_WIDTH,
                          (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                          C_WIDTH,
                          C_HEIGHT,
                          u + c.u,
                          v + c.v + 1,
                          C_WIDTH * scale,
                          C_HEIGHT * scale
                      );
                  }
                  ctx.drawImage(
                      font,
                      k % FONT_SHEET_WIDTH,
                      (k / FONT_SHEET_WIDTH | 0) * FONT_SHEET_C_WIDTH,
                      C_WIDTH,
                      C_HEIGHT,
                      u + c.u,
                      v + c.v,
                      C_WIDTH * scale,
                      C_HEIGHT * scale
                  );
              }
          }
      },

      drawParagraph(ctx, text, u, v, width, scale = 1, font = Text.white, shadow) {
          const lines = this.breakParagraph(text, width, scale);

          for (let i = 0; i < lines.length; i++) {
              this.drawText(ctx, lines[i], u, v + i * (C_HEIGHT + 2) * scale, scale, font, shadow);
          }
      },

      breakParagraph(text, width, scale = 1) {
          const lines = [];
          let line = '';
          const words = text.split(' ');
          while (words.length > 0) {
              const lineWidth = this.measure(line + ' ' + words[0], scale).w;
              if (lineWidth > width) {
                  lines.push(line);
                  line = '';
              }
              line = line + ' ' + words.shift();
          }
          if (line.length > 0) {
              lines.push(line);
          }
          return lines;
      },

      measure(text, scale = 1) {
          let w = 0, h = 0;

          for (let c of this.charactersToDraw(text, scale)) {
              w = Math.max(w, c.u + (C_SHIFT[c.c] || DEFAULT_C_SHIFT) * scale);
              h = c.v + (C_HEIGHT + 2) * scale;
          }

          return { w, h };
      },

      *charactersToDraw(text, scale = 1) {
          let u = 0, v = 0;

          for (let idx = 0; idx < text.length; idx++) {
              let c = text.charCodeAt(idx);

              if (c === 10) {
                  // Newline
                  u = 0;
                  v += (C_HEIGHT + 2) * scale;
                  continue;
              }

              if (c === 92) {
                  // Backslash
                  idx++;
                  c = 1000 + text.charCodeAt(idx);
              }

              yield { c, u, v };

              u += (C_SHIFT[c] || DEFAULT_C_SHIFT) * scale;
          }
      }
  };

  // AshParticle


  class AshParticle {
      constructor() {
          this.t = -1;
          this.d = 60;

          this.pos = { u: Math.random() * 320, v: Math.random() * 200 };
          this.layer = Math.floor(Math.random() * 3) + 1;
          this.alpha = 1;
      }

      update() {
          if (++this.t === this.d) {
              this.cull = true;
          }

          if (this.t > 36) {
              this.alpha -= 0.02;
          }

          this.pos.v += 0.1;
          if (this.pos.v < 3) this.pos.v += 0.02;
          if (this.pos.v < 2) this.pos.v += 0.02;

          if (Math.random() < 0.05) {
              this.pos.u += 0.5;
          }
      }

      draw() {
          Viewport.ctx.globalAlpha = this.alpha;
          Viewport.ctx.drawImage(Sprite.particle[this.layer - 1].img, Math.floor(this.pos.u), Math.floor(this.pos.v));
          Viewport.ctx.globalAlpha = 1;
      }
  }

  // KeyboardAdapter


  const KeyboardAdapter = {
      init() {
          KeyboardAdapter.held = [];

          window.addEventListener('keydown', event => {
              //let k = KeyboardAdapter.map[event.code];
              // Uncomment to debug key presses
              // console.log(event.key, event.keyCode, event.code, k);

              // Hack to ensure we initialize audio after user interacts with game
              Audio.initContext();

              //if (Input.Action.includes(event.code)) {
              //if (k) {
              //    KeyboardAdapter.held[k] = true;
                KeyboardAdapter.held[event.code] = true;
              //}
          });

          window.addEventListener('keyup', event => {
              //let k = KeyboardAdapter.map[event.code];
              //if (k) {
              //    KeyboardAdapter.held[k] = false;
              //}
              KeyboardAdapter.held[event.code] = false;

              /*if (event.key >= '1' && event.key <= '9') {
                  game.nextLevel = Number(event.key) - 1;
                  game.screens.pop();
              }*/
          });

          KeyboardAdapter.reset();
      },

      //update() {
          // For keyboards, we want to convert the state of the various arrow keys being held down
          // into a directional vector. We use the browser's event to handle the held state of
          // the other action buttons, so we don't need to process them here.
          /*let state =
              (KeyboardAdapter.held[Input.Action.UP] ? 1 : 0) +
              (KeyboardAdapter.held[Input.Action.DOWN] ? 2 : 0) +
              (KeyboardAdapter.held[Input.Action.LEFT] ? 4 : 0) +
              (KeyboardAdapter.held[Input.Action.RIGHT] ? 8 : 0);*/

          //KeyboardAdapter.direction = KeyboardAdapter.arrowDirections[state];
      //},

      reset() {
          //KeyboardAdapter.direction = 0;
          for (let action of Input.Action) {
              KeyboardAdapter.held[action] = false;
          }
          //KeyboardAdapter.held = [];
          //KeyboardAdapter.held.length = 0;
      }
  };

  // Input


  const Input = {
      // Game Inputs

      // Extreme hack
      //
      Action: [
          'ArrowUp',
          'ArrowLeft',
          'ArrowDown',
          'ArrowRight',
          'Escape',
          'Space',
          'KeyV',
          'KeyH',
          'KeyA',
          'KeyS',
          'KeyB',
          'KeyT',
          'KeyM'
      ],

      init() {
          // A vector representing the direction the user is pressing/facing,
          // separate from pressing and releasing inputs. Treating "direction"
          // separately makes it easier to handle gamepad sticks.
          //this.direction = { x: 0, y: 0, m: 0 };

          // "Pressed" means an input was pressed THIS FRAME.
          this.pressed = {};

          // "Released" means an input was released THIS FRAME.
          this.released = {};

          // "Held" means an input is held down. The input was "Pressed" either
          // this frame or in a past frame, and has not been "Released" yet.
          this.held = {};

          KeyboardAdapter.init();
      },

      update() {
          // We could have some kind of "input adapter toggle", but it's easier to just treat all inputs
          // as valid -- if you're pressing the "attack" button on either gamepad or keyboard, then you're
          // attacking. For directional input, we instead check whether there's movement on the thumbstick,
          // and we use it if there is -- otherwise we try to extract movement from the keyboard instead.

          //KeyboardAdapter.update();

          for (let action of Input.Action) {
              let held = KeyboardAdapter.held[action];
              this.pressed[action] = !this.held[action] && held;
              this.released[action] = this.held[action] && !held;

              this.held[action] = held;
          }

          //this.pointer = pointerAdapter.pointer;
          //this.direction = KeyboardAdapter.direction;
          //this.direction = this.gamepad.direction.m > 0 ? this.gamepad.direction : this.keyboard.direction;
      }
  };

  // Particle


  class VillagerChunkParticle {
      constructor(pos) {
          this.t = -1;
          this.d = 30;

          this.angle = Math.random() * Math.PI + Math.PI;
          this.vector = angle2vector(this.angle);
          this.m = 50 + Math.random() * 25;
          this.a = Math.random() * Math.PI * 2;
          this.ad = 0.1;

          this.pos = { u: pos.u, v: pos.v - 12 };
          this.pos.u += this.vector.x * 3;
          this.pos.v += this.vector.y * 3;

          this.frame = Math.floor(Math.random() * 6);
      }

      update() {
          if (++this.t === this.d) {
              this.cull = true;
          }

          this.pos.u += (this.m / this.d) * this.vector.x;
          this.pos.v += (this.m / this.d) * this.vector.y;
          this.vector.x *= 0.95;
          this.vector.y *= 0.95;
          this.vector.y += 0.05;

          this.a += this.ad;
      }

      draw() {
          Sprite.drawViewportSprite(Sprite.villagerchunk[this.frame], this.pos, this.a);
      }
  }

  // SacrificeParticle


  class SacrificeParticle {
      constructor(villager) {
          this.t = -1;
          this.d = 30;
          this.villager = villager;
      }

      update() {
          if (++this.t === this.d) {
              game.gameScene.grantSanity(10);
              this.cull = true;
          }

          if (this.t >= 24 && this.t <= 27) {
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
              game.gameScene.entities.push(new VillagerChunkParticle(this.villager.pos));
          }

          this.villager.pos.v -= 0.2;
      }

      draw() {
          let v = Math.floor(this.villager.pos.v);

          if (this.t >= 0 && this.t < 15) {
              let shake = (this.t % 3) - 1;
              Sprite.drawViewportSprite(Sprite.villager[0], { u: this.villager.pos.u + shake, v: v });
          } else if (this.t >= 15 && this.t <= 25) {
              Sprite.drawViewportSprite(Sprite.villagerdeath[0], { u: this.villager.pos.u, v: v });
          }
      }
  }

  // Button


  class Button {
      constructor(u, v, hotkey, text) {
          this.u = u;
          this.v = v;
          this.hotkey = hotkey;
          this.text = text;
          this.visible = false;
          this.active = false;
      }

      update() {
          if (!this.visible) return;
      }

      draw() {
          if (!this.visible) return;

          const frame = this.active ? 0 : 2;
          const colorIndex = this.active ? 4 : 2;
          const bgColorIndex = this.active ? 0 : 2;
          Viewport.ctx.drawImage(Sprite.button[frame].img, this.u, this.v);
          Text.drawText(Viewport.ctx, this.hotkey, this.u + 2, this.v + 2, 1, Text.palette[bgColorIndex]);
          Text.drawText(Viewport.ctx, this.text.toUpperCase(), this.u + 11, this.v + 2, 1, Text.palette[colorIndex]);
      }
  }

  // TweenChain

  class TweenChain {
      constructor(tweenArray) {
          this.t = -1;
          this.tweenArray = tweenArray;
      }

      update() {
          this.t++;

          if (this.t < this.tweenArray[0].t1) {
              this.value = this.tweenArray[0].v1;
              this.facing = (this.tweenArray[0].v2 - this.tweenArray[0].v1 >= 0 ? 1 : 0);
              return;
          }

          if (this.t >= this.tweenArray[this.tweenArray.length - 1].t2) {
              this.value = this.tweenArray[this.tweenArray.length - 1].v2;
              this.facing = (this.tweenArray[this.tweenArray.length - 1].v2 - this.tweenArray[this.tweenArray.length - 1].v1 >= 0 ? 1 : 0);
              this.finished = true;
              return;
          }

          for (let i = 0; i < this.tweenArray.length; i++) {
              if (this.t >= this.tweenArray[i].t1 && this.t < this.tweenArray[i].t2) {
                  // A tween chain can have an "undefined" start value, which means
                  // just inherit the last value of the previous tween.
                  if (this.tweenArray[i].v1 === undefined) {
                      this.tweenArray[i].v1 = this.tweenArray[i - 1].v2;
                  }

                  // Apply stagger on the fly; this allows for randomization of the DESTINATION
                  // (we assume the start point does not move).
                  if (this.tweenArray[i].stagger) {
                      this.tweenArray[i].v2 += Math.floor(Math.random() * this.tweenArray[i].stagger - this.tweenArray[i].stagger / 2);
                      this.tweenArray[i].stagger = undefined;
                  }

                  this.value = (this.tweenArray[i].v2 - this.tweenArray[i].v1)
                      * (this.t - this.tweenArray[i].t1)
                      / (this.tweenArray[i].t2 - this.tweenArray[i].t1)
                      + this.tweenArray[i].v1;

                  // For every frame, we provide a utility "facing" value: 1 if the current
                  // movement trends RIGHT, 0 if the current movement trends LEFT.
                  this.facing = (this.tweenArray[i].v2 - this.tweenArray[i].v1 >= 0 ? 1 : 0);
                  break;
              }
          }
      }
  }

  // HeightMapData
  //
  // This file is generated by `gulp buildAssets`.

  const HeightMapData =
  /* <generated-data> */
  [ [],
    [],
    [ 126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      126,
      127,
      128,
      128,
      129,
      129,
      129,
      130,
      130,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      131,
      132,
      132,
      132,
      132,
      132,
      132,
      133,
      133,
      133,
      133,
      133,
      134,
      134,
      135,
      136,
      136,
      137,
      138,
      138,
      139,
      139,
      139,
      140,
      140,
      140,
      140,
      139,
      139,
      139,
      139,
      139,
      139,
      138,
      138,
      138,
      138,
      138,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      138,
      139,
      139,
      139,
      139,
      140,
      140,
      141,
      141,
      141,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      145,
      145,
      145,
      145,
      145,
      145,
      145,
      146,
      145,
      145,
      145,
      145,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143,
      143 ],
    [ 149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      148,
      148,
      148,
      148,
      148,
      148,
      147,
      147,
      147,
      146,
      146,
      146,
      145,
      145,
      144,
      144,
      144,
      143,
      143,
      142,
      141,
      141,
      141,
      140,
      140,
      140,
      139,
      139,
      139,
      139,
      139,
      138,
      138,
      138,
      138,
      138,
      138,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      137,
      136,
      136,
      136,
      135,
      135,
      135,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      134,
      135,
      135,
      135,
      136,
      136,
      136,
      137,
      137,
      137,
      137,
      137,
      137,
      138,
      138,
      138,
      138,
      139,
      139,
      139,
      139,
      140,
      140,
      140,
      140,
      141,
      141,
      141,
      141,
      142,
      142,
      142,
      142,
      143,
      143,
      143,
      143,
      144,
      144,
      144,
      145,
      145,
      146,
      145,
      145,
      145,
      145,
      145,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      144,
      145,
      146,
      146,
      147,
      147,
      148,
      148,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      148,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      147,
      148,
      148,
      149,
      149,
      149,
      149,
      150,
      150,
      150,
      150,
      151,
      151,
      152,
      152,
      152,
      153,
      153,
      153,
      154,
      154,
      154,
      154,
      154,
      154,
      153,
      153,
      153,
      153,
      152,
      152,
      152,
      152,
      151,
      151,
      151,
      151,
      151,
      151,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      150,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149,
      149 ] ]
  /* </generated-data> */
  ;

  // Villager


  const IDLE = 0;
  const WOODCUTTER = 1;
  const BUTCHER = 2;
  const TALLOWER = 3;
  const STONECUTTER = 4;

  class IdleTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 30, v1: 0, v2: 0 }
          ]);
          this.frame = 0;
          this.layer = 3;
      }

      completeTask() { }
  }

  class ButcherTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: -76, stagger: 20 },
              { t1: 120, t2: 180, v1: undefined, v2: -76, stagger: 20 },
              { t1: 180, t2: 300, v1: undefined, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
          this.equipmentframe = (this.t > 60 && this.t < 210) ? 3 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.gatherMeat();
      }
  }

  class WoodcutterTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: 140, stagger: 15 },
              { t1: 120, t2: 180, v1: undefined, v2: 140, stagger: 15 },
              { t1: 180, t2: 300, v1: undefined, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 130 && this.t < 170) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
          this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.gatherWood();
      }
  }

  class TallowerTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: 47 },
              { t1: 120, t2: 180, v1: 47, v2: 47 },
              { t1: 180, t2: 300, v1: 47, v2: 0 }
          ]);
          this.layer = 2;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + 7 + facing * VILLAGER_FRAMES;
          //this.equipmentframe = (this.t > 60 && this.t < 210) ? 2 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.craftTorch();
      }
  }

  class StonecutterTask extends TweenChain {
      constructor() {
          super([
              { t1: 0, t2: 120, v1: 0, v2: -141 },
              { t1: 120, t2: 180, v1: -141, v2: -141 },
              { t1: 180, t2: 300, v1: -141, v2: 0 }
          ]);
          this.layer = 3;
          this.frame = 0;
      }

      update() {
          super.update();

          const facing = (this.t > 140 && this.t < 160) ? (Math.floor(this.t / 10) % 2) : this.facing;

          this.frame = Math.floor((this.t + 1) / 8) % 2 + facing * VILLAGER_FRAMES;
          this.equipmentframe = (this.t > 60 && this.t < 210) ? 5 + facing * VILLAGER_FRAMES : undefined;
      }

      completeTask() {
          game.gameScene.gatherStone();
      }
  }

  const TaskClass = {
      [WOODCUTTER]: WoodcutterTask,
      [BUTCHER]: ButcherTask,
      [TALLOWER]: TallowerTask,
      [STONECUTTER]: StonecutterTask,
      [IDLE]: IdleTask
  };

  class Villager {
      static JOB_NAMES = ['', 'WOODCUTTER', 'BUTCHER', 'TALLOWER', 'STONEMASON', 'FIREKEEPER', 'TOTEMCARVER'];

      constructor(job) {
          this.job = job;
          this.t = 0;
          this.pos = { u: 0, v: 0 };
      }

      update() {
          if (!this.task) {
              this.task = new TaskClass[this.job]();
          }

          this.task.update();

          this.layer = this.task.layer;
          this.pos.u = 160 + this.task.value;
          this.pos.v = HeightMapData[this.layer][Math.floor(this.pos.u)] - 32 + 1;
          this.frame = this.task.frame || 0;
          this.equipmentframe = this.task.equipmentframe;

          if (this.task.finished) {
              this.task.completeTask(this);
              this.task = undefined;
          }
      }

      draw() {
          Sprite.drawViewportSprite(Sprite.villager[this.frame], this.pos);

          if (this.equipmentframe > -1) {
              Sprite.drawViewportSprite(Sprite.villager[this.equipmentframe], this.pos);
          }
      }

      newTask() {
          return new TaskClass[this.job]();
      }
  }

  // TextFloatParticle


  class TextFloatParticle {
      constructor(pos, text, paletteRange) {
          this.pos = { ...pos };
          this.text = text;
          this.paletteRange = paletteRange;
          this.t = -1;
          this.d = 30;
      }

      update() {
          if (++this.t === this.d) this.cull = true;
          this.pos.v -= 0.2;
          this.paletteColor = Math.round((this.paletteRange[1] - this.paletteRange[0]) * (this.t/this.d) + this.paletteRange[0]);
      }

      draw() {
          Text.drawText(Viewport.ctx, this.text, this.pos.u, this.pos.v, 1, Text.palette[this.paletteColor]);
      }
  }

  // WinkParticle


  class WinkParticle {
      constructor() {
          this.t = -1;
          this.d = 15;
          this.winkframe = 3;
          this.layer = 1;
      }

      update() {
          if (++this.t === this.d) {
              this.cull = true;
          }

          if (this.t === 2) {
              this.winkframe = 0;
          } else if (this.t === 6) {
              this.winkframe++;
          } else if (this.t === 8) {
              this.winkframe++;
          } else if (this.t === 10) {
              this.winkframe++;
          }
      }

      draw() {
          Viewport.ctx.drawImage(Sprite.wink[this.winkframe].img, 160 + 11 - 1, 73 - 30 + 9 - 2);
      }
  }

  // HelpScene


  class HelpScene {
      static pagesUnlocked = 4;
      static help = [
          {
              title: 'SANITY',
              text: 'The sanity of the village is already eroding. If it runs out before you accomplish your mission, you lose.',
              arrow: [278, 38]
          },
          {
              title: 'INFLUENCE',
              text: 'Use your influence to control villagers. The more villagers you have, the longer it takes to gain another.',
              arrow: [100, 3]
          },
          {
              title: 'JOBS',
              text: 'Use the arrow keys to switch jobs and change the number of villagers assigned to a job. As you unlock additional jobs, adjust the number of villagers assigned to accomplish your goals.',
              arrow: [65, 122]
          },
          {
              title: 'RESOURCES',
              text: 'Resources are produced constantly by villagers each turn. Some resources consume other resources to produce, so watch resource levels carefully.',
              arrow: [170, 128]
          }
      ];

      constructor(page) {
          this.page = page || 0;
          this.t = 0;
      }

      update() {
          this.t++;
          this.bounceX = Math.floor(Math.cos(this.t / 8) * 3);

          if (Input.pressed['ArrowRight']) {
              this.page = (this.page + 1) % HelpScene.pagesUnlocked;
          }

          if (Input.pressed['ArrowLeft']) {
              this.page = (this.page + HelpScene.pagesUnlocked - 1) % HelpScene.pagesUnlocked;
          }

          if (Input.pressed['Escape']) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = rgba(0, 0, 0, 0.66);
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          const page = HelpScene.help[this.page];

          const titleText = page.title.toUpperCase();
          const titleWidth = Text.measure(titleText, 1).w;
          Text.drawText(Viewport.ctx, titleText, (Viewport.width - titleWidth) / 2, 35, 1, Text.palette[4]);
          Text.drawParagraph(Viewport.ctx, page.text.toUpperCase(), 80, 50, 180, 1, Text.palette[4]);

          if (page.arrow) {
              Viewport.ctx.drawImage(Sprite.bigarrows[0].img, page.arrow[0] + this.bounceX, page.arrow[1]);
          }

          const helpText = `HELP PAGE ${this.page + 1}/${HelpScene.pagesUnlocked}    \\l\\r MORE HELP    \\e BACK`;
          const helpWidth = Text.measure(helpText, 1).w;
          Text.drawText(Viewport.ctx, helpText, (Viewport.width - helpWidth) / 2, 170, 1, Text.palette[4]);
      }
  }

  // DefeatScene


  class DefeatScene {
      constructor(stats) {
          this.stats = stats;

          this.text = [
              'THE LAST SPARK OF SANITY FADES IN ULTHAR, AND WITH IT',
              'ANY HOPE OF DELIVERANCE FOR YOU AND YOUR KIN.',
              '',
              'WOOD GATHERED: ' + this.stats.woodGathered,
              'MEAT BUTCHERED: ' + this.stats.meatGathered,
              'TORCHES CRAFTED: ' + this.stats.torchesCrafted,
              'STONE MINED: ' + this.stats.stoneGathered,
              'SECONDS SURVIVED: ' + this.stats.seconds
          ];
          this.frames = 0;
      }

      update() {
          this.frames++;

          if (Input.pressed['Space']) {
              game.scenes.pop();
          }
      }

      draw() {
          Viewport.ctx.fillStyle = '#0a1a2f';
          Viewport.ctx.fillRect(-5, 0, Viewport.width + 5, Viewport.height);

          const gameOverWidth = Text.measure('GAME OVER', 2).w;
          Text.drawText(Viewport.ctx, 'GAME OVER', (Viewport.width - gameOverWidth) / 2, 10, 2, Text.palette[4]);

          //Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 73 - 30);
          Viewport.ctx.drawImage(Sprite.blackcat[1].img, 160, 61 - 30);

          for (let i = 0; i < this.text.length; i++) {
              let width = Text.measure(this.text[i], 1).w;
              Text.drawText(Viewport.ctx, this.text[i], (Viewport.width - width) / 2, 80 + i * 10, 1, Text.palette[4]);
          }
      }
  }

  // GameScene


  const BUTTON_RECRUIT_VILLAGER = 0;
  const BUTTON_SACRIFICE_VILLAGER = 1;
  const BUTTON_REPAIR_BRIDGE = 2;
  const BUTTON_REPAIR_HALL = 3;
  const BUTTON_REPAIR_ALTAR = 4;
  const BUTTON_HELP = 5;

  class GameScene {
      constructor() {
          game.gameScene = this;
          this.entities = [];
          this.screenshakes = [];

          // Clock
          this.t = 0;
          this.influence = 5;
          this.sanity = 100;

          // Inventory
          this.meat = 0;
          this.wood = 0;
          this.stone = 0;
          this.torches = 0;

          // Playthrough Stats
          this.meatGathered = 0;
          this.woodGathered = 0;
          this.stoneGathered = 0;
          this.villagersRecruited = 0;
          this.torchesCrafted = 0;

          this.buttons = [];
          //this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button((320-80)/2, 15, 'V', 'Recruit Villager');
          //this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button((320-80)/2, 15, 'S', 'Sacrifice Villager');
          this.buttons[BUTTON_RECRUIT_VILLAGER] = new Button(5, 3, 'V', 'Recruit Villager');
          this.buttons[BUTTON_SACRIFICE_VILLAGER] = new Button(5, 13, 'S', 'Sacrifice Villager');
          this.buttons[BUTTON_REPAIR_BRIDGE] = new Button(5, 23, 'B', 'REPAIR BRIDGE');
          this.buttons[BUTTON_REPAIR_HALL] = new Button(5, 33, 'T', 'REPAIR TALLOW HALL');
          this.buttons[BUTTON_REPAIR_ALTAR] = new Button(5, 43, 'A', 'BUILD ALTAR');
          this.buttons[BUTTON_HELP] = new Button(285, 168, 'H', 'HELP');
          this.buttons[BUTTON_HELP].visible = true;
          this.buttons[BUTTON_HELP].active = true;

          this.selectedJob = WOODCUTTER;
          this.jobsDisplayed = [WOODCUTTER];

          this.villagers = [];
          this.villagersWithJob = [[], [], [], [], [], [], [], []];

          this.techBridge = false;
          this.techTorches = false;
          this.techStone = false;
          this.techAltar = false;
      }

      update() {
          // Set up displayed jobs
          this.jobsDisplayed = [WOODCUTTER];
          if (this.techBridge) {
              this.jobsDisplayed.push(BUTCHER);
          }
          if (this.techTorches) {
              this.jobsDisplayed.push(TALLOWER);
          }
          if (this.techStone) {
              this.jobsDisplayed.push(STONECUTTER);
          }

          if (this.torches > 0 && !this.techStone) {
              this.techStone = true;
          }

          // Player input

                  // move
          ///this.pos.x += this.vel.x;
          ///this.pos.y += this.vel.y;

          if (Input.pressed['KeyV']) {
              this.recruitVillager();
          }

          if (Input.pressed['KeyB']) {
              this.buildBridge();
          }

          if (Input.pressed['KeyT']) {
              this.buildHall();
          }

          if (Input.pressed['KeyA']) {
              this.buildAltar();
          }

          if (Input.pressed['ArrowDown']) {
              this.moveJobSelector(1);
          }

          if (Input.pressed['ArrowUp']) {
              this.moveJobSelector(-1);
          }

          if (Input.pressed['ArrowRight']) {
              this.hireVillager(this.selectedJob);
          }

          if (Input.pressed['ArrowLeft']) {
              this.fireVillager(this.selectedJob);
          }

          if (Input.pressed['KeyS']) {
              this.sacrificeVillager();
          }

          if (Input.pressed['Space']) {
              this.sanity -= 10;
          }

          if (Input.pressed['KeyH']) {
              game.scenes.push(new HelpScene());
          }

          // Game ticks

          this.t++;

          if (!this.nextSanityTick) {
              this.nextSanityTick = this.t + 12;
          }

          if (this.t >= this.nextSanityTick) {
              this.sanity -= 0.2;
              this.influence += 0.2;
              this.nextSanityTick = this.t + 12;
          }

          if (this.t === 4) ;

          // Button UI Elements

          this.buttons[BUTTON_RECRUIT_VILLAGER].active = (this.influence >= this.nextWorkerCost());
          this.buttons[BUTTON_RECRUIT_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_RECRUIT_VILLAGER].active);

          this.buttons[BUTTON_SACRIFICE_VILLAGER].active = (true);
          this.buttons[BUTTON_SACRIFICE_VILLAGER].visible = (this.villagersRecruited > 0 || this.buttons[BUTTON_SACRIFICE_VILLAGER].active);

          this.buttons[BUTTON_REPAIR_BRIDGE].active = (this.wood >= 10);
          this.buttons[BUTTON_REPAIR_BRIDGE].visible = !this.techBridge && this.wood >= 10;

          this.buttons[BUTTON_REPAIR_HALL].active = (this.wood >= 10);
          this.buttons[BUTTON_REPAIR_HALL].visible = this.techBridge && !this.techTorches && this.wood >= 10;

          this.buttons[BUTTON_REPAIR_ALTAR].active = (this.stone >= 10);
          this.buttons[BUTTON_REPAIR_ALTAR].visible = this.techTorches && !this.techAltar && this.stone >= 10;

          let visibleButtonY = 3;
          for (let i = 0; i < 5; i++) {
              if (this.buttons[i].visible) {
                  this.buttons[i].y = visibleButtonY;
                  visibleButtonY += 10;
              }
          }

          // Villagers

          for (const villager of this.villagers) {
              villager.update();
          }

          // Entities

          if (this.t > 35) {
              for (const entity of this.entities) {
                  entity.update();
              }
              this.entities = this.entities.filter(entity => !entity.cull);
          }

          // Check

          if (this.sanity < 0) {
              this.playerLost();
          }

          // Ash Particles

          if (this.entities.length < 33) {
              this.entities.push(new AshParticle());
          }
      }

      draw() {
          let terrainY = this.t > 36 ? 0 : (285 - 285 * this.t / 36);

          // Background

          Viewport.ctx.fillStyle = '#40985e';
          Viewport.ctx.fillRect(0, 0, Viewport.width + 5, Viewport.height);

          // Layer 3 (farthest)

          Viewport.ctx.drawImage(Sprite.terrain[2].img, 0, Math.floor(0 + terrainY * 0.8 * 0.8));

          for (let entity of this.entities) {
              if (entity.layer === 3) entity.draw();
          }

          for (let villager of this.villagers) {
              if (villager.layer === 2) villager.draw();
          }

          // Layer 2 (middle)

          Viewport.ctx.drawImage(Sprite.terrain[1].img, 0, Math.floor(0 + terrainY * 0.8));

          for (let entity of this.entities) {
              if (entity.layer === 2) entity.draw();
          }

          for (let villager of this.villagers) {
              if (villager.layer === 2) villager.draw();
          }

          // Layer 1 (closest)

          Viewport.ctx.drawImage(Sprite.terrain[0].img, 0, Math.floor(0 + terrainY));

          for (let entity of this.entities) {
              if (entity.layer === 1) entity.draw();
          }

          for (let villager of this.villagers) {
              if (villager.layer === 1) villager.draw();
          }

          // Black cat perch

          Viewport.ctx.drawImage(Sprite.blackcat[0].img, 160, 73 - 30);

          /*Viewport.ctx.fillStyle = '#0a1a2f';
          Viewport.ctx.fillRect(-5, Viewport.height - 31, Viewport.width + 5, 31);*/

          // Bridge

          if (this.t > 40) {
          if (this.techBridge) {
              Viewport.ctx.drawImage(Sprite.bridge[1].img, 112, 133 - 32);
          } else {
              Viewport.ctx.drawImage(Sprite.bridge[0].img, 112, 133 - 32);
          }

          // Tallower Hall

          if (this.techTorches) {
              Viewport.ctx.drawImage(Sprite.factory[1].img, 198, 133 - 32);
          } else {
              Viewport.ctx.drawImage(Sprite.factory[0].img, 198, 133 - 32);
          }

          // Altar

          if (this.techAltar) {
              let altarY = Math.floor(Math.sin(this.t / 25) * 2);
              Viewport.ctx.drawImage(Sprite.altar[0].img, 238, 116 - 30);
              Viewport.ctx.drawImage(Sprite.altar[1].img, 238, 115 - 30 + altarY);
          }

          /*
              // (Debug) raw numbers
              let crunk = String(Math.floor(this.sanity)) + ',' + String(Math.floor(this.influence)) + ',' + String(this.villagers.length);
              Text.drawText(Viewport.ctx, crunk, 3, 3, 1, Text.palette[1]);
          */

          if (game.scene === this) {
              // Hide button prompts if Help Screen is displayed, to avoid confusion
              for (const button of this.buttons) {
                  button.draw();
              }
          }

          this.drawSanityBar();
          this.drawInfluenceBar();
          this.drawJobSelectUI();
          this.drawInventory();
          }
      }

      drawSanityBar() {
          let k = Math.floor((this.sanity / 100) * 78);
          Viewport.ctx.drawImage(Sprite.sanitybar[0].img, 320-18-5, -3);
          Viewport.ctx.drawImage(Sprite.sanitybar[1].img, 320-18-5, -3);
          Viewport.ctx.drawImage(Sprite.sanitybar[2].img,
              0, 2 + (78 - k),
              18, k,
              320-18-5, -3 + 2 + (78 - k),
              18, k
          );
      }

      drawInfluenceBar() {
          let k = Math.floor(Math.min(this.influence / this.nextWorkerCost(), 1) * 80);
          Viewport.ctx.drawImage(Sprite.influencebar[0].img, (320-80)/2, 3);
          Viewport.ctx.drawImage(Sprite.influencebar[1].img,
              2, 3,
              k, 4,
              (320-80)/2 + 2, 3 + 3,
              k, 4
          );
      }

      drawJobSelectUI() {
          const cornerX = 7;
          const cornerY = 120;
          const verticalMargin = 10;

          let selectedIdx = 0;

          for (let i = 0; i < this.jobsDisplayed.length; i++) {
              if (this.selectedJob === this.jobsDisplayed[i]) {
                  selectedIdx = i;
              }

              const color = this.selectedJob === this.jobsDisplayed[i] ? Text.palette[3] : Text.palette[2];
              const numberText = String(this.villagersWithJob[this.jobsDisplayed[i]].length);
              const width = Text.measure(numberText).w;
              Text.drawText(Viewport.ctx, Villager.JOB_NAMES[this.jobsDisplayed[i]], cornerX + 5, cornerY + 4 + verticalMargin * i, 1, color);
              Text.drawText(Viewport.ctx, numberText, cornerX + 92 - width, cornerY + 4 + verticalMargin * i, 1, color);
          }

          const leftArrow = this.villagersWithJob[this.selectedJob].length > 0 ? 0 : 2;
          const rightArrow = this.villagersWithJob[IDLE].length > 0 ? 1 : 3;

          Viewport.ctx.drawImage(Sprite.jobselect[0].img, cornerX, cornerY + selectedIdx * verticalMargin);
          Viewport.ctx.drawImage(Sprite.smallarrows[leftArrow].img, cornerX + 77, cornerY + 4 + selectedIdx * verticalMargin);
          Viewport.ctx.drawImage(Sprite.smallarrows[rightArrow].img, cornerX + 94, cornerY + 4 + selectedIdx * verticalMargin);
      }

      drawInventory() {
          let woodWidth = Text.measure(String(this.wood), 1).w;
          let meatWidth = Text.measure(String(this.meat), 1).w;
          let stoneWidth = Text.measure(String(this.stone), 1).w;
          let torchWidth = Text.measure(String(this.torches), 1).w;

          Viewport.ctx.drawImage(Sprite.icons[0].img, INVENTORY_WOOD_POS.u - 60, INVENTORY_WOOD_POS.v - 1);
          Text.drawText(Viewport.ctx, 'WOOD', INVENTORY_WOOD_POS.u - 50, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);
          Text.drawText(Viewport.ctx, String(this.wood), INVENTORY_WOOD_POS.u - woodWidth, INVENTORY_WOOD_POS.v, 1, Text.palette[4]);

          if (this.techBridge) {
              Viewport.ctx.drawImage(Sprite.icons[2].img, INVENTORY_MEAT_POS.u - 60, INVENTORY_MEAT_POS.v - 1);
              Text.drawText(Viewport.ctx, 'MEAT', INVENTORY_MEAT_POS.u - 50, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.meat), INVENTORY_MEAT_POS.u - meatWidth, INVENTORY_MEAT_POS.v, 1, Text.palette[4]);
          }

          if (this.techTorches) {
              Viewport.ctx.drawImage(Sprite.icons[3].img, INVENTORY_TORCH_POS.u - 60, INVENTORY_TORCH_POS.v - 1);
              Text.drawText(Viewport.ctx, 'TORCHES', INVENTORY_TORCH_POS.u - 50, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.torches), INVENTORY_TORCH_POS.u - torchWidth, INVENTORY_TORCH_POS.v, 1, Text.palette[4]);
          }

          if (this.techStone) {
              Viewport.ctx.drawImage(Sprite.icons[1].img, INVENTORY_STONE_POS.u - 60, INVENTORY_STONE_POS.v - 1);
              Text.drawText(Viewport.ctx, 'STONE', INVENTORY_STONE_POS.u - 50, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
              Text.drawText(Viewport.ctx, String(this.stone), INVENTORY_STONE_POS.u - stoneWidth, INVENTORY_STONE_POS.v, 1, Text.palette[4]);
          }

      }

      addScreenShake(screenshake) {
          // This screen shake applies to the entire rendered screen, including GUI
          this.screenshakes.push(screenshake);
      }

      moveJobSelector(delta) {
          let idx = this.jobsDisplayed.indexOf(this.selectedJob);
          idx = (idx + delta + this.jobsDisplayed.length) % this.jobsDisplayed.length;
          this.selectedJob = this.jobsDisplayed[idx];
      }

      recruitVillager() {
          const cost = this.nextWorkerCost();
          if (this.influence >= cost) {
              this.influence -= cost;

              const villager = new Villager(this.selectedJob || WOODCUTTER);
              this.villagers.push(villager);
              this.villagersWithJob[villager.job].push(villager);
              this.villagersRecruited++;

              this.entities.push(new WinkParticle());
              return true;
          }

          return false;
      }

      hireVillager() {
          if (this.villagersWithJob[IDLE].length > 0) {
              // TODO
              const villager = this.villagersWithJob[IDLE].pop();
              villager.job = this.selectedJob;
              this.villagersWithJob[this.selectedJob].push(villager);
              return true;
          }
          return false;
      }

      fireVillager() {
          if (this.villagersWithJob[this.selectedJob].length > 0) {
              // TODO
              const villager = this.villagersWithJob[this.selectedJob].pop();
              villager.job = IDLE;
              this.villagersWithJob[IDLE].push(villager);
              return true;
          }
          return false;
      }

      sacrificeVillager() {
          if (this.villagersWithJob[this.selectedJob].length > 0) {
              // TODO - pick right villager
              const villager = this.villagersWithJob[this.selectedJob].pop();

              this.villagers.splice(this.villagers.indexOf(villager), 1);

              this.entities.push(new SacrificeParticle(villager));
              this.entities.push(new WinkParticle());

              //villager.job = SACRIFICE;
              //this.villagersWithJob[SACRIFICE].push(villager);
              //this.activeSacrifice = new SacrificeParticle();
              //console.log('VILLAGER DEAD');
              return true;
          }
          return false;
      }

      consumeMeat() {
          if (this.meat > 0) {
              this.meat--;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-1', [4, 2]));
          } else {
              this.sanity--;
              this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '-1', [0, 2]));
          }
      }

      grantSanity(value) {
          if (this.sanity < 100) {
              this.sanity = Math.min(100, this.sanity + value);
              this.entities.push(new TextFloatParticle({ u: SANITY_POS.u, v: SANITY_POS.v }, '+' + value, [0, 2]));
          }
      }

      gatherMeat() {
          this.meat += 5;
          this.meatGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '+5', [4, 2]));
      }

      gatherWood() {
          this.wood += 5;
          this.woodGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '+5', [4, 2]));
      }

      craftTorch() {
          this.torches += 1;
          this.torchesCrafted += 1;
          this.wood -= 2;
          this.meat -= 2;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: INVENTORY_TORCH_POS.u + 6, v: INVENTORY_TORCH_POS.v }, '+1', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-2', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_MEAT_POS.u + 6, v: INVENTORY_MEAT_POS.v }, '-2', [4, 2]));
      }

      gatherStone() {
          this.stone += 5;
          this.stoneGathered += 5;
          this.consumeMeat();
          this.entities.push(new TextFloatParticle({ u: 100, v: 100 }, '+5', [4, 2]));
          this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '+5', [4, 2]));
      }

      buildBridge() {
          const button = this.buttons[BUTTON_REPAIR_BRIDGE];

          if (button.active && button.visible && this.wood >= 10 && !this.techBridge) {
              this.wood -= 10;
              this.techBridge = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

              // TODO build bridge animation
          }
      }

      buildHall() {
          const button = this.buttons[BUTTON_REPAIR_HALL];

          if (button.active && button.visible && this.wood >= 10 && !this.techTorches) {
              this.wood -= 10;
              this.techTorches = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_WOOD_POS.u + 6, v: INVENTORY_WOOD_POS.v }, '-10', [4, 2]));

              // TODO build hall animation
          }
      }

      buildAltar() {
          const button = this.buttons[BUTTON_REPAIR_ALTAR];

          if (button.active && button.visible && this.stone >= 10 && !this.techAltar) {
              this.stone -= 10;
              this.techAltar = true;
              this.entities.push(new TextFloatParticle({ u: INVENTORY_STONE_POS.u + 6, v: INVENTORY_STONE_POS.v }, '-10', [4, 2]));

              // TODO build altar animation
          }
      }

      nextWorkerCost() {
          return Math.floor(1 * Math.pow(1.3, this.villagers.length));
      }

      playerLost() {
          const stats = {
              seconds: Math.floor(this.t / 60),
              woodGathered: this.woodGathered,
              meatGathered: this.meatGathered,
              torchesCrafted: this.torchesCrafted,
              stoneGathered: this.stoneGathered,
          };
          game.scenes.pop();
          game.scenes.push(new DefeatScene(stats));
      }
  }

  // IntroScene


  class IntroScene {
      constructor() {
          this.text = [
              'HAROLD',
              'IS',
              'HEAVY'
          ];
          this.pos = [
              { y: -20 },
              { y: -20 },
              { y: -20 }
          ];
          this.vel = [
              { y: 0 },
              { y: 0 },
              { y: 0 }
          ];
          this.screenshakes = [];
          this.t = 0;
          this.fadet = -1;
          this.entities = [];
      }

      update() {
          this.t++;

          if (this.fadet >= 0) this.fadet++;

          if (this.fadet === 1) {
              Audio.initTracks();
          }

          if (this.fadet > 20) {
              game.scenes.pop();

              const gameScene = new GameScene();
              game.scenes.push(gameScene);
              gameScene.entities = this.entities;
          }

          if (Input.pressed['Space']) {
              this.fadet = 0;
          }

          if (this.entities.length < 33) {
              this.entities.push(new AshParticle());
          }

          for (let entity of this.entities) {
              entity.update();
          }

          this.entities = this.entities.filter(entity => !entity.cull);
      }

      draw() {
          Viewport.ctx.fillStyle = PALETTE[0];
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);

          Viewport.ctx.globalAlpha = Math.min(this.t / 20, 1);
          Viewport.ctx.fillStyle = PALETTE[3];
          Viewport.ctx.fillRect(0, 0, Viewport.width, Viewport.height);
          Viewport.ctx.globalAlpha = 1;

          for (let entity of this.entities) {
              entity.draw();
          }

          if (this.t > 30) {
              let adjustment = Math.max(1 - this.t / 54, 0);

              if (!this.x || this.t % 3 === 0) {
                  this.x = [0,1,2,3,4,5,6,7,8].map(x => adjustment * (Math.random() * 12 - 6));
                  this.alpha = [0,1,2,3,4,5,6,7,8].map(x => 1 - adjustment * Math.random());
              }

              for (let i = 0; i < 9; i++) {
                  let y = i * 4;
                  Viewport.ctx.globalAlpha = this.alpha[i];
                  Viewport.ctx.drawImage(Sprite.blackcat[0].img, 0, y, 24, 4, 160 + this.x[i], 73 - 30 + y, 24, 4);
                  Viewport.ctx.globalAlpha = 1;
              }
          }

          if (this.t > 40) {
              let title = 'THE ASHES OF ULTHAR';
              let titleWidth = Text.measure(title, 2).w;
              Text.drawText(Viewport.ctx, title, 168 - titleWidth / 2, 13 - this.fadet * 3, 2, Text.palette[4], Text.palette[1]);
          }

          if (this.t > 48 && this.fadet < 0) {
              let text = 'PRESS SPACE TO PLAY';
              let width = Text.measure(text, 1).w;
              Text.drawText(Viewport.ctx, text, 168 - width / 2, 150, 1, Text.palette[4], Text.palette[1]);
          }
      }
  }

  // Game


  /**
   * Game state.
   */
  class Game {
      init() {
          Sprite.loadSpritesheet(() => {
              Viewport.init();
              Sprite.init();
              Text.init();
              Input.init();
              Audio.init();

              //Camera.init();

              window.addEventListener('blur', () => this.pause());
              window.addEventListener('focus', () => this.unpause());

              this.reset();
              this.start();
          });
      }

      reset() {
          this.scenes = [];
          this.lastFrame = 0;
          this.nextLevel = 0;

          this.scores = [
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 },
              { time: 300 * 60, enemiesAlive: 10 }
          ];

          this.scenes.push(new IntroScene());
      }

      start() {
          this.frame = 0;
          this.framestamps = [0];
          this.update();
          window.requestAnimationFrame((xyz) => this.onFrame(xyz));
      }

      onFrame(currentms) {
          let delta = (currentms - this.lastFrame) - (1000 / FPS);

          if (delta >= 0) {
              this.frame++;
              this.lastFrame = (currentms - delta);

              // The above calculation is right for smoothing out frames, but if
              // we end up far behind the currentms, we can "fast play" for a long time
              // which is not desired. Fast-forward if we fall behind more than 5 frames.
              if (currentms - this.lastFrame > 5 * 1000 / FPS) {
                  this.lastFrame = currentms;
              }

              Viewport.resize();
              this.update();
              this.draw(Viewport.ctx);

              // this.framestamps.push(currentms);
              // if (this.framestamps.length >= 120) {
              //     this.framestamps.shift();
              // }
              // this.fps = 1000 / ((this.framestamps[this.framestamps.length - 1] - this.framestamps[0]) / this.framestamps.length);
          }
          window.requestAnimationFrame((xyz) => this.onFrame(xyz));
      }

      update() {
          // Gather user input
          Input.update();

          // Handle special keys that are screen-independent
          if (Input.pressed['KeyM']) {
              console.log('KeyM - toggling music');
              Audio.musicEnabled = !Audio.musicEnabled;
          }
          /*if (Input.pressed[Input.Action.SFX_TOGGLE]) {
              Audio.sfxEnabled = !Audio.sfxEnabled;
          }*/

          // Hand off control to the current "screen" (for example, game screen or menu)
          if (this.scenes.length === 0) {
              this.scenes.push(new GameScene());
          }
          this.scene = this.scenes[this.scenes.length - 1];
          this.scene.update();

          // Do per-frame audio updates
          Audio.update();
      }

      draw() {
          // Reset canvas transform and scale
          Viewport.ctx.setTransform(1, 0, 0, 1, 0, 0);
          Viewport.ctx.scale(Viewport.scale, Viewport.scale);

          for (let i = 0; i < this.scenes.length; i++) {
              this.scenes[i].draw();
          }

          //Text.drawText(Viewport.ctx, String(this.fps), 15, 15, 1, Text.white);
      }

      pause() {
          if (this.paused) return;
          this.paused = true;
          Audio.pause();
      }

      unpause() {
          if (!this.paused) return;
          this.paused = false;
          Audio.unpause();
      }
  }

  const game = new Game();

  /**
   * Create and launch game.
   */
  game.init();

})();</script>